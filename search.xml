<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LoopyCuts 编译运行记录</title>
    <url>/2023/09/03/LoopyCuts%20%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="一、项目准备"><a href="#一、项目准备" class="headerlink" title="一、项目准备"></a>一、项目准备</h1><h2 id="1-1-项目下载"><a href="#1-1-项目下载" class="headerlink" title="1.1 项目下载"></a>1.1 项目下载</h2><p>项目地址：<a class="link"   href="https://github.com/mlivesu/LoopyCuts" >LoopyCuts: Practical Feature-Preserving Block Decomposition for Strongly Hex-Dominant Meshing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>使用命令下载：<code>git clone --recursive https://github.com/mlivesu/LoopyCuts.git</code></p>
<h2 id="1-2-IDE-和编译器"><a href="#1-2-IDE-和编译器" class="headerlink" title="1.2 IDE 和编译器"></a>1.2 IDE 和编译器</h2><p>笔者使用的 IDE 和编译器版本记录如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Qt Creator 11.0.2</span><br><span class="line">Qt 编译器 Desktop Qt 5.15.2 MSVC2019 64bit</span><br><span class="line">Cmake 3.27.0</span><br><span class="line">Visual Studio Community 2022 17.6.5</span><br></pre></td></tr></table></figure></div>

<h1 id="二、Loop-Distributor"><a href="#二、Loop-Distributor" class="headerlink" title="二、Loop Distributor"></a>二、Loop Distributor</h1><h2 id="2-1-输入和输出"><a href="#2-1-输入和输出" class="headerlink" title="2.1 输入和输出"></a>2.1 输入和输出</h2><h3 id="2-1-1-输入"><a href="#2-1-1-输入" class="headerlink" title="2.1.1 输入"></a>2.1.1 输入</h3><p>根据官方文档，输入是一个网格，并通过命令行传递网格路径。网格可以是 <code>.obj</code> 文件或 <code>.ply</code> 文件，要求在同一文件夹中有一个 <code>.rosy</code> 文件和一个 <code>.sharp</code> 文件，与网格文件的名称相同。</p>
<p>Rosy 文件格式：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn                   // 网格面数</span><br><span class="line">4                    // 场的方向（交叉场始终为 4）</span><br><span class="line">x0 y0 z0             // 第一个面的交叉场向量的 xyz 方向</span><br><span class="line">...</span><br><span class="line">xn yn zn             // 第 n 个面的交叉场向量的 xyz 方向</span><br></pre></td></tr></table></figure></div>

<p>Sharp 文件格式：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sn                   // 锐利特征的数量</span><br><span class="line">t0 f0 e0             // 对于每个锐边：如果边缘是凹的，则第一个整数是 0；如果是凸的，则第一个整数是 1；然后是锐边索引</span><br><span class="line">...</span><br><span class="line">tn fn en             // 第 n 个锐边</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-2-输出"><a href="#2-1-2-输出" class="headerlink" title="2.1.2 输出"></a>2.1.2 输出</h3><p><code>_splitted</code> 网格文件和 <code>_loop</code>文件：跟踪和拆分的网格 </p>
<p>Loop 文件格式</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln                  		// 切割环数量</span><br><span class="line">for each loop:</span><br><span class="line">REGULAR|CONCAVE|CONVEX      // 切割环种类</span><br><span class="line">Closed|Open                 // 切割环是否已成功闭合</span><br><span class="line">Cross OK|FAIL               // 切割环是否具有适合切割拓扑的交叉数量</span><br><span class="line">en                          // 切割环的边数量</span><br><span class="line">indexF indexE 0|1           // 平面、边的索引以及是否位于锐利特征上</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-GLEW-库"><a href="#2-2-GLEW-库" class="headerlink" title="2.2 GLEW 库"></a>2.2 GLEW 库</h2><p>GLEW（OpenGL Extension Wrangler Library）是一个用于管理 OpenGL 扩展的跨平台 C&#x2F;C++ 库。 GLEW 在运行时自动检测可用的 OpenGL 扩展，并提供函数指针和常量来使用它们。</p>
<h3 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h3><p>项目地址：<a class="link"   href="https://github.com/Perlmint/glew-cmake" >glew-cmake: GLEW with Cmake and pre-generated sources<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>使用命令下载：<code>git clone https://github.com/Perlmint/glew-cmake.git </code> </p>
<h3 id="2-2-2-编译"><a href="#2-2-2-编译" class="headerlink" title="2.2.2 编译"></a>2.2.2 编译</h3><p>IDE：Visual Studio Community 2022 17.6.5</p>
<p>使用 VS 打开 <code>glew-cmake\build\vc15\glew.sln</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423675.png"
                      alt="image-20230823110820650" style="zoom: 67%;" 
                >

<p>在重定向项目时选择 确定</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423676.png"
                      alt="image-20230823110941295" style="zoom: 67%;" 
                >

<p><code>glew_shared</code> 编译得到动态链接库，<code>glew_static</code> 编译得到静态链接库，此处我们需要静态链接库。编译选项选择 Release x64，在 解决方案资源管理器中右击 <code>glew_static</code>，选择 仅用于项目(J)-&gt;仅生成 glew_static(B)</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423677.png"
                      alt="image-20230823111811575" style="zoom:67%;" 
                >

<p>编译完成之后，在 <code>glew-cmake\lib\Release\x64</code> 目录下能够看到 <code>glew32s.lib</code> 和 <code>glew32s.pdb</code> 两个文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423678.png"
                      alt="image-20230823112315799" style="zoom:67%;" 
                >

<h3 id="2-2-3-部署"><a href="#2-2-3-部署" class="headerlink" title="2.2.3 部署"></a>2.2.3 部署</h3><p>将 <code>glew-cmake</code> 文件夹复制到 <code>LoopyCuts\lib</code> 文件夹下，并将其重命名为 <code>glew</code>，同时我们只需要 <code>glew\lib</code> 和 <code>glew\include</code> 两个文件夹下的文件，可以删除 <code>glew</code> 下的其他子文件夹。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423679.png"
                      alt="image-20230823113338697" style="zoom:67%;" 
                >

<h2 id="2-3-编译"><a href="#2-3-编译" class="headerlink" title="2.3 编译"></a>2.3 编译</h2><h3 id="2-3-1-导入和配置"><a href="#2-3-1-导入和配置" class="headerlink" title="2.3.1 导入和配置"></a>2.3.1 导入和配置</h3><p>使用 Qt Creator 打开 <code>LoopyCuts\loop_distribution\loop_distributor.pro</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423680.png"
                      alt="image-20230823122855102" style="zoom:67%;" 
                >

<p>选择编译器 <code>Desktop Qt 5.15.2 MSVC2019 64bit</code> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423681.png"
                      alt="image-20230823123145661" style="zoom:67%;" 
                >

<p>构建选择 <code>Release</code> 版本</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423682.png"
                      alt="image-20230823123504706" style="zoom:67%;" 
                >

<p>项目需要额外导入 <code>OpenGL32</code> 、 <code>GlU32</code> 和 <code>AntTweakBar64</code> 库，同时需要将事先编译好的 <code>glew</code> 库导入，需要注意导入的路径，修改 <code>loop_distributor.pro</code> 中的 <code>win32</code> 配置项为：</p>
<div class="code-container" data-rel="Qt"><figure class="iseeu highlight qt"><figcaption><span>config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title">win32</span>&#123;</span><br><span class="line">  DEFINES += NOMINMAX</span><br><span class="line">  LIBS += -lOpenGL32</span><br><span class="line">  LIBS += -lGlU32</span><br><span class="line">  LIBS += $$ANTDIR/lib/AntTweakBar.lib</span><br><span class="line">  LIBS += -L$$ANTDIR/lib/ -lAntTweakBar64</span><br><span class="line">  LIBS += -L$$PWD/../lib/glew/lib/Release/x64/ -lglew32s</span><br><span class="line">  INCLUDEPATH += $$PWD/../lib/glew/include</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要在代码中导入 <code>glew</code> 库，在 <code>glwidget.h</code> 中取消 <code> #include &lt;GL/glew.h&gt;</code> 的注释，并在之前添加 <code> #define GLEW_STATIC</code> ，或者在 <code>#define GLWIDGET_H</code> 之后添加：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-2-编译和运行"><a href="#2-3-2-编译和运行" class="headerlink" title="2.3.2 编译和运行"></a>2.3.2 编译和运行</h3><p>在 项目-&gt;运行-&gt;Command line arguments 中添加网格的路径，可以使用 <code>test_data</code> 中的数据，例如 <code>..\test_data\bearing_plate\bearing_plate_rem.obj</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423683.png"
                      alt="image-20230823131231960" style="zoom:67%;" 
                >

<p>点击运行按钮编译运行即可</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423684.png"
                      alt="image-20230823131811329" style="zoom:67%;" 
                >

<h1 id="三、Volumetric-Cutter"><a href="#三、Volumetric-Cutter" class="headerlink" title="三、Volumetric Cutter"></a>三、Volumetric Cutter</h1><h2 id="3-1-输入和输出"><a href="#3-1-输入和输出" class="headerlink" title="3.1 输入和输出"></a>3.1 输入和输出</h2><p>该部分读取上一步生成的细化网格和切割环路，并输出六面体网格。</p>
<h3 id="3-1-1-输入"><a href="#3-1-1-输入" class="headerlink" title="3.1.1 输入"></a>3.1.1 输入</h3><p>在第二章中得到的 <code>_splitted</code> 网格文件和 <code>_loop</code> 文件</p>
<h3 id="3-1-2-输出"><a href="#3-1-2-输出" class="headerlink" title="3.1.2 输出"></a>3.1.2 输出</h3><p>尽管几乎完全由六面体组成，但输出网格可能包含任意多面体，这些多面体无法以流行的体积网格格式（例如 <code>.mesh</code> 和 <code>.vtk</code>）进行编码。 因此，所有的输出都使用 <code>.hedra</code> 格式进行编码，其结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nv nf np             // 顶点数、面数和多面体数</span><br><span class="line">x0 y0 z0             // 第 1 个顶点点的 xyz 坐标</span><br><span class="line">x1 y1 z1             // 第 2 个顶点点的 xyz 坐标</span><br><span class="line">...                  // </span><br><span class="line">f0 v1 v2 ... vf1     // f1：第 1 个面的顶点数，后跟（CCW 顺序）顶点列表</span><br><span class="line">f1 v1 v2 ... vf2     // f2: 第 2 个面的顶点数，后跟（CCW 顺序）顶点列表</span><br><span class="line">...                  //</span><br><span class="line">p1  f1 -f2 ...  fp1  // p1：第 1 个多面体的面数，后面是面列表</span><br><span class="line">p2 -f1  f2 ... -fp2  // p2: 第 2 个多面体的面数，后面是面列表</span><br><span class="line">...                  // （带有负数的引用（例如 -f）表示面 |f| 被多面体视为 CW）</span><br></pre></td></tr></table></figure></div>

<p>如果输出是完整的六面体网格，还将生成 <code>.mesh</code> 文件。</p>
<h2 id="3-2-Tetgen-库"><a href="#3-2-Tetgen-库" class="headerlink" title="3.2 Tetgen 库"></a>3.2 Tetgen 库</h2><p>Tetgen 库是一个用于生成三维 Delaunay 三角剖分和约束性 Delaunay 三角剖分的软件包。它可以用于创建三维网格，如四面体网格、多面体网格和混合网格。它还可以用于计算三维凸包、Voronoi 图和 alpha shapes。</p>
<h3 id="3-2-1-下载"><a href="#3-2-1-下载" class="headerlink" title="3.2.1 下载"></a>3.2.1 下载</h3><p>下载地址：<a class="link"   href="https://wias-berlin.de/software/index.jsp?id=TetGen&lang=1" >WIAS-Software (wias-berlin.de)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="3-2-2-编译"><a href="#3-2-2-编译" class="headerlink" title="3.2.2 编译"></a>3.2.2 编译</h3><p>首先使用 <code>Cmake</code> 生成 <code>.sln</code> 项目工程文件，命令如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423685.png"
                      alt="image-20230823232944900" style="zoom:67%;" 
                >

<p>使用 VS 打开 <code>Project.sln</code> ，编译选项选择 Release x64，在 解决方案资源管理器中右击 <code>tet</code>，选择 仅用于项目(J)-&gt;仅生成 tet(B)</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423686.png"
                      alt="image-20230823233153485" style="zoom:67%;" 
                >

<p>生成完成后可以在 <code>tetgen1.6.0\build\Release</code> 找到 <code>tet.lib</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423687.png"
                      alt="image-20230823233318387" style="zoom:67%;" 
                >

<h3 id="3-2-3-部署"><a href="#3-2-3-部署" class="headerlink" title="3.2.3 部署"></a>3.2.3 部署</h3><p>在 <code>LoopyCuts\lib</code> 下新建文件夹 <code>tetgen</code>，并在 <code>LoopyCuts\lib\tetgen</code> 下新建 <code>include</code> 和 <code>lib</code> 文件夹，然后将 <code>tetgen1.6.0\build\Release\tet.lib</code> 复制到 <code>LoopyCuts\lib\tetgen\lib</code> 下，将 <code>tetgen1.6.0\tetgen.h</code> 复制到 <code>LoopyCuts\lib\tetgen\include</code> 下 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423688.png"
                      alt="image-20230823233649870" style="zoom:67%;" 
                >

<h2 id="3-3-编译"><a href="#3-3-编译" class="headerlink" title="3.3 编译"></a>3.3 编译</h2><h3 id="3-3-1-配置和导入"><a href="#3-3-1-配置和导入" class="headerlink" title="3.3.1 配置和导入"></a>3.3.1 配置和导入</h3><p>使用 Qt Creator 打开 <code>LoopyCuts\volumetric_cutter\volumetric_cutter.pro</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423689.png"
                      alt="image-20230823234632559" style="zoom:67%;" 
                >

<p>选择编译器 <code>Desktop Qt 5.15.2 MSVC2019 64bit</code> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423690.png"
                      alt="image-20230823234747986" style="zoom:67%;" 
                >

<p>构建选择 <code>Debug</code> 版本</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423691.png"
                      alt="image-20230903031327235" style="zoom:67%;" 
                >

<p>项目需要额外导入 <code>OpenGL32</code> 和 <code>GlU32</code> 库，同时需要将事先编译好的 <code>tetgen</code> 库导入，需要注意导入的路径，在 <code>volumetric_cutter.pro</code> 中的添加配置项为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFINES     += NOMINMAX</span><br><span class="line">INCLUDEPATH += $$PWD/../lib/tetgen/include</span><br><span class="line">LIBS        += -L$$PWD/../lib/tetgen/lib/ -ltet</span><br><span class="line">LIBS        += -lOpenGL32</span><br><span class="line">LIBS        += -lGlU32</span><br></pre></td></tr></table></figure></div>

<p>需要删除或注释掉的配置项为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">QMAKE_CXXFLAGS += -Wno-deprecated-declarations</span><br><span class="line">INCLUDEPATH *= /usr/local/include</span><br><span class="line">LIBS        += -L/usr/local/lib -ltet</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-2-编译和错误修正"><a href="#3-3-2-编译和错误修正" class="headerlink" title="3.3.2 编译和错误修正"></a>3.3.2 编译和错误修正</h3><p><strong>1、<code>gl.h</code> 中出现大量报错</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\gl\GL.h:1157: error: C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\gl\GL.h:1157: error: C2182: “APIENTRY”: “void” 这一使用无效</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\gl\GL.h:1157: error: C2144: 语法错误:“void”的前面应有“;”</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\gl\GL.h:1157: error: C2146: 语法错误: 缺少“;”(在标识符“glAccum”的前面)</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\gl\GL.h:1157: error: C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int</span><br><span class="line">······</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：头文件导入错误</p>
<p><strong>修正方法</strong>：在 <code>LoopyCuts\lib\cinolib\include\cinolib\gl\draw_lines_tris.h</code> 中的 window 编译选项中添加 <code>#include &lt;windows.h&gt;</code>，添加完成后的编译选项为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  <span class="comment">// 添加了此行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/gl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>2、<code>octree.cpp</code>  中出现的错误</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoopyCuts\lib\cinolib\include\cinolib\octree.cpp:661: error: C2664: “cinolib::AABB::AABB(const cinolib::AABB &amp;)”: 无法将参数 1 从“initializer list”转换为“const cinolib::AABB &amp;”</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：参数传递错误</p>
<p><strong>修正方法</strong>：将 <code>LoopyCuts\lib\cinolib\include\cinolib\octree.cpp</code> 中的 661 行 <code>AABB s_box(&#123;s[0], s[1]&#125;);</code> 修改为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AABB <span class="title">s_box</span><span class="params">(s[<span class="number">0</span>],s[<span class="number">1</span>])</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>3、<code>hexmesh.cpp</code> 中出现的错误</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoopyCuts\lib\cinolib\include\cinolib\meshes\hexmesh.cpp:405: error: C2039: &quot;update_hex_quality&quot;: 不是 &quot;cinolib::Hexmesh&lt;MM,MV,ME,MF,MP&gt;&quot; 的成员</span><br><span class="line">LoopyCuts\lib\cinolib\include\cinolib\meshes\hexmesh.cpp:415: error: C2039: &quot;update_hex_quality&quot;: 不是 &quot;cinolib::Hexmesh&lt;MM,MV,ME,MF,MP&gt;&quot; 的成员</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：成员函数调用错误</p>
<p><strong>修正方法</strong>：在 <code>LoopyCuts\lib\cinolib\include\cinolib\meshes\hexmesh.cpp</code> 中</p>
<p>将 405 行 <code>this-&gt;update_hex_quality(pid);</code> 修改为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this-&gt;update_p_quality(pid);</span><br></pre></td></tr></table></figure></div>

<p>将  415 行 <code>this-&gt;update_hex_quality();</code> 修改为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this-&gt;update_quality();</span><br></pre></td></tr></table></figure></div>

<p><strong>4、<code>laplacian.cpp</code> 中出现的错误</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoopyCuts\lib\cinolib\include\cinolib\laplacian.cpp:54: error: C2131: 表达式的计算结果不是常数</span><br><span class="line">LoopyCuts\lib\cinolib\include\cinolib\laplacian.cpp:55: error: C3863: 不可指定数组类型“uint [n]”</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：MSVC 编译器不支持变长数组的声明，需要修改为动态数组</p>
<p><strong>修正方法</strong>：将 <code>LoopyCuts\lib\cinolib\include\cinolib\laplacian.cpp</code> 中的 54 行 <code>uint base[n];</code> 修改为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">uint *base = <span class="keyword">new</span> uint[n]();</span><br></pre></td></tr></table></figure></div>

<p>并在 80 行添加：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] base;</span><br></pre></td></tr></table></figure></div>

<p><strong>5、<code>ambient_occlusion.cpp</code> 中出现的错误</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoopyCuts\lib\cinolib\include\cinolib\ambient_occlusion.cpp:195: error: C2131: 表达式的计算结果不是常数</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：MSVC 编译器不支持变长数组的声明，需要修改为动态数组</p>
<p><strong>修正方法</strong>：将 <code>LoopyCuts\lib\cinolib\include\cinolib\ambient_occlusion.cpp</code>中的 195 行 <code>float depth_buffer[buffer_size*buffer_size];</code> 修改为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> *depth_buffer = <span class="keyword">new</span> <span class="type">float</span>[buffer_size*buffer_size]();</span><br></pre></td></tr></table></figure></div>

<p>并在 219 行添加：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete [] depth_buffer;</span><br></pre></td></tr></table></figure></div>

<p><strong>6、<code>draw_lines_tris.cpp</code> 中出现的错误</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoopyCuts\lib\cinolib\include\cinolib\gl\draw_lines_tris.cpp:160: error: C3861: “glGenerateMipmap”: 找不到标识符</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：<code>glGenerateMipmap()</code> 函数在 OpenGl 3.0 中出现，Windows 默认的 OpenGl 版本为 1.1</p>
<p><strong>修正方法</strong>：在 <code>LoopyCuts\lib\cinolib\include\cinolib\gl\draw_lines_tris.h</code> 中的 window 编译选项中添加 <code>#include &lt;QOpenGLWidget&gt;</code> 和 <code>#include &lt;QOpenGLFunctions_4_5_Core&gt;</code>，添加完成后的编译选项为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QOpenGLWidget&gt;</span>				<span class="comment">// 添加了此行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QOpenGLFunctions_4_5_Core&gt;</span>	<span class="comment">// 添加了此行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/gl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>并在 98 行添加如下代码：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CinoInline</span> : <span class="keyword">public</span> QOpenGLWidget, QOpenGLFunctions_4_5_Core</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render_tris</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render_segs</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>将 <code>LoopyCuts\lib\cinolib\include\cinolib\gl\draw_lines_tris.cpp</code> 中的 <code>render_tris(const RenderData &amp; data)</code>、<code>render_segs(const RenderData &amp; data)</code> 和 <code>render(const RenderData &amp; data)</code> 函数实现前添加 <code>CinoInline::</code></p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CinoInline::render_tris</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CinoInline::render_segs</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CinoInline::render</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span></span><br></pre></td></tr></table></figure></div>

<p>并在 <code>void CinoInline::render(const RenderData &amp; data)</code> 函数中的第一行添加：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">initializeOpenGLFunctions</span>();</span><br></pre></td></tr></table></figure></div>

<p>并在 269 行添加如下代码：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CINO_INLINE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> RenderData &amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CinoInline cino_in_line;</span><br><span class="line">    cino_in_line.<span class="built_in">render</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>7、出现 Assertion failed 错误弹窗</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423692.png"
                      alt="image-20230903030027721" style="zoom:67%;" 
                >

<p><strong>原因</strong>：代码未完成错误</p>
<p><strong>修正方法</strong>：将 <code>LoopyCuts\lib\cinolib\include\cinolib\memory_usage.cpp</code> 中的第 63 行开始的 window 编译分支修改为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    <span class="built_in">GetProcessMemoryInfo</span>(<span class="built_in">GetCurrentProcess</span>(), &amp;pmc, <span class="built_in">sizeof</span>(pmc));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>) pmc.WorkingSetSize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>8、运行带 GUI 版本时程序崩溃</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">F:\QT\LoopyCuts\build-volumetric_cutter-Desktop_Qt_5_15_2_MSVC2019_64bit-Debug\debug\volumetric_cutter.exe 崩溃。</span><br></pre></td></tr></table></figure></div>

<p><strong>原因</strong>：迭代器越界</p>
<p><strong>修正方法</strong>：将 <code>LoopyCuts\volumetric_cutter\loops.cpp</code> 中的第 208 - 214 行的循环修改为：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = l.drawlist.<span class="built_in">begin</span>(); i != l.drawlist.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">    <span class="built_in">glVertex3dv</span>(i-&gt;<span class="built_in">ptr</span>());</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-3-运行"><a href="#3-3-3-运行" class="headerlink" title="3.3.3 运行"></a>3.3.3 运行</h3><p>运行命令为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./volumetric_cutter &lt;mesh&gt; &lt;loops&gt; [ -batch-mode &lt;output_folder&gt; ]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>mesh 是三角形网格，为以 <code>_splitted</code> 结尾的格式为 <code>.off</code> 或 <code>.obj</code> 的文件</li>
<li>Loops 是以 <code>_loop</code> 结尾的格式为 <code>.txt</code> 的文本文件</li>
</ul>
<p>注意：如果指定 <code>-batch-mode</code>，程序将在没有 GUI 的情况下运行，并按给定顺序处理所有切割环，直到收敛。 多面体网格将在输出中生成并保存在 <code>&lt;output_folder&gt;</code> 中。</p>
<p>1、带有 GUI 的版本</p>
<p>在 项目-&gt;运行-&gt;Command line arguments 中添加 <code>_splitted</code> 网格文件和 <code>_loop</code> 切割环文件的路径，可以使用 <code>test_data</code> 中的数据，例如： </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">..\test_data\bearing_plate\bearing_plate_rem_splitted.obj ..\test_data\bearing_plate\bearing_plate_rem_loop.txt</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423693.png"
                      alt="image-20230824004603982" style="zoom:67%;" 
                >

<p>点击运行按钮编译运行即可</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423694.png"
                      alt="image-20230903033425559" style="zoom:67%;" 
                >



<p>2、不带 GUI 版本</p>
<p>在 项目-&gt;运行-&gt;Command line arguments 中添加完整的命令，可以使用 <code>test_data</code> 中的数据，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">..\test_data\bearing_plate\bearing_plate_rem_splitted.obj ..\test_data\bearing_plate\bearing_plate_rem_loop.txt -batch-mode .</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Xiaolong-Work/figure/master/202309030423695.png"
                      alt="image-20230903031508781" style="zoom:67%;" 
                >

<p>点击运行按钮编译运行即可</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting F:\QT\LoopyCuts\build-volumetric_cutter-Desktop_Qt_5_15_2_MSVC2019_64bit-Debug\debug\volumetric_cutter.exe ..\test_data\bearing_plate\bearing_plate_rem_splitted.obj ..\test_data\bearing_plate\bearing_plate_rem_loop.txt -batch-mode ....</span><br><span class="line"></span><br><span class="line">input mesh  : ..\test_data\bearing_plate\bearing_plate_rem_splitted.obj</span><br><span class="line">input loops : ..\test_data\bearing_plate\bearing_plate_rem_loop.txt</span><br><span class="line">batch mode  : 1</span><br><span class="line">output mesh : .</span><br><span class="line"></span><br><span class="line">load mesh	12605V / 37839E / 25226P  [0.60409s]</span><br><span class="line">load mesh	20646V / 120662E / 187411F / 87399P  [20.2652s]</span><br><span class="line">131 loops found</span><br><span class="line">Loop 0	114 segs	CONCAVE	Closed	</span><br><span class="line">Loop 1	114 segs	CONCAVE	Closed	</span><br><span class="line">Loop 2	134 segs	CONCAVE	Closed	</span><br><span class="line">Loop 3	134 segs	CONCAVE	Closed	</span><br><span class="line">Loop 4	96 segs	REGULAR	Closed	</span><br><span class="line">Loop 5	100 segs	REGULAR	Closed	</span><br><span class="line">Loop 6	102 segs	REGULAR	Closed	</span><br><span class="line">Loop 7	93 segs	REGULAR	Closed	</span><br><span class="line">Loop 8	81 segs	REGULAR	Closed	</span><br><span class="line">Loop 9	79 segs	REGULAR	Closed	</span><br><span class="line">Loop 10	35 segs	REGULAR	Closed	</span><br><span class="line">Loop 11	36 segs	REGULAR	Closed	</span><br><span class="line">Loop 12	33 segs	REGULAR	Closed	</span><br><span class="line">Loop 13	42 segs	REGULAR	Closed	</span><br><span class="line">Loop 14	32 segs	REGULAR	Closed	</span><br><span class="line">Loop 15	37 segs	REGULAR	Closed	</span><br><span class="line">Loop 16	30 segs	REGULAR	Closed	</span><br><span class="line">Loop 17	31 segs	REGULAR	Closed	</span><br><span class="line">Loop 18	132 segs	REGULAR	Closed	</span><br><span class="line">Loop 19	138 segs	REGULAR	Closed	</span><br><span class="line">Loop 20	137 segs	REGULAR	Closed	</span><br><span class="line">Loop 21	136 segs	REGULAR	Closed	</span><br><span class="line">Loop 22	104 segs	REGULAR	Closed	</span><br><span class="line">Loop 23	105 segs	REGULAR	Closed	</span><br><span class="line">Loop 24	108 segs	REGULAR	Closed	</span><br><span class="line">Loop 25	102 segs	REGULAR	Closed	</span><br><span class="line">Loop 26	104 segs	REGULAR	Closed	</span><br><span class="line">Loop 27	107 segs	REGULAR	Closed	</span><br><span class="line">Loop 28	104 segs	REGULAR	Closed	</span><br><span class="line">Loop 29	109 segs	REGULAR	Closed	</span><br><span class="line">Loop 30	168 segs	REGULAR	Closed	</span><br><span class="line">Loop 31	108 segs	REGULAR	Closed	</span><br><span class="line">Loop 32	91 segs	REGULAR	Closed	</span><br><span class="line">Loop 33	39 segs	REGULAR	Closed	</span><br><span class="line">Loop 34	101 segs	REGULAR	Closed	</span><br><span class="line">Loop 35	35 segs	REGULAR	Closed	</span><br><span class="line">Loop 36	145 segs	REGULAR	Closed	</span><br><span class="line">Loop 37	39 segs	REGULAR	Closed	</span><br><span class="line">Loop 38	99 segs	REGULAR	Closed	</span><br><span class="line">Loop 39	97 segs	REGULAR	Closed	</span><br><span class="line">Loop 40	94 segs	REGULAR	Closed	</span><br><span class="line">Loop 41	37 segs	REGULAR	Closed	</span><br><span class="line">Loop 42	99 segs	REGULAR	Closed	</span><br><span class="line">Loop 43	41 segs	REGULAR	Closed	</span><br><span class="line">Loop 44	110 segs	REGULAR	Closed	</span><br><span class="line">Loop 45	117 segs	REGULAR	Closed	</span><br><span class="line">Loop 46	111 segs	REGULAR	Closed	</span><br><span class="line">Loop 47	180 segs	REGULAR	Closed	</span><br><span class="line">Loop 48	107 segs	REGULAR	Closed	</span><br><span class="line">Loop 49	105 segs	REGULAR	Closed	</span><br><span class="line">Loop 50	101 segs	REGULAR	Closed	</span><br><span class="line">Loop 51	188 segs	REGULAR	Closed	</span><br><span class="line">Loop 52	137 segs	REGULAR	Closed	</span><br><span class="line">Loop 53	108 segs	REGULAR	Closed	</span><br><span class="line">Loop 54	188 segs	REGULAR	Closed	</span><br><span class="line">Loop 55	206 segs	REGULAR	Closed	</span><br><span class="line">Loop 56	147 segs	REGULAR	Closed	</span><br><span class="line">Loop 57	181 segs	REGULAR	Closed	</span><br><span class="line">Loop 58	108 segs	REGULAR	Closed	</span><br><span class="line">Loop 59	39 segs	REGULAR	Closed	</span><br><span class="line">Loop 60	110 segs	REGULAR	Closed	</span><br><span class="line">Loop 61	37 segs	REGULAR	Closed	</span><br><span class="line">Loop 62	179 segs	REGULAR	Closed	</span><br><span class="line">Loop 63	99 segs	REGULAR	Closed	</span><br><span class="line">Loop 64	37 segs	REGULAR	Closed	</span><br><span class="line">Loop 65	214 segs	REGULAR	Closed	</span><br><span class="line">Loop 66	35 segs	REGULAR	Closed	</span><br><span class="line">Loop 67	227 segs	REGULAR	Closed	</span><br><span class="line">Loop 68	102 segs	REGULAR	Closed	</span><br><span class="line">Loop 69	389 segs	REGULAR	Closed	</span><br><span class="line">Loop 70	137 segs	REGULAR	Closed	</span><br><span class="line">Loop 71	228 segs	REGULAR	Closed	</span><br><span class="line">Loop 72	220 segs	REGULAR	Closed	</span><br><span class="line">Loop 73	172 segs	REGULAR	Closed	</span><br><span class="line">Loop 74	33 segs	REGULAR	Closed	</span><br><span class="line">Loop 75	41 segs	REGULAR	Closed	</span><br><span class="line">Loop 76	37 segs	REGULAR	Closed	</span><br><span class="line">Loop 77	30 segs	REGULAR	Closed	</span><br><span class="line">Loop 78	35 segs	REGULAR	Closed	</span><br><span class="line">Loop 79	135 segs	REGULAR	Closed	</span><br><span class="line">Loop 80	108 segs	REGULAR	Closed	</span><br><span class="line">Loop 81	100 segs	REGULAR	Closed	</span><br><span class="line">Loop 82	96 segs	REGULAR	Closed	</span><br><span class="line">Loop 83	46 segs	CONVEX	Open	</span><br><span class="line">Loop 84	46 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 84 because it seems to be a copy of loop 83</span><br><span class="line">Loop 85	49 segs	CONVEX	Open	</span><br><span class="line">Loop 86	49 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 86 because it seems to be a copy of loop 85</span><br><span class="line">Loop 87	48 segs	CONVEX	Open	</span><br><span class="line">Loop 88	48 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 88 because it seems to be a copy of loop 87</span><br><span class="line">Loop 89	28 segs	CONVEX	Closed	</span><br><span class="line">Loop 90	28 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 90 because it seems to be a copy of loop 89</span><br><span class="line">Loop 91	31 segs	CONVEX	Closed	</span><br><span class="line">Loop 92	31 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 92 because it seems to be a copy of loop 91</span><br><span class="line">Loop 93	49 segs	CONVEX	Open	</span><br><span class="line">Loop 94	49 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 94 because it seems to be a copy of loop 93</span><br><span class="line">Loop 95	5 segs	CONVEX	Open	</span><br><span class="line">Loop 96	5 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 96 because it seems to be a copy of loop 95</span><br><span class="line">Loop 97	29 segs	CONVEX	Closed	</span><br><span class="line">Loop 98	29 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 98 because it seems to be a copy of loop 97</span><br><span class="line">Loop 99	28 segs	CONVEX	Closed	</span><br><span class="line">Loop 100	28 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 100 because it seems to be a copy of loop 99</span><br><span class="line">Loop 101	46 segs	CONVEX	Open	</span><br><span class="line">Loop 102	46 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 102 because it seems to be a copy of loop 101</span><br><span class="line">Loop 103	28 segs	CONVEX	Closed	</span><br><span class="line">Loop 104	28 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 104 because it seems to be a copy of loop 103</span><br><span class="line">Loop 105	114 segs	CONVEX	Closed	</span><br><span class="line">Loop 106	114 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 106 because it seems to be a copy of loop 105</span><br><span class="line">Loop 107	134 segs	CONVEX	Closed	</span><br><span class="line">Loop 108	134 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 108 because it seems to be a copy of loop 107</span><br><span class="line">Loop 109	49 segs	CONVEX	Open	</span><br><span class="line">Loop 110	49 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 110 because it seems to be a copy of loop 109</span><br><span class="line">Loop 111	31 segs	CONVEX	Closed	</span><br><span class="line">Loop 112	31 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 112 because it seems to be a copy of loop 111</span><br><span class="line">Loop 113	74 segs	CONVEX	Closed	</span><br><span class="line">Loop 114	74 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 114 because it seems to be a copy of loop 113</span><br><span class="line">Loop 115	29 segs	CONVEX	Closed	</span><br><span class="line">Loop 116	29 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 116 because it seems to be a copy of loop 115</span><br><span class="line">Loop 117	5 segs	CONVEX	Open	</span><br><span class="line">Loop 118	5 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 118 because it seems to be a copy of loop 117</span><br><span class="line">Loop 119	49 segs	CONVEX	Open	</span><br><span class="line">Loop 120	49 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 120 because it seems to be a copy of loop 119</span><br><span class="line">Loop 121	30 segs	CONVEX	Closed	</span><br><span class="line">Loop 122	30 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 122 because it seems to be a copy of loop 121</span><br><span class="line">Loop 123	48 segs	CONVEX	Open	</span><br><span class="line">Loop 124	48 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 124 because it seems to be a copy of loop 123</span><br><span class="line">Loop 125	5 segs	CONVEX	Open	</span><br><span class="line">Loop 126	5 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 126 because it seems to be a copy of loop 125</span><br><span class="line">Loop 127	74 segs	CONVEX	Closed	</span><br><span class="line">Loop 128	74 segs	CONVEX	Closed	</span><br><span class="line">WARNING: I am skipping loop 128 because it seems to be a copy of loop 127</span><br><span class="line">Loop 129	5 segs	CONVEX	Open	</span><br><span class="line">Loop 130	5 segs	CONVEX	Open	</span><br><span class="line">WARNING: I am skipping loop 130 because it seems to be a copy of loop 129</span><br><span class="line">Refined mesh to fully detach cuts</span><br><span class="line">4044 edges were split</span><br><span class="line">0 faces were split</span><br><span class="line">0 polys were split</span><br><span class="line">--------preprocessing [0.000189s]	0.553230GB RAM</span><br><span class="line">loop 3 is interpolated by current cut. Add it to BCs</span><br><span class="line">--------HRBF [9.163733s]	0.556759GB RAM</span><br><span class="line">--------Tessellation (24690V) [28.965890s]	0.626801GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.070590s]	0.627697GB RAM</span><br><span class="line">--------Labeling update [0.119056s](2 clusters)</span><br><span class="line">----Cut loop #0 [38.319827s]	0.627823GB RAM</span><br><span class="line">----Mesh Extractor [0.475998s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000147s]	0.627884GB RAM</span><br><span class="line">--------HRBF [6.102698s]	0.627884GB RAM</span><br><span class="line">--------Tessellation (28753V) [11.537809s]	0.656219GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.070334s]	0.657009GB RAM</span><br><span class="line">--------Labeling update [0.120614s](3 clusters)</span><br><span class="line">----Cut loop #1 [17.831920s]	0.657009GB RAM</span><br><span class="line">----Mesh Extractor [0.501954s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000181s]	0.657009GB RAM</span><br><span class="line">--------HRBF [7.245421s]	0.657238GB RAM</span><br><span class="line">--------Tessellation (30317V) [27.733172s]	0.800037GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.085099s]	0.801186GB RAM</span><br><span class="line">--------Labeling update [0.138929s](4 clusters)</span><br><span class="line">----Cut loop #2 [35.203115s]	0.801186GB RAM</span><br><span class="line">----Mesh Extractor [0.648158s]</span><br><span class="line"></span><br><span class="line">----Mesh Extractor [0.734819s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000174s]	0.801216GB RAM</span><br><span class="line">--------HRBF [0.285782s]	0.801220GB RAM</span><br><span class="line">--------Tessellation (34775V) [11.668475s]	0.824223GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.069109s]	0.824684GB RAM</span><br><span class="line">--------Labeling update [0.146912s](4 clusters)</span><br><span class="line">----Cut loop #4 [12.170739s]	0.824684GB RAM</span><br><span class="line">----Mesh Extractor [0.616942s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000136s]	0.824718GB RAM</span><br><span class="line">--------HRBF [0.302007s]	0.824718GB RAM</span><br><span class="line">--------Tessellation (36142V) [12.774730s]	0.849133GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.072138s]	0.849541GB RAM</span><br><span class="line">--------Labeling update [0.149255s](8 clusters)</span><br><span class="line">----Cut loop #5 [13.298541s]	0.849541GB RAM</span><br><span class="line">----Mesh Extractor [0.666960s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000211s]	0.849609GB RAM</span><br><span class="line">--------HRBF [0.317384s]	0.849609GB RAM</span><br><span class="line">--------Tessellation (37637V) [13.500301s]	0.875072GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.079844s]	0.875374GB RAM</span><br><span class="line">--------Labeling update [0.170140s](12 clusters)</span><br><span class="line">----Cut loop #6 [14.068164s]	0.875374GB RAM</span><br><span class="line">----Mesh Extractor [0.735981s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000120s]	0.875420GB RAM</span><br><span class="line">--------HRBF [0.247238s]	0.875420GB RAM</span><br><span class="line">--------Tessellation (39161V) [11.925650s]	0.896641GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.080524s]	0.897076GB RAM</span><br><span class="line">--------Labeling update [0.167645s](16 clusters)</span><br><span class="line">----Cut loop #7 [12.421474s]	0.897076GB RAM</span><br><span class="line">----Mesh Extractor [0.726062s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000110s]	0.897095GB RAM</span><br><span class="line">--------HRBF [0.181838s]	0.898815GB RAM</span><br><span class="line">--------Tessellation (40519V) [11.405100s]	0.918770GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.078976s]	0.919106GB RAM</span><br><span class="line">--------Labeling update [0.171206s](19 clusters)</span><br><span class="line">----Cut loop #8 [11.837517s]	0.919106GB RAM</span><br><span class="line">----Mesh Extractor [0.752414s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000106s]	0.919117GB RAM</span><br><span class="line">--------HRBF [0.171205s]	0.920757GB RAM</span><br><span class="line">--------Tessellation (41896V) [12.496918s]	0.943577GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.081562s]	0.944000GB RAM</span><br><span class="line">--------Labeling update [0.178476s](22 clusters)</span><br><span class="line">----Cut loop #9 [12.928544s]	0.944000GB RAM</span><br><span class="line">----Mesh Extractor [0.776425s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000065s]	0.944073GB RAM</span><br><span class="line">--------HRBF [0.022791s]	0.944073GB RAM</span><br><span class="line">--------Tessellation (43503V) [5.813727s]	0.999825GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.087071s]	0.999825GB RAM</span><br><span class="line">--------Labeling update [0.191810s](22 clusters)</span><br><span class="line">----Cut loop #10 [6.115778s]	0.999825GB RAM</span><br><span class="line">----Mesh Extractor [0.829006s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000063s]	0.999825GB RAM</span><br><span class="line">--------HRBF [0.021729s]	0.999825GB RAM</span><br><span class="line">--------Tessellation (44197V) [14.210263s]	1.087044GB RAM</span><br><span class="line">Revert cut</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.084750s]</span><br><span class="line">----Cut loop #11 [14.317014s]</span><br><span class="line">----Mesh Extractor [0.863839s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000064s]	1.087067GB RAM</span><br><span class="line">--------HRBF [0.018168s]	1.087067GB RAM</span><br><span class="line">--------Tessellation (46101V) [15.627233s]	1.111408GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.080935s]	1.111534GB RAM</span><br><span class="line">--------Labeling update [0.208435s](22 clusters)</span><br><span class="line">----Cut loop #12 [15.935105s]	1.111534GB RAM</span><br><span class="line">----Mesh Extractor [0.855889s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000068s]	1.111626GB RAM</span><br><span class="line">--------HRBF [0.031711s]	1.112045GB RAM</span><br><span class="line">--------Tessellation (48286V) [14.380493s]	1.146629GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.084433s]	1.146755GB RAM</span><br><span class="line">--------Labeling update [0.210721s](23 clusters)</span><br><span class="line">----Cut loop #13 [14.707710s]	1.146755GB RAM</span><br><span class="line">----Mesh Extractor [0.893655s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000189s]	1.147205GB RAM</span><br><span class="line">--------HRBF [0.017390s]	1.147449GB RAM</span><br><span class="line">--------Tessellation (50331V) [4.550830s]	1.156536GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.085423s]	1.156536GB RAM</span><br><span class="line">--------Labeling update [0.208880s](24 clusters)</span><br><span class="line">----Cut loop #14 [4.863065s]	1.156677GB RAM</span><br><span class="line">----Mesh Extractor [0.911797s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000067s]	1.156708GB RAM</span><br><span class="line">--------HRBF [0.023535s]	1.157032GB RAM</span><br><span class="line">--------Tessellation (50898V) [3.163397s]	1.161236GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.086486s]	1.161362GB RAM</span><br><span class="line">--------Labeling update [0.213116s](25 clusters)</span><br><span class="line">----Cut loop #15 [3.486894s]	1.161362GB RAM</span><br><span class="line">----Mesh Extractor [0.908651s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000061s]	1.161362GB RAM</span><br><span class="line">--------HRBF [0.015223s]	1.161362GB RAM</span><br><span class="line">--------Tessellation (51159V) [12.563354s]	1.193268GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.089295s]	1.193268GB RAM</span><br><span class="line">--------Labeling update [0.216765s](26 clusters)</span><br><span class="line">----Cut loop #16 [12.884983s]	1.193394GB RAM</span><br><span class="line">----Mesh Extractor [0.956534s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000063s]	1.193810GB RAM</span><br><span class="line">--------HRBF [0.017665s]	1.193920GB RAM</span><br><span class="line">--------Tessellation (52999V) [5.402335s]	1.204975GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.100717s]	1.204975GB RAM</span><br><span class="line">--------Labeling update [0.228016s](27 clusters)</span><br><span class="line">----Cut loop #17 [5.749143s]	1.204979GB RAM</span><br><span class="line">----Mesh Extractor [0.993257s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000222s]	1.204975GB RAM</span><br><span class="line">--------HRBF [0.636586s]	1.205250GB RAM</span><br><span class="line">--------Tessellation (53648V) [15.457998s]	1.229183GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.113666s]	1.230019GB RAM</span><br><span class="line">--------Labeling update [0.224740s](31 clusters)</span><br><span class="line">----Cut loop #18 [16.433572s]	1.230019GB RAM</span><br><span class="line">----Mesh Extractor [0.992320s]</span><br><span class="line"></span><br><span class="line">--------preprocessing [0.000165s]	1.230106GB RAM</span><br><span class="line">--------HRBF [0.750456s]	1.230228GB RAM</span><br><span class="line">--------Tessellation (54963V) [15.641222s]	1.252247GB RAM</span><br><span class="line">--------Analyze the cut. Revert if necessary [0.116046s]	1.252773GB RAM</span><br><span class="line">--------Labeling update [0.232762s](33 clusters)</span><br><span class="line">----Cut loop #19 [16.741106s]	1.252773GB RAM</span><br><span class="line">CONVERGED!</span><br><span class="line">----Mesh Extractor [1.209680s]</span><br><span class="line"></span><br><span class="line">20 cuts performed</span><br><span class="line"></span><br><span class="line">Post Convergence Cut Analysis</span><br><span class="line">CONVERGED!</span><br><span class="line">extracting patch for MM surface face 0. Face label on M is 108</span><br><span class="line">extracting patch for MM surface face 1. Face label on M is 31</span><br><span class="line">extracting patch for MM surface face 2. Face label on M is 15</span><br><span class="line">extracting patch for MM surface face 3. Face label on M is 153</span><br><span class="line">extracting patch for MM surface face 4. Face label on M is 53</span><br><span class="line">extracting patch for MM surface face 5. Face label on M is 150</span><br><span class="line">extracting patch for MM surface face 6. Face label on M is 65</span><br><span class="line">extracting patch for MM surface face 7. Face label on M is 140</span><br><span class="line">extracting patch for MM surface face 8. Face label on M is 1</span><br><span class="line">extracting patch for MM surface face 9. Face label on M is 3</span><br><span class="line">extracting patch for MM surface face 10. Face label on M is 103</span><br><span class="line">extracting patch for MM surface face 11. Face label on M is 44</span><br><span class="line">extracting patch for MM surface face 12. Face label on M is 120</span><br><span class="line">extracting patch for MM surface face 13. Face label on M is 138</span><br><span class="line">extracting patch for MM surface face 14. Face label on M is 78</span><br><span class="line">extracting patch for MM surface face 15. Face label on M is 45</span><br><span class="line">extracting patch for MM surface face 16. Face label on M is 49</span><br><span class="line">extracting patch for MM surface face 17. Face label on M is 11</span><br><span class="line">extracting patch for MM surface face 19. Face label on M is 67</span><br><span class="line">extracting patch for MM surface face 21. Face label on M is 64</span><br><span class="line">extracting patch for MM surface face 25. Face label on M is 27</span><br><span class="line">extracting patch for MM surface face 26. Face label on M is 97</span><br><span class="line">extracting patch for MM surface face 28. Face label on M is 113</span><br><span class="line">extracting patch for MM surface face 31. Face label on M is 114</span><br><span class="line">extracting patch for MM surface face 33. Face label on M is 69</span><br><span class="line">extracting patch for MM surface face 34. Face label on M is 2</span><br><span class="line">extracting patch for MM surface face 35. Face label on M is 18</span><br><span class="line">extracting patch for MM surface face 36. Face label on M is 126</span><br><span class="line">extracting patch for MM surface face 37. Face label on M is 135</span><br><span class="line">extracting patch for MM surface face 38. Face label on M is 76</span><br><span class="line">extracting patch for MM surface face 41. Face label on M is 59</span><br><span class="line">extracting patch for MM surface face 43. Face label on M is 38</span><br><span class="line">extracting patch for MM surface face 48. Face label on M is 32</span><br><span class="line">extracting patch for MM surface face 50. Face label on M is 37</span><br><span class="line">extracting patch for MM surface face 51. Face label on M is 136</span><br><span class="line">extracting patch for MM surface face 52. Face label on M is 88</span><br><span class="line">extracting patch for MM surface face 53. Face label on M is 41</span><br><span class="line">extracting patch for MM surface face 54. Face label on M is 123</span><br><span class="line">extracting patch for MM surface face 56. Face label on M is 50</span><br><span class="line">extracting patch for MM surface face 57. Face label on M is 148</span><br><span class="line">extracting patch for MM surface face 58. Face label on M is 117</span><br><span class="line">extracting patch for MM surface face 59. Face label on M is 35</span><br><span class="line">extracting patch for MM surface face 61. Face label on M is 52</span><br><span class="line">extracting patch for MM surface face 62. Face label on M is 40</span><br><span class="line">extracting patch for MM surface face 64. Face label on M is 26</span><br><span class="line">extracting patch for MM surface face 65. Face label on M is 118</span><br><span class="line">extracting patch for MM surface face 66. Face label on M is 141</span><br><span class="line">extracting patch for MM surface face 68. Face label on M is 155</span><br><span class="line">extracting patch for MM surface face 69. Face label on M is 145</span><br><span class="line">extracting patch for MM surface face 70. Face label on M is 19</span><br><span class="line">extracting patch for MM surface face 71. Face label on M is 22</span><br><span class="line">extracting patch for MM surface face 72. Face label on M is 42</span><br><span class="line">extracting patch for MM surface face 73. Face label on M is 143</span><br><span class="line">extracting patch for MM surface face 75. Face label on M is 47</span><br><span class="line">extracting patch for MM surface face 76. Face label on M is 36</span><br><span class="line">extracting patch for MM surface face 77. Face label on M is 43</span><br><span class="line">extracting patch for MM surface face 78. Face label on M is 30</span><br><span class="line">extracting patch for MM surface face 81. Face label on M is 5</span><br><span class="line">extracting patch for MM surface face 82. Face label on M is 23</span><br><span class="line">extracting patch for MM surface face 84. Face label on M is 0</span><br><span class="line">extracting patch for MM surface face 86. Face label on M is 60</span><br><span class="line">extracting patch for MM surface face 88. Face label on M is 121</span><br><span class="line">extracting patch for MM surface face 93. Face label on M is 16</span><br><span class="line">extracting patch for MM surface face 100. Face label on M is 54</span><br><span class="line">extracting patch for MM surface face 101. Face label on M is 112</span><br><span class="line">extracting patch for MM surface face 103. Face label on M is 84</span><br><span class="line">extracting patch for MM surface face 104. Face label on M is 80</span><br><span class="line">extracting patch for MM surface face 106. Face label on M is 104</span><br><span class="line">extracting patch for MM surface face 108. Face label on M is 24</span><br><span class="line">extracting patch for MM surface face 109. Face label on M is 119</span><br><span class="line">extracting patch for MM surface face 110. Face label on M is 146</span><br><span class="line">extracting patch for MM surface face 111. Face label on M is 106</span><br><span class="line">extracting patch for MM surface face 112. Face label on M is 93</span><br><span class="line">extracting patch for MM surface face 113. Face label on M is 58</span><br><span class="line">extracting patch for MM surface face 116. Face label on M is 75</span><br><span class="line">extracting patch for MM surface face 117. Face label on M is 8</span><br><span class="line">extracting patch for MM surface face 119. Face label on M is 85</span><br><span class="line">extracting patch for MM surface face 121. Face label on M is 77</span><br><span class="line">extracting patch for MM surface face 122. Face label on M is 56</span><br><span class="line">extracting patch for MM surface face 127. Face label on M is 10</span><br><span class="line">extracting patch for MM surface face 128. Face label on M is 29</span><br><span class="line">extracting patch for MM surface face 130. Face label on M is 61</span><br><span class="line">extracting patch for MM surface face 131. Face label on M is 115</span><br><span class="line">extracting patch for MM surface face 132. Face label on M is 90</span><br><span class="line">extracting patch for MM surface face 133. Face label on M is 94</span><br><span class="line">extracting patch for MM surface face 134. Face label on M is 127</span><br><span class="line">extracting patch for MM surface face 135. Face label on M is 156</span><br><span class="line">extracting patch for MM surface face 137. Face label on M is 82</span><br><span class="line">extracting patch for MM surface face 140. Face label on M is 86</span><br><span class="line">extracting patch for MM surface face 144. Face label on M is 105</span><br><span class="line">extracting patch for MM surface face 146. Face label on M is 73</span><br><span class="line">extracting patch for MM surface face 149. Face label on M is 66</span><br><span class="line">extracting patch for MM surface face 150. Face label on M is 125</span><br><span class="line">extracting patch for MM surface face 151. Face label on M is 99</span><br><span class="line">extracting patch for MM surface face 152. Face label on M is 13</span><br><span class="line">extracting patch for MM surface face 153. Face label on M is 21</span><br><span class="line">extracting patch for MM surface face 154. Face label on M is 74</span><br><span class="line">extracting patch for MM surface face 155. Face label on M is 62</span><br><span class="line">uv mapping patch 76(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0010333s)                      </span><br><span class="line">#Items                   : 306</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 99</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 140(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0007001s)                      </span><br><span class="line">#Items                   : 316</span><br><span class="line">#Leaves                  : 22</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 44(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0004123s)                      </span><br><span class="line">#Items                   : 218</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 83</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 108(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002847s)                      </span><br><span class="line">#Items                   : 136</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 63</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 143(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002194s)                      </span><br><span class="line">#Items                   : 107</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 47</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 15(corners 7)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.009894s)                      </span><br><span class="line">#Items                   : 1295</span><br><span class="line">#Leaves                  : 512</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 31(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0030766s)                      </span><br><span class="line">#Items                   : 446</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 92</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 1(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.000382s)                      </span><br><span class="line">#Items                   : 193</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 77</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 65(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002936s)                      </span><br><span class="line">#Items                   : 151</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 67</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 153(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003028s)                      </span><br><span class="line">#Items                   : 159</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 66</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 117(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0011154s)                      </span><br><span class="line">#Items                   : 283</span><br><span class="line">#Leaves                  : 64</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 53(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0017089s)                      </span><br><span class="line">#Items                   : 349</span><br><span class="line">#Leaves                  : 106</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 86</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 22(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0046679s)                      </span><br><span class="line">#Items                   : 684</span><br><span class="line">#Leaves                  : 246</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 89</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 150(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003826s)                      </span><br><span class="line">#Items                   : 189</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 81</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 67(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0053466s)                      </span><br><span class="line">#Items                   : 778</span><br><span class="line">#Leaves                  : 288</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 84</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 3(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0013453s)                      </span><br><span class="line">#Items                   : 378</span><br><span class="line">#Leaves                  : 64</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 103(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0014407s)                      </span><br><span class="line">#Items                   : 378</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 120(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003982s)                      </span><br><span class="line">#Items                   : 210</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 91</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 138(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0013453s)                      </span><br><span class="line">#Items                   : 345</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 78(corners 7)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0103484s)                      </span><br><span class="line">#Items                   : 1360</span><br><span class="line">#Leaves                  : 540</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 95</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 45(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0013664s)                      </span><br><span class="line">#Items                   : 387</span><br><span class="line">#Leaves                  : 64</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 113(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0027521s)                      </span><br><span class="line">#Items                   : 446</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 78</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 49(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0034788s)                      </span><br><span class="line">#Items                   : 584</span><br><span class="line">#Leaves                  : 204</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 11(corners 7)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0092166s)                      </span><br><span class="line">#Items                   : 1118</span><br><span class="line">#Leaves                  : 540</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 102</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 0(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.003155s)                      </span><br><span class="line">#Items                   : 567</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 64(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0046862s)                      </span><br><span class="line">#Items                   : 667</span><br><span class="line">#Leaves                  : 288</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 81</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 155(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002022s)                      </span><br><span class="line">#Items                   : 104</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 62</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 27(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0026047s)                      </span><br><span class="line">#Items                   : 467</span><br><span class="line">#Leaves                  : 120</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 97(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0033131s)                      </span><br><span class="line">#Items                   : 632</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 93</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 50(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0079605s)                      </span><br><span class="line">#Items                   : 1037</span><br><span class="line">#Leaves                  : 484</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 78</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 114(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0015217s)                      </span><br><span class="line">#Items                   : 289</span><br><span class="line">#Leaves                  : 106</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 5(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0014433s)                      </span><br><span class="line">#Items                   : 297</span><br><span class="line">#Leaves                  : 92</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 93</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 69(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0001602s)                      </span><br><span class="line">#Items                   : 68</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 29</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 2(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0001789s)                      </span><br><span class="line">#Items                   : 87</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 43</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 18(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0020274s)                      </span><br><span class="line">#Items                   : 508</span><br><span class="line">#Leaves                  : 92</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 126(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0014414s)                      </span><br><span class="line">#Items                   : 397</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 135(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0033177s)                      </span><br><span class="line">#Items                   : 500</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 86</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 123(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003456s)                      </span><br><span class="line">#Items                   : 189</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 87</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 59(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0011483s)                      </span><br><span class="line">#Items                   : 345</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 38(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0032839s)                      </span><br><span class="line">#Items                   : 559</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 85</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 32(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.005244s)                      </span><br><span class="line">#Items                   : 917</span><br><span class="line">#Leaves                  : 288</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 37(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0018929s)                      </span><br><span class="line">#Items                   : 315</span><br><span class="line">#Leaves                  : 134</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 95</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 136(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002895s)                      </span><br><span class="line">#Items                   : 150</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 64</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 88(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0008057s)                      </span><br><span class="line">#Items                   : 207</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 64</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 41(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0045934s)                      </span><br><span class="line">#Items                   : 924</span><br><span class="line">#Leaves                  : 204</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 88</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 148(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003472s)                      </span><br><span class="line">#Items                   : 178</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 70</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 35(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0014299s)                      </span><br><span class="line">#Items                   : 323</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 52(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0027052s)                      </span><br><span class="line">#Items                   : 456</span><br><span class="line">#Leaves                  : 148</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 78</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 40(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0040751s)                      </span><br><span class="line">#Items                   : 552</span><br><span class="line">#Leaves                  : 232</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 26(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0094656s)                      </span><br><span class="line">#Items                   : 1086</span><br><span class="line">#Leaves                  : 568</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 54(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0022367s)                      </span><br><span class="line">#Items                   : 332</span><br><span class="line">#Leaves                  : 134</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 88</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 118(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003053s)                      </span><br><span class="line">#Items                   : 143</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 64</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 141(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.000412s)                      </span><br><span class="line">#Items                   : 193</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 82</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 145(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002821s)                      </span><br><span class="line">#Items                   : 133</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 67</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 19(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0016043s)                      </span><br><span class="line">#Items                   : 382</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 42(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0059002s)                      </span><br><span class="line">#Items                   : 892</span><br><span class="line">#Leaves                  : 288</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 99</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 47(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0023908s)                      </span><br><span class="line">#Items                   : 377</span><br><span class="line">#Leaves                  : 148</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 94</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 36(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0015585s)                      </span><br><span class="line">#Items                   : 312</span><br><span class="line">#Leaves                  : 92</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 43(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002732s)                      </span><br><span class="line">#Items                   : 124</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 55</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 30(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0035622s)                      </span><br><span class="line">#Items                   : 672</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 83</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 23(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0033998s)                      </span><br><span class="line">#Items                   : 527</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 60(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0017856s)                      </span><br><span class="line">#Items                   : 369</span><br><span class="line">#Leaves                  : 106</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 121(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0018036s)                      </span><br><span class="line">#Items                   : 380</span><br><span class="line">#Leaves                  : 106</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 16(corners 6)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0058992s)                      </span><br><span class="line">#Items                   : 894</span><br><span class="line">#Leaves                  : 344</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 84</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 112(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0023915s)                      </span><br><span class="line">#Items                   : 329</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 63</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 84(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0027558s)                      </span><br><span class="line">#Items                   : 396</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 74</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 80(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0008441s)                      </span><br><span class="line">#Items                   : 235</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 71</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 104(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0004482s)                      </span><br><span class="line">#Items                   : 235</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 24(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0005577s)                      </span><br><span class="line">#Items                   : 257</span><br><span class="line">#Leaves                  : 22</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 119(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.000873s)                      </span><br><span class="line">#Items                   : 249</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 79</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 146(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0015993s)                      </span><br><span class="line">#Items                   : 375</span><br><span class="line">#Leaves                  : 92</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 106(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0022042s)                      </span><br><span class="line">#Items                   : 400</span><br><span class="line">#Leaves                  : 148</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 93(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0018675s)                      </span><br><span class="line">#Items                   : 325</span><br><span class="line">#Leaves                  : 134</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 58(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0032548s)                      </span><br><span class="line">#Items                   : 511</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 99</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 75(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0074184s)                      </span><br><span class="line">#Items                   : 832</span><br><span class="line">#Leaves                  : 456</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 94</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 8(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0074957s)                      </span><br><span class="line">#Items                   : 830</span><br><span class="line">#Leaves                  : 456</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 81</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 85(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0032756s)                      </span><br><span class="line">#Items                   : 522</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 88</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 77(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003652s)                      </span><br><span class="line">#Items                   : 205</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 89</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 56(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003764s)                      </span><br><span class="line">#Items                   : 212</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 84</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 10(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0004351s)                      </span><br><span class="line">#Items                   : 246</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 96</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 29(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0013695s)                      </span><br><span class="line">#Items                   : 362</span><br><span class="line">#Leaves                  : 78</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 61(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0024833s)                      </span><br><span class="line">#Items                   : 508</span><br><span class="line">#Leaves                  : 148</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 115(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0004975s)                      </span><br><span class="line">#Items                   : 222</span><br><span class="line">#Leaves                  : 22</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 86</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 90(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0003355s)                      </span><br><span class="line">#Items                   : 191</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 94(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0025856s)                      </span><br><span class="line">#Items                   : 486</span><br><span class="line">#Leaves                  : 148</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 127(corners 3)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0001522s)                      </span><br><span class="line">#Items                   : 75</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 47</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 156(corners 3)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0002042s)                      </span><br><span class="line">#Items                   : 107</span><br><span class="line">#Leaves                  : 8</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 1</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 62</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 82(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0026406s)                      </span><br><span class="line">#Items                   : 624</span><br><span class="line">#Leaves                  : 120</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 86(corners 5)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0021443s)                      </span><br><span class="line">#Items                   : 571</span><br><span class="line">#Leaves                  : 92</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 98</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 105(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0031318s)                      </span><br><span class="line">#Items                   : 560</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 79</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 73(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0048724s)                      </span><br><span class="line">#Items                   : 674</span><br><span class="line">#Leaves                  : 288</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 88</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 66(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0041435s)                      </span><br><span class="line">#Items                   : 682</span><br><span class="line">#Leaves                  : 232</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 100</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 125(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0027664s)                      </span><br><span class="line">#Items                   : 329</span><br><span class="line">#Leaves                  : 50</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 99(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0012202s)                      </span><br><span class="line">#Items                   : 344</span><br><span class="line">#Leaves                  : 64</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 2</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 97</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 13(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0027504s)                      </span><br><span class="line">#Items                   : 464</span><br><span class="line">#Leaves                  : 176</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 77</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 21(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0023507s)                      </span><br><span class="line">#Items                   : 451</span><br><span class="line">#Leaves                  : 134</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 81</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 74(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0024536s)                      </span><br><span class="line">#Items                   : 459</span><br><span class="line">#Leaves                  : 134</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 75</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">uv mapping patch 62(corners 4)</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0012923s)                      </span><br><span class="line">#Items                   : 311</span><br><span class="line">#Leaves                  : 64</span><br><span class="line">Max depth                : 4</span><br><span class="line">Depth                    : 3</span><br><span class="line">Prescribed items per leaf: 100</span><br><span class="line">Max items per leaf       : 80</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">load mesh	542V / 1370E / 1128F / 304P  [0.0644435s]</span><br><span class="line">load mesh	542V / 1370E / 1128F / 304P  [0.0636196s]</span><br><span class="line">smooth meta mesh</span><br><span class="line">load mesh	424V / 864E / 432P  [0.0191439s]</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.201954s)                      </span><br><span class="line">#Items                   : 25226</span><br><span class="line">#Leaves                  : 48742</span><br><span class="line">Max depth                : 7</span><br><span class="line">Depth                    : 7</span><br><span class="line">Prescribed items per leaf: 10</span><br><span class="line">Max items per leaf       : 29</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">Octree created (0.0039163s)                      </span><br><span class="line">#Items                   : 1282</span><br><span class="line">#Leaves                  : 883</span><br><span class="line">Max depth                : 7</span><br><span class="line">Depth                    : 4</span><br><span class="line">Prescribed items per leaf: 10</span><br><span class="line">Max items per leaf       : 10</span><br><span class="line">:::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">304 hexa - 0 prisms - 0 hexable with midpoint - 0 others</span><br><span class="line">LoopyCuts [317.289371s]</span><br><span class="line">03:09:38: F:\QT\LoopyCuts\build-volumetric_cutter-Desktop_Qt_5_15_2_MSVC2019_64bit-Debug\debug\volumetric_cutter.exe 退出，退出代码: 0</span><br></pre></td></tr></table></figure></div>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="http://t.csdn.cn/D8K1w" >LoopyCuts编译运行方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://doc.qt.io/qt-6/qtopengl-openglwindow-example.html" >doc.qt.io&#x2F;qt-6&#x2F;qtopengl-openglwindow-example.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qing666888/article/details/78946384" >Qt5.9.4中配置opengl的glut库(Windows)_明卿的博客-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>[Qt+OpenGL基础教程_qt opengl_mai0026的博客-CSDN博客](<a class="link"   href="https://blog.csdn.net/weixin_43220219/article/details/127863676?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BD%BF%E7%94%A8" >https://blog.csdn.net/weixin_43220219/article/details/127863676?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=使用<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> Qt 和 opengl 开发&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-127863676.142^v93^chatgptT3_1&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/517924720" >QT+OpenGL入门笔记（完结） - 骆驼的文章 - 知乎<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/mlivesu/cinolib/issues/12" >compile error! · Issue #12 · mlivesu&#x2F;cinolib (github.com)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>[Tetgen软件学习和使用_VincentFu2017的博客-CSDN博客](<a class="link"   href="https://blog.csdn.net/Shrekul/article/details/108597008?ops_request_misc=%7B%22request_id%22:%22169243682016800184150449%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=169243682016800184150449&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108597008-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=Tetgen" >https://blog.csdn.net/Shrekul/article/details/108597008?ops_request_misc=%7B%22request%5Fid%22%3A%22169243682016800184150449%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169243682016800184150449&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108597008-null-null.142^v93^chatgptT3_1&amp;utm_term=Tetgen<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 安装&amp;spm&#x3D;1018.2226.3001.4187)</p>
]]></content>
  </entry>
  <entry>
    <title>光栅化</title>
    <url>/2025/03/20/Games101/%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/光栅化.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>光线追踪</title>
    <url>/2025/03/20/Games101/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/光线追踪.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>几何</title>
    <url>/2025/03/20/Games101/%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/几何.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学基础</title>
    <url>/2025/03/20/Games101/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/图形学基础.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>材质</title>
    <url>/2025/03/20/Games101/%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/材质.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>着色</title>
    <url>/2025/03/20/Games101/%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/着色.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>核心上下文</title>
    <url>/2025/03/20/Vulkan/1.%E6%A0%B8%E5%BF%83%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>为了模块化设计，使用类 <code>ContentManager</code> 来管理 Vulkan 中的核心上下文，其中 <code>init</code> 函数将执行所有初始化操作，<code>clear</code> 函数将执行所有清理操作：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ContentManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;ContentManager&gt; ContentManagerSPtr;</span><br></pre></td></tr></table></figure></div>

<h1 id="GLFW-窗口"><a href="#GLFW-窗口" class="headerlink" title="GLFW 窗口"></a>GLFW 窗口</h1><p>在类 <code>ContentManager</code> 中，添加 <code>GLFWwindow</code> 类型的成员变量来存储 <code>glfw</code> 窗口指针，并添加一个函数 <code>createWindow</code> 来完成窗口的创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createWindow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>首先，定义窗口的默认大小，添加两个 <code>uint32_t</code> 类型的成员变量来存储窗口宽度和高度，并添加一个设置函数 <code>setExtent</code> 来修改窗口创建时的大小：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setExtent</span><span class="params">(<span class="type">const</span> VkExtent2D&amp; extent)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">uint32_t</span> windowWidth = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">uint32_t</span> windowHeight = <span class="number">1024</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后，调用函数 <code>glfwInit</code> 来初始化 <code>glfw</code>，并调用函数 <code>glfwWindowHint</code> 来配置窗口属性，最后调用 <code>glfwCreateWindow</code> 来创建窗口，一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::setExtent</span><span class="params">(<span class="type">const</span> VkExtent2D&amp; extent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;windowWidth = extent.width;</span><br><span class="line">	<span class="keyword">this</span>-&gt;windowHeight = extent.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line">    <span class="keyword">this</span>-&gt;window = <span class="built_in">glfwCreateWindow</span>(<span class="keyword">this</span>-&gt;windowWidth, <span class="keyword">this</span>-&gt;windowHeight, <span class="string">&quot;Vulkan&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，在 <code>init</code> 函数中调用 <code>createWindow</code> 函数来创建窗口：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createWindow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理窗口"><a href="#清理窗口" class="headerlink" title="清理窗口"></a>清理窗口</h2><p>调用函数 <code>glfwDestroyWindow</code> 来销毁窗口，并调用 <code>glfwTerminate</code> 来清理 <code>glfw</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(<span class="keyword">this</span>-&gt;window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Vulkan-实例"><a href="#Vulkan-实例" class="headerlink" title="Vulkan 实例"></a>Vulkan 实例</h1><p>初始化 Vulkan 库的第一步是创建一个实例（Instance）。该实例是应用程序与 Vulkan 库之间的连接，在创建时需要向驱动程序提供一些关于应用程序的详细信息。</p>
<p>首先，通过 <code>glfw</code> 引入 Vulkan 库文件：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>然后，添加 <code>VkInstance</code> 类型的成员来存储实例句柄，并添加一个函数 <code>createInstance</code> 来创建实例：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkInstance instance;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="应用程序信息"><a href="#应用程序信息" class="headerlink" title="应用程序信息"></a>应用程序信息</h2><p>在创建实例之前，需要先填充结构体 <code>VkApplicationInfo</code> ，提供关于应用程序的信息。该数据是可选的，但它可以为驱动程序提供一些有用的信息，以优化特定的应用程序（例如，如果它使用的是某个特定的图形引擎），其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkApplicationInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*        pApplicationName;</span><br><span class="line">    <span class="type">uint32_t</span>           applicationVersion;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*        pEngineName;</span><br><span class="line">    <span class="type">uint32_t</span>           engineVersion;</span><br><span class="line">    <span class="type">uint32_t</span>           apiVersion;</span><br><span class="line">&#125; VkApplicationInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_APPLICATION_INFO</code>，以表明这是一个 <strong>应用信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展信息的指针，如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>pApplicationName</td>
<td>应用程序名称</td>
<td>指向应用程序名称的字符串指针。</td>
</tr>
<tr>
<td>applicationVersion</td>
<td>应用程序版本号</td>
<td>指定应用程序的版本号，使用 <code>VK_MAKE_VERSION(major, minor, patch)</code> 宏进行设置。</td>
</tr>
<tr>
<td>pEngineName</td>
<td>图形引擎名称</td>
<td>指向图形引擎名称的字符串指针，如果没有引擎，可以设置为 <code>&quot;No Engine&quot;</code>。</td>
</tr>
<tr>
<td>engineVersion</td>
<td>图形引擎版本号</td>
<td>指定引擎的版本号，使用 <code>VK_MAKE_VERSION(major, minor, patch)</code> 宏进行设置。</td>
</tr>
<tr>
<td>apiVersion</td>
<td>Vulkan API 版本</td>
<td>指定 Vulkan API 版本，使用 <code>VK_MAKE_VERSION(major, minor, patch)</code> 进行设置。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Application Information */</span></span><br><span class="line">	VkApplicationInfo applicationInfo&#123;&#125;;</span><br><span class="line">	applicationInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line">	applicationInfo.pApplicationName = <span class="string">&quot;Rasterization&quot;</span>;</span><br><span class="line">	applicationInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	applicationInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">	applicationInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	applicationInfo.apiVersion = VK_API_VERSION_1_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="实例创建信息"><a href="#实例创建信息" class="headerlink" title="实例创建信息"></a>实例创建信息</h2><p>为了创建实例，我们需要再填充一个 <code>VkInstanceCreateInfo</code> 结构体，该结构体是必需的，它告诉 Vulkan 驱动程序我们希望启用哪些全局扩展和验证层。<strong>全局</strong> 指的是这些扩展和层适用于整个程序，而不是某个特定的设备，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkInstanceCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext;</span><br><span class="line">    VkInstanceCreateFlags       flags;</span><br><span class="line">    <span class="type">const</span> VkApplicationInfo*    pApplicationInfo;</span><br><span class="line">    <span class="type">uint32_t</span>                    enabledLayerCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*          ppEnabledLayerNames;</span><br><span class="line">    <span class="type">uint32_t</span>                    enabledExtensionCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*          ppEnabledExtensionNames;</span><br><span class="line">&#125; VkInstanceCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</code>，以表明这是一个 <strong>实例创建信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展信息的指针，如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>实例创建附加标志</td>
<td>默认值为 <code>0</code>。可选值：<br /><code>VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR</code>：需要<code>VK_KHR_portability_enumeration</code> 扩展，允许 Vulkan 枚举支持  非标准 Vulkan 设备（如基于 Metal 的 MoltenVK）。在 MacOS 上，若使用 MoltenVK，需要使用此标志。</td>
</tr>
<tr>
<td>pApplicationInfo</td>
<td>应用程序信息指针</td>
<td>指向 <code>VkApplicationInfo</code> 结构体，提供应用程序信息。</td>
</tr>
<tr>
<td>enabledLayerCount</td>
<td>启用的验证层数量</td>
<td>仅在调试时有用，通常用于启用验证层（Validation Layers）。</td>
</tr>
<tr>
<td>ppEnabledLayerNames</td>
<td>启用的验证层名称数组指针</td>
<td>指向启用的验证层（Validation Layers）名称数组。</td>
</tr>
<tr>
<td>enabledExtensionCount</td>
<td>启用的全局扩展数量</td>
<td>启用的全局扩展（Extensions）数量。</td>
</tr>
<tr>
<td>ppEnabledExtensionNames</td>
<td>启用的扩展名称数组指针</td>
<td>指向启用的扩展名称数组。</td>
</tr>
</tbody></table>
<p>一个示例如下，其中扩展信息将在扩展小节中填充，验证层信息将在验证层小节中填充：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkApplicationInfo applicationInfo&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* Vulkan Instance Information */</span></span><br><span class="line">    VkInstanceCreateInfo instanceCreateInfo&#123;&#125;;</span><br><span class="line">    instanceCreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">    instanceCreateInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    instanceCreateInfo.flags = <span class="number">0</span>;</span><br><span class="line">    instanceCreateInfo.pApplicationInfo = &amp;applicationInfo;</span><br><span class="line">    instanceCreateInfo.enabledLayerCount = <span class="number">0</span>;				<span class="comment">// TODO</span></span><br><span class="line">    instanceCreateInfo.ppEnabledLayerNames = <span class="literal">nullptr</span>;		<span class="comment">// TODO</span></span><br><span class="line">    instanceCreateInfo.enabledExtensionCount = <span class="number">0</span>;			<span class="comment">// TODO</span></span><br><span class="line">    instanceCreateInfo.ppEnabledExtensionNames = <span class="literal">nullptr</span>; 	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建-Vulkan-实例"><a href="#创建-Vulkan-实例" class="headerlink" title="创建 Vulkan 实例"></a>创建 Vulkan 实例</h2><p>通过调用函数 <code>vkCreateInstance</code> 来创建 Vulkan 实例，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkInstanceCreateInfo*                 pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance*                                 pInstance)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>实例创建信息指针</td>
<td>指向 <code>VkInstanceCreateInfo</code> 结构体的指针，包含应用程序信息，扩展，验证层等信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pInstance</td>
<td>实例句柄指针</td>
<td>指向 <code>VkInstance</code> 变量的指针，存储创建的实例句柄。函数执行成功后，该变量将持有新创建的实例对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示实例是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示实例创建成功，其他错误码表示创建失败。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    VkInstanceCreateInfo instanceCreateInfo&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* Create Instance */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateInstance</span>(&amp;instanceCreateInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;instance) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create instance!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，在 <code>init</code> 中，调用 <code>createInstance</code> 函数来创建实例：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;content_manager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="built_in">createInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理-Vulkan-实例"><a href="#清理-Vulkan-实例" class="headerlink" title="清理 Vulkan 实例"></a>清理 Vulkan 实例</h2><p><code>VkInstance</code> 只应在程序退出前销毁，销毁时需要确保所有依赖该实例的资源均被释放。通过函数 <code>vkDestroyInstance</code> 来进行释放，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance                                  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>instance</td>
<td>实例句柄</td>
<td>指定要销毁的实例句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建实例时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 中释放实例：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">vkDestroyInstance</span>(<span class="keyword">this</span>-&gt;instance, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="配置扩展"><a href="#配置扩展" class="headerlink" title="配置扩展"></a>配置扩展</h2><p>由于程序的窗口接口基于 <code>glfw</code> ，因此需要支持的实例扩展至少需要包括 <code>glfw</code> 相关扩展。同时，为了程序的扩展性，需要一个辅助函数来获取所有的实例扩展：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredInstanceExtensions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过函数 <code>glfwGetRequiredInstanceExtensions</code> 来获取 <code>glfw</code> 所需的扩展，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>** <span class="title">glfwGetRequiredInstanceExtensions</span><span class="params">(<span class="type">uint32_t</span>* count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>count</td>
<td>整数指针</td>
<td>用于存储返回的扩展名数量的指针。如果传入 <code>nullptr</code>，则不会返回数量信息。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>字符串数组</td>
<td>包含了 Vulkan 实例创建时所需的扩展名。</td>
</tr>
</tbody></table>
<blockquote>
<p>在 Windows 上，函数通常会返回 <code>&quot;VK_KHR_surface&quot;</code> 和 <code>&quot;VK_KHR_win32_surface&quot;</code>，而在 Linux 上，它可能返回 <code>&quot;VK_KHR_surface&quot;</code> 和 <code>&quot;VK_KHR_xcb_surface&quot;</code> 或 <code>&quot;VK_KHR_wayland_surface&quot;</code>，取决于窗口系统。</p>
</blockquote>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredInstanceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Get the required extensions for GLFW */</span></span><br><span class="line">    <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="检查扩展是否可用"><a href="#检查扩展是否可用" class="headerlink" title="检查扩展是否可用"></a>检查扩展是否可用</h2><p>需要一个辅助函数来检查所有请求的实例层扩展是否都可用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInstanceExtensionSupport</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>首先，使用 <code>vkEnumerateInstanceExtensionProperties</code> 获取所有可用的实例层扩展，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkEnumerateInstanceExtensionProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>*                                 pLayerName,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pPropertyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkExtensionProperties*                      pProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>pLayerName</td>
<td>层名称</td>
<td>传入某个 层（Layer） 的名称时，将返回该层提供的实例扩展列表。<br />传入 <code>nullptr</code> 时，返回所有全局可用的 Vulkan 实例扩展。</td>
</tr>
<tr>
<td>输入或输出参数</td>
<td>pPropertyCount</td>
<td>扩展属性信息数组大小</td>
<td>若 <code>pProperties</code> 为 <code>nullptr</code>，<code>pPropertyCount</code> 会返回可用的扩展属性数量。<br />如果 <code>pProperties</code> 不是 <code>nullptr</code>，则 <code>pPropertyCount</code> 需要指向一个变量，表示 <code>pProperties</code> 数组的大小，函数会填充数组，并更新 <code>pPropertyCount</code> 为实际写入的扩展数量。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pProperties</td>
<td>扩展属性信息数组指针</td>
<td>若不为 <code>nullptr</code>，用于存储 Vulkan 扩展的属性信息，每个元素是 <code>VkExtensionProperties</code> 结构体，包含扩展的名称、版本信息。<br />若为 <code>nullptr</code>，则函数仅返回可用扩展的数量到 <code>pPropertyCount</code>。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>扩展属性是否获取成功</td>
<td><code>VK_SUCCESS</code>：成功获取可用扩展属性，其他错误码表示获取失败。</td>
</tr>
</tbody></table>
<p>其中 <code>VkExtensionProperties</code> 的成员如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkExtensionProperties</span> &#123;</span><br><span class="line"><span class="type">char</span>        extensionName[VK_MAX_EXTENSION_NAME_SIZE];</span><br><span class="line"><span class="type">uint32_t</span>    specVersion;</span><br><span class="line">&#125; VkExtensionProperties;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>extensionName</td>
<td>扩展名称</td>
<td>表示扩展的唯一标识符。扩展名称是一个以空字符（<code>\0</code>）结尾的字符串。</td>
</tr>
<tr>
<td>specVersion</td>
<td>扩展版本号</td>
<td>表示扩展的规范版本。版本号通常是一个整数，用于标识扩展的修订或更新。</td>
</tr>
</tbody></table>
<p>这个函数需要两次调用，首先将 <code>pProperties</code> 设置为 <code>nullptr</code>，获取可用实例层扩展数量，然后再调用并传入 <code>VkExtensionProperties</code> 指针来获取属性信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkInstanceExtensionSupport</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Get the number of available extensions */</span></span><br><span class="line">	<span class="type">uint32_t</span> extensionCount;</span><br><span class="line">	<span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the attribute information of the extensions */</span></span><br><span class="line">	<span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">extensionProperties</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">	<span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, extensionProperties.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，遍历所需的扩展，并依次检查请求的扩展是否在可用的扩展中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkInstanceExtensionSupport</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* extensionName : <span class="built_in">getRequiredInstanceExtensions</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">bool</span> extensionFound = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/* Check if the extension is in the available extensions */</span></span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extensionProperty : extensionProperties)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extensionName, extensionProperty.extensionName) == <span class="number">0</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	            extensionFound = <span class="literal">true</span>;</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (!extensionFound)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，在 <code>init</code> 中执行此检查：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkInstanceExtensionSupport</span>())</span><br><span class="line">	&#123;</span><br><span class="line"> 	   <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Instance extenison not available!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="启用扩展"><a href="#启用扩展" class="headerlink" title="启用扩展"></a>启用扩展</h2><p>在 <code>ContentManager::createInstance</code> 函数中 <code>VkInstanceCreateInfo</code> 结构体的初始化中包含扩展名称：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/* Extension Information */</span></span><br><span class="line">	<span class="keyword">auto</span> extensions = <span class="built_in">getRequiredInstanceExtensions</span>();</span><br><span class="line">	instanceCreateInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(extensions.<span class="built_in">size</span>());</span><br><span class="line">	instanceCreateInfo.ppEnabledExtensionNames = extensions.<span class="built_in">data</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="验证层"><a href="#验证层" class="headerlink" title="验证层"></a>验证层</h1><p>Vulkan API 的设计理念之一是最小化驱动程序开销，这一目标的体现之一就是默认情况下 API 中的错误检查非常有限。甚至像将枚举值设置为错误的值，或者向必需的参数传递空指针这样简单的错误，通常都不会被显式处理，而是会导致崩溃或未定义行为。Vulkan 引入了一种机制来解决这个问题，即 <strong>验证层（Validation Layers）</strong>。</p>
<p>验证层是可选组件，它们会拦截 Vulkan 函数调用并执行额外的操作。常见的验证层功能包括：</p>
<ul>
<li>检查参数值是否符合规范，以检测误用</li>
<li>跟踪对象的创建和销毁，以发现资源泄漏</li>
<li>通过追踪调用线程来检查线程安全性</li>
<li>记录每个调用及其参数到标准输出</li>
<li>追踪 Vulkan 调用，以进行性能分析和回放</li>
</ul>
<p>Vulkan 本身不包含任何内置的验证层，但 <strong>LunarG Vulkan SDK</strong> 提供了一组完整的验证层。使用验证层是避免应用程序在不同的驱动程序上因依赖未定义行为而崩溃的最佳方式。</p>
<blockquote>
<p><strong>注意</strong>：验证层必须安装到系统上才能使用。例如，LunarG 提供的验证层仅在安装了 Vulkan SDK 的 PC 上可用。</p>
</blockquote>
<p>Vulkan 过去有两种不同类型的验证层：<strong>实例级（Instance）</strong> 和 <strong>设备级（Device）</strong>。实例级层仅检查与 Vulkan 全局对象（如 <code>VkInstance</code>）相关的调用，而设备级层则检查特定 GPU 相关的调用。然而，设备级层已被废弃，这意味着实例级验证层现在适用于所有 Vulkan 调用。尽管如此，规范文档仍然建议在逻辑设备级别启用验证层，以保持兼容性。</p>
<h2 id="配置验证层"><a href="#配置验证层" class="headerlink" title="配置验证层"></a>配置验证层</h2><p>验证层需要通过其名称显式启用，所有常见的标准验证功能都被打包到 <code>VK_LAYER_KHRONOS_validation</code> 层中，该层包含在 Vulkan SDK 中。通常，验证层只需要启用 <code>VK_LAYER_KHRONOS_validation</code>，但也可以启用一些第三方验证层（例如 <code>VK_LAYER_LUNARG_api_dump</code>，<code>VK_LAYER_RENDERDOC_Capture</code> ），为了程序的可拓展性，使用一个辅助函数来获取验证层名称：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredValidationLayers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredValidationLayers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; validationLayers&#123;&#125;;</span><br><span class="line">    validationLayers.<span class="built_in">push_back</span>(<span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> validationLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此外，通常验证层只会在 <code>Debug</code> 模式下启用来提升 <code>Release</code> 模式下的性能，通过基于是否处于调试模式（<code>NDEBUG</code> 宏）来决定是否启用验证层：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="type">bool</span> enableValidationLayers = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> enableValidationLayers = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="检查验证层是否可用"><a href="#检查验证层是否可用" class="headerlink" title="检查验证层是否可用"></a>检查验证层是否可用</h2><p>需要一个辅助函数来检查所有请求的验证层是否都可用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidationLayerSupport</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>首先，使用 <code>vkEnumerateInstanceLayerProperties</code> 获取所有可用的实例层属性，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkEnumerateInstanceLayerProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pPropertyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkLayerProperties*                          pProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入或输出参数</td>
<td>pPropertyCount</td>
<td>实例层属性信息数组大小</td>
<td>如果 <code>pProperties</code> 为 <code>nullptr</code>，<code>pPropertyCount</code> 会返回可用的实例层属性数量。<br />如果 <code>pProperties</code> 不是 <code>nullptr</code>，则 <code>pPropertyCount</code> 需要指向一个变量，表示 <code>pProperties</code> 数组的大小，函数会填充数组，并更新 <code>pPropertyCount</code> 为实际写入的层数。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pProperties</td>
<td>实例层属性信息数组指针</td>
<td>若不为 <code>nullptr</code>，用于存储 Vulkan 实例层的属性信息，每个元素是 <code>VkLayerProperties</code> 结构体，包含层的名称、描述、版本等信息。<br />若为 <code>nullptr</code>，则函数仅返回可用层的数量到 <code>pPropertyCount</code>。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>可用实例层属性获取是否成功</td>
<td><code>VK_SUCCESS</code>：成功获取可用实例层属性，其他错误码表示获取失败。</td>
</tr>
</tbody></table>
<p>其中 <code>VkLayerProperties</code> 的成员如下：：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkLayerProperties</span> &#123;</span><br><span class="line"> <span class="type">char</span>        layerName[VK_MAX_EXTENSION_NAME_SIZE];</span><br><span class="line"> <span class="type">uint32_t</span>    specVersion;</span><br><span class="line"> <span class="type">uint32_t</span>    implementationVersion;</span><br><span class="line"> <span class="type">char</span>        description[VK_MAX_DESCRIPTION_SIZE];</span><br><span class="line">&#125; VkLayerProperties;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>layerName</td>
<td>层名称</td>
<td>表示层的唯一标识符。层名称是一个以空字符（<code>\0</code>）结尾的字符串。</td>
</tr>
<tr>
<td>specVersion</td>
<td>层的规范版本号</td>
<td>表示层的规范版本。版本号通常是一个整数，用于标识层的修订或更新。</td>
</tr>
<tr>
<td>implementationVersion</td>
<td>层的实现版本号</td>
<td>表示层的实现版本。实现版本号通常是一个整数，用于标识层的具体实现或发布版本。</td>
</tr>
<tr>
<td>description</td>
<td>层的描述信息</td>
<td>提供关于层的简要描述，通常包括层的功能或用途。</td>
</tr>
</tbody></table>
<p>这个函数需要两次调用，首先将 <code>pProperties</code> 设置为 <code>nullptr</code>，获取可用实例层属性数量，然后再调用并传入 <code>VkLayerProperties</code> 指针来获取属性信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkValidationLayerSupport</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Get the number of available validation layers */</span></span><br><span class="line">	<span class="type">uint32_t</span> layerPropertyCount;</span><br><span class="line">	<span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerPropertyCount, <span class="literal">nullptr</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Get the attribute information of the validation layer */</span></span><br><span class="line">	<span class="function">std::vector&lt;VkLayerProperties&gt; <span class="title">layerProperties</span><span class="params">(layerPropertyCount)</span></span>;</span><br><span class="line">	<span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerPropertyCount, layerProperties.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，遍历所需的验证层，并依次检查请求的验证层是否在可用的实例层属性中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkValidationLayerSupport</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* layerName : <span class="built_in">getRequiredValidationLayers</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">bool</span> layerFound = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/* Check if the validation layer is in the available validation layers */</span></span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layerProperties : layerProperties)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="number">0</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	            layerFound = <span class="literal">true</span>;</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (!layerFound)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，在 <code>init</code> 中执行此检查：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers &amp;&amp; !<span class="built_in">checkValidationLayerSupport</span>())</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Validation not available!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="启用验证层"><a href="#启用验证层" class="headerlink" title="启用验证层"></a>启用验证层</h2><p>在 <code>ContentManager::createInstance</code> 函数中 <code>VkInstanceCreateInfo</code> 结构体的初始化中包含验证层名称：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/* Validation Layers Information */</span></span><br><span class="line">	<span class="keyword">auto</span> validationLayers = <span class="built_in">getRequiredValidationLayers</span>();</span><br><span class="line">	VkDebugUtilsMessengerCreateInfoEXT debugMessengerCreateInfo&#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;enableValidationLayers)</span><br><span class="line">	&#123;</span><br><span class="line">	    instanceCreateInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">	    instanceCreateInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    instanceCreateInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">	    instanceCreateInfo.ppEnabledLayerNames = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="自定义验证层消息"><a href="#自定义验证层消息" class="headerlink" title="自定义验证层消息"></a>自定义验证层消息</h1><p>默认情况下，验证层会将调试消息打印到标准输出，但也可以在程序中提供显式的回调函数来自行处理它们。这样可以让我们决定要查看哪些类型的消息，因为并非所有消息都是（致命）错误。为了在程序中设置回调来处理消息及其相关细节，我们需要使用 <code>VK_EXT_debug_utils</code> 扩展来设置一个调试信使（debug messenger）并绑定回调。</p>
<h2 id="获取所需扩展"><a href="#获取所需扩展" class="headerlink" title="获取所需扩展"></a>获取所需扩展</h2><p>首先，扩展 <code>getRequiredInstanceExtensions</code> 函数，使其包含 <code>VK_EXT_debug_utils</code> 扩展 。这里使用 <code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code> 宏（等同于 <code>&quot;VK_EXT_debug_utils&quot;</code> 字符串）来避免拼写错误。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredInstanceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="调试回调函数"><a href="#调试回调函数" class="headerlink" title="调试回调函数"></a>调试回调函数</h2><p>接下来，我们定义一个静态成员函数 <code>debugCallback</code>，它的原型是 <code>PFN_vkDebugUtilsMessengerCallbackEXT</code>，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VkBool32</span> <span class="params">(VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>*                                            pUserData)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>messageSeverity</td>
<td>消息的严重程度</td>
<td>可选值包括，这些值可以进行 位或运算 (&#96;</td>
</tr>
<tr>
<td>输入参数</td>
<td>messageTypes</td>
<td>消息的类别</td>
<td>可选值包括，这些值可以进行 位或运算 (&#96;</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCallbackData</td>
<td>详细调试信息</td>
<td>包含详细的调试信息，主要字段包括：<br /><code>pCallbackData-&gt;pMessage</code>：调试消息。<br /><code>pCallbackData-&gt;objectCount</code>：涉及的 Vulkan 对象数量。 <br /><code>pCallbackData-&gt;pObjects</code>：Vulkan 对象数组。<br /><code>pCallbackData-&gt;queueLabelCount / pQueueLabels</code>：Vulkan 队列相关信息 <br /><code>pCallbackData-&gt;cmdBufLabelCount / pCmdBufLabels</code>：命令缓冲区信息 <br /><code>pCallbackData-&gt;messageIdNumber / pMessageIdName</code>：消息 ID</td>
</tr>
<tr>
<td>输入参数</td>
<td>pUserData</td>
<td>用户自定义数据</td>
<td>调用 <code>vkCreateDebugUtilsMessengerEXT</code> 时传入的 <code>pUserData</code> 指针，可用于在回调函数中访问自定义上下文。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>是否继续执行</td>
<td><code>VK_FALSE</code>：正常继续执行（大多数情况下返回这个）<br /><code>VK_TRUE</code>：终止 Vulkan API 调用（仅用于测试验证层）</td>
</tr>
</tbody></table>
<p>使用 <code>VKAPI_ATTR</code> 和 <code>VKAPI_CALL</code> 确保该函数的签名正确，一个只在存在错误或警告信息时输出调试信息的回调函数如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* pUserData)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (messageSeverity &gt;= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)</span><br><span class="line">	&#123;</span><br><span class="line">    	std::cerr &lt;&lt; <span class="string">&quot;Validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> VK_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置调试信使"><a href="#配置调试信使" class="headerlink" title="配置调试信使"></a>配置调试信使</h2><p>Vulkan 的调试回调信使是由 <code>VkDebugUtilsMessengerEXT</code> 管理的，需要显式创建和销毁。首先，在类中添加 <code>debugMessenger</code> 成员：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;        </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createDebugMessenger</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VkDebugUtilsMessengerEXT debugMessenger;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过填充 <code>VkDebugUtilsMessengerCreateInfoEXT</code> 结构体来描述一个调试回调信使，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDebugUtilsMessengerCreateInfoEXT</span> &#123;</span><br><span class="line">    VkStructureType                         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                             pNext;</span><br><span class="line">    VkDebugUtilsMessengerCreateFlagsEXT     flags;</span><br><span class="line">    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;</span><br><span class="line">    VkDebugUtilsMessageTypeFlagsEXT         messageType;</span><br><span class="line">    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;</span><br><span class="line">    <span class="type">void</span>*                                   pUserData;</span><br><span class="line">&#125; VkDebugUtilsMessengerCreateInfoEXT;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT</code>，以表明这是一个 <strong>调试回调器创建信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展信息的指针，如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>调试回调器创建时的附加标志</td>
<td>目前 必须为 <code>0</code>，因为 Vulkan 还没有定义任何标志位。</td>
</tr>
<tr>
<td>messageSeverity</td>
<td>要捕获的消息的严重性级别</td>
<td>可选值包括，这些值可以进行 位或运算 (&#96;</td>
</tr>
<tr>
<td>messageType</td>
<td>要捕获的消息类型</td>
<td>可选值包括，这些值可以进行 位或运算 (&#96;</td>
</tr>
<tr>
<td>pfnUserCallback</td>
<td>自定义回调函数</td>
<td>指向用户自定义的回调函数，用于接收 Vulkan 生成的调试信息。</td>
</tr>
<tr>
<td>pUserData</td>
<td>自定义数据指针</td>
<td>允许传递一个自定义指针给回调函数，与回调函数中的 <code>pUserData</code> 对应。</td>
</tr>
</tbody></table>
<p>与自定义的调试回调函数一致，一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createDebugMessenger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">    createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    createInfo.flags = <span class="number">0</span>;</span><br><span class="line">    createInfo.messageSeverity =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">                             VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">                             VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">    createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">    createInfo.pUserData = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建调试信使"><a href="#创建调试信使" class="headerlink" title="创建调试信使"></a>创建调试信使</h2><p>调用函数 <code>vkCreateDebugUtilsMessengerEXT</code> 来创建调试信使，由于其是扩展函数，必须使用 <code>vkGetInstanceProcAddr</code> 手动加载：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createDebugMessenger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VkDebugUtilsMessengerCreateInfoEXT createInfo&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">auto</span> function = (PFN_vkCreateDebugUtilsMessengerEXT)<span class="built_in">vkGetInstanceProcAddr</span>(<span class="keyword">this</span>-&gt;instance, <span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (function != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">function</span>(<span class="keyword">this</span>-&gt;instance, &amp;createInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;debugMessenger);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to set up debug messenger!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 中，在实例创建之后调用函数 <code>createDebugMessenger</code> 来创建调试回调信使：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">createDebugMessenger</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理调试信使"><a href="#清理调试信使" class="headerlink" title="清理调试信使"></a>清理调试信使</h2><p>同样，<code>vkDestroyDebugUtilsMessengerEXT</code> 也需要手动加载，在 <code>clear</code> 中释放资源：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line">ContentManager::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;enableValidationLayers)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">auto</span> function = (PFN_vkDestroyDebugUtilsMessengerEXT)<span class="built_in">vkGetInstanceProcAddr</span>(<span class="keyword">this</span>-&gt;instance, <span class="string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">	    <span class="built_in">function</span>(<span class="keyword">this</span>-&gt;instance, <span class="keyword">this</span>-&gt;debugMessenger, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyInstance</span>(<span class="keyword">this</span>-&gt;instance, <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="调试实例创建和销毁"><a href="#调试实例创建和销毁" class="headerlink" title="调试实例创建和销毁"></a>调试实例创建和销毁</h2><p>为了能够调试实例的创建和销毁，需要在 <code>VkInstanceCreateInfo</code> 的 <code>pNext</code> 扩展字段中传递一个指向 <code>VkDebugUtilsMessengerCreateInfoEXT</code> 结构体的指针，这里的结构体和之前的保持一致：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Validation Layers Information */</span></span><br><span class="line">	<span class="keyword">auto</span> validationLayers = <span class="built_in">getRequiredValidationLayers</span>();</span><br><span class="line">	VkDebugUtilsMessengerCreateInfoEXT debugMessengerCreateInfo&#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;enableValidationLayers)</span><br><span class="line">	&#123;</span><br><span class="line">	    instanceCreateInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">	    instanceCreateInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">	</span><br><span class="line">	    debugMessengerCreateInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">	    debugMessengerCreateInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |</span><br><span class="line">	                                               VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">	                                               VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">	    debugMessengerCreateInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">	                                           VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">	                                           VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">	    debugMessengerCreateInfo.pfnUserCallback = debugCallback;</span><br><span class="line">	</span><br><span class="line">	    instanceCreateInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*)&amp;debugMessengerCreateInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    instanceCreateInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">	    instanceCreateInfo.ppEnabledLayerNames = <span class="literal">nullptr</span>;</span><br><span class="line">	    instanceCreateInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><p>在通过 <code>VkInstance</code> 初始化 Vulkan 库之后，我们需要在系统中查找并选择一个支持我们所需功能的显卡，也被称为物理设备。</p>
<h2 id="选择物理设备"><a href="#选择物理设备" class="headerlink" title="选择物理设备"></a>选择物理设备</h2><p>添加物理设备句柄 <code>VkPhysicalDevice</code> 作为成员变量，并添加函数 <code>choosePhysicalDevice</code> 来进行物理设备的选择，添加函数 <code>isDeviceSuitable</code> 来检查某个设备是否符合要求：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">choosePhysicalDevice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>首先，通过函数 <code>vkEnumeratePhysicalDevices</code> 来列举出所有的物理设备，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkEnumeratePhysicalDevices</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance                                  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pPhysicalDeviceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice*                           pPhysicalDevices)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>instance</td>
<td>实例句柄</td>
<td>指定要查询物理设备的 Vulkan 实例。</td>
</tr>
<tr>
<td>输入输出参数</td>
<td>pPhysicalDeviceCount</td>
<td>物理设备数量</td>
<td>若 <code>pPhysicalDevices</code> 为 <code>nullptr</code>，则该变量会被设置为系统中可用的物理设备数量。<br />若 <code>pPhysicalDevices</code> 不为 <code>nullptr</code>，则该变量应指定 <code>pPhysicalDevices</code> 数组的大小，函数会将其更新为实际返回的物理设备数量。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPhysicalDevices</td>
<td>物理设备数组</td>
<td>若为 <code>nullptr</code>，函数仅返回物理设备的数量。<br />若为 <code>nullptr</code>，函数会将枚举到的物理设备句柄存储在该数组中。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>物理设备是否列举成功</td>
<td><code>VK_SUCCESS</code>：成功获取可用扩展属性，其他错误码表示获取失败。</td>
</tr>
</tbody></table>
<p>这个函数需要两次调用，首先将 <code>pPhysicalDevices</code> 设置为 <code>nullptr</code>，获取物理设备数量，然后再调用并传入 <code>VkPhysicalDevice</code> 指针来获取物理设备：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::choosePhysicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Get the number of physical devices */</span></span><br><span class="line">    <span class="type">uint32_t</span> deviceCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(<span class="keyword">this</span>-&gt;instance, &amp;deviceCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (deviceCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to find GPUs with Vulkan support!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get all physical devices */</span></span><br><span class="line">    <span class="function">std::vector&lt;VkPhysicalDevice&gt; <span class="title">devices</span><span class="params">(deviceCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(<span class="keyword">this</span>-&gt;instance, &amp;deviceCount, devices.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，调用 <code>isDeviceSuitable</code> 函数来确定一个物理设备是否满足条件：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::choosePhysicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find physical devices that meet requirements */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; device : devices)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isDeviceSuitable</span>(device))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;physicalDevice = device;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;physicalDevice == VK_NULL_HANDLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to find a suitable GPU!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，在 <code>init</code> 中，在实例创建之后调用函数 <code>choosePhysicalDevice</code> 来选择物理设备：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">choosePhysicalDevice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接下来，只需要扩展 <code>isDeviceSuitable</code> 函数就能够自动完成对于物理设备的选择。</p>
<h2 id="配置设备扩展"><a href="#配置设备扩展" class="headerlink" title="配置设备扩展"></a>配置设备扩展</h2><p>为了程序的扩展性，需要一个辅助函数来获取所有的设备扩展：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredDeviceExtensions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这里暂时留空，后续将会扩展这个函数：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredDeviceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; deviceExtensions&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> deviceExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="检查扩展是否可用-1"><a href="#检查扩展是否可用-1" class="headerlink" title="检查扩展是否可用"></a>检查扩展是否可用</h2><p>需要一个辅助函数来检查所有请求的设备扩展是否都可用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice physicalDevice)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>首先，使用 <code>vkEnumerateDeviceExtensionProperties</code> 获取所有可用的实例层属性，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkEnumerateDeviceExtensionProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>*                                 pLayerName,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pPropertyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkExtensionProperties*                      pProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>要查询的物理设备。</td>
</tr>
<tr>
<td>输入或输出参数</td>
<td>pLayerName</td>
<td>查询的层名称</td>
<td>指定要查询的层名称。如果为 <code>nullptr</code>，则查询设备本身支持的扩展。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pPropertyCount</td>
<td>设备属性信息数组指针</td>
<td>如果 <code>pProperties</code> 为 <code>nullptr</code>，<code>pPropertyCount</code> 会返回可用的设备属性数量。<br />如果 <code>pProperties</code> 不是 <code>nullptr</code>，则 <code>pPropertyCount</code> 需要指向一个变量，表示 <code>pProperties</code> 数组的大小，函数会填充数组，并更新 <code>pPropertyCount</code> 为实际写入的层数。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pProperties</td>
<td></td>
<td>若不为 <code>nullptr</code>，用于存储 Vulkan 设备的属性信息，每个元素是 <code>VkExtensionProperties</code> 结构体，包含扩展的名称、版本信息。<br />若为 <code>nullptr</code>，则函数仅返回可用层的数量到 <code>pPropertyCount</code>。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>可用设备属性获取是否成功</td>
<td><code>VK_SUCCESS</code>：成功获取可用设备属性，其他错误码表示获取失败。</td>
</tr>
</tbody></table>
<p>其中 <code>VkExtensionProperties</code> 的成员如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkExtensionProperties</span> &#123;</span><br><span class="line"><span class="type">char</span>        extensionName[VK_MAX_EXTENSION_NAME_SIZE];</span><br><span class="line"><span class="type">uint32_t</span>    specVersion;</span><br><span class="line">&#125; VkExtensionProperties;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>extensionName</td>
<td>扩展名称</td>
<td>表示扩展的唯一标识符。扩展名称是一个以空字符（<code>\0</code>）结尾的字符串。</td>
</tr>
<tr>
<td>specVersion</td>
<td>扩展版本号</td>
<td>表示扩展的规范版本。版本号通常是一个整数，用于标识扩展的修订或更新。</td>
</tr>
</tbody></table>
<p>这个函数需要两次调用，首先将 <code>pProperties</code> 设置为 <code>nullptr</code>，获取可用设备层扩展数量，然后再调用并传入 <code>VkExtensionProperties</code> 指针来获取属性信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice physicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Get the number of extensions supported by the physical device */</span></span><br><span class="line">	<span class="type">uint32_t</span> extensionCount;</span><br><span class="line">	<span class="built_in">vkEnumerateDeviceExtensionProperties</span>(physicalDevice, <span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get all extensions supported by the physical device */</span></span><br><span class="line">	<span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">extensionProperties</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">	<span class="built_in">vkEnumerateDeviceExtensionProperties</span>(physicalDevice, <span class="literal">nullptr</span>, &amp;extensionCount, extensionProperties.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，遍历所需的扩展，并依次检查请求的扩展是否在可用的扩展中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::checkDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice physicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* extensionName : <span class="built_in">getRequiredDeviceExtensions</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">bool</span> extensionFound = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/* Check if the extension is in the available extensions */</span></span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extensionProperty : extensionProperties)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extensionName, extensionProperty.extensionName) == <span class="number">0</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	            extensionFound = <span class="literal">true</span>;</span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (!extensionFound)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，扩展函数 <code>isDeviceSuitable</code> 执行此检查：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice physicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">checkDeviceExtensionSupport</span>(physicalDevice))</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="队列族"><a href="#队列族" class="headerlink" title="队列族"></a>队列族</h1><p>Vulkan 中的几乎所有操作，从绘制到上传纹理，都需要将命令提交到队列中。队列有不同的类型，它们源自不同的队列族，每个队列族只允许执行特定类型的命令。可能的队列族列举如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志位</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>图形队列族</td>
<td><code>VK_QUEUE_GRAPHICS_BIT</code></td>
<td>支持图形渲染相关的操作，例如绘制、几何着色器、顶点着色器等。</td>
</tr>
<tr>
<td>计算队列族</td>
<td><code>VK_QUEUE_COMPUTE_BIT</code></td>
<td>支持计算相关的操作，例如通用计算、并行计算任务。</td>
</tr>
<tr>
<td>传输队列族</td>
<td><code>VK_QUEUE_TRANSFER_BIT</code></td>
<td>支持内存传输相关的操作，例如缓冲区复制、图像复制等。</td>
</tr>
<tr>
<td>稀疏资源队列族</td>
<td><code>VK_QUEUE_SPARSE_BINDING_BIT</code></td>
<td>支持稀疏资源管理，例如动态绑定内存到稀疏纹理或缓冲区。</td>
</tr>
<tr>
<td>保护队列族</td>
<td><code>VK_QUEUE_PROTECTED_BIT</code></td>
<td>支持受保护的内存和操作，用于安全相关的任务。</td>
</tr>
<tr>
<td>视频解码队列族</td>
<td><code>VK_QUEUE_VIDEO_DECODE_BIT_KHR</code></td>
<td>支持视频解码操作。</td>
</tr>
<tr>
<td>视频编码队列族</td>
<td><code>VK_QUEUE_VIDEO_ENCODE_BIT_KHR</code></td>
<td>支持视频编码操作。</td>
</tr>
<tr>
<td>光追队列族</td>
<td><code>VK_QUEUE_OPTICAL_FLOW_BIT_NV</code></td>
<td>支持光流相关的操作。</td>
</tr>
</tbody></table>
<p>一个物理设备可能支持多个队列族，并且某些队列族可能支持多种类型的操作。例如，一个队列族可能同时支持图形和计算操作（<code>VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT</code>）。因此需要检查设备支持哪些队列族，并确定哪些队列族支持我们想要使用的命令。</p>
<p>在 Vulkan 应用中，最常使用的队列包括图形队列、传输队列和呈现队列。因此，需要查询图形队列族和传输队列族的索引，添加类成员来存储查询得到的队列族索引：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">	<span class="type">uint32_t</span> graphicsFamily;</span><br><span class="line">	<span class="type">uint32_t</span> transferFamily;</span><br><span class="line">    <span class="type">uint32_t</span> presentFamily;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="查询队列族索引"><a href="#查询队列族索引" class="headerlink" title="查询队列族索引"></a>查询队列族索引</h2><p>首先，通过函数 <code>vkGetPhysicalDeviceQueueFamilyProperties</code> 来获取队列族列表，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pQueueFamilyPropertyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueueFamilyProperties*                    pQueueFamilyProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询队列族属性的物理设备。</td>
</tr>
<tr>
<td>输入输出参数</td>
<td>pQueueFamilyPropertyCount</td>
<td>队列族的数量</td>
<td>若 <code>pQueueFamilyProperties</code> 为 <code>nullptr</code>，则该变量会被设置为设备支持的队列族数量。<br />若 <code>pQueueFamilyProperties</code> 不为 <code>nullptr</code>，则该变量应指定 <code>pQueueFamilyProperties</code> 数组的大小，函数会将其更新为实际返回的队列族数量。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pQueueFamilyProperties</td>
<td>队列族数组</td>
<td>若为 <code>nullptr</code>，函数仅返回队列族的数量。<br />若为 <code>nullptr</code>，函数会将队列族的属性信息存储在该数组中。</td>
</tr>
</tbody></table>
<p>其中，<code>VkQueueFamilyProperties</code> 的成员如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkQueueFamilyProperties</span> &#123;</span><br><span class="line"> VkQueueFlags    queueFlags;</span><br><span class="line"> <span class="type">uint32_t</span>        queueCount;</span><br><span class="line"> <span class="type">uint32_t</span>        timestampValidBits;</span><br><span class="line"> VkExtent3D      minImageTransferGranularity;</span><br><span class="line">&#125; VkQueueFamilyProperties;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>queueFlags</td>
<td>队列族支持的操作类型</td>
<td>表示队列族支持的操作类型，它是一个位掩码，可能的标志包括：<br /><code>VK_QUEUE_GRAPHICS_BIT</code>：支持图形操作。 <br /><code>VK_QUEUE_COMPUTE_BIT</code>：支持计算操作。 <br /><code>VK_QUEUE_TRANSFER_BIT</code>：支持传输操作。 <br /><code>VK_QUEUE_SPARSE_BINDING_BIT</code>：支持稀疏资源绑定。<br /> <code>VK_QUEUE_PROTECTED_BIT</code>：支持受保护的操作。<br /> <code>VK_QUEUE_VIDEO_DECODE_BIT_KHR</code>：视频解码。<br /><code>VK_QUEUE_VIDEO_ENCODE_BIT_KHR</code>：视频编码。<br /><code>VK_QUEUE_OPTICAL_FLOW_BIT_NV</code>：光流计算。</td>
</tr>
<tr>
<td>queueCount</td>
<td>队列族支持的队列数量</td>
<td>表示可以基于该队列族创建多少个队列。</td>
</tr>
<tr>
<td>timestampValidBits</td>
<td>时间戳的有效位数</td>
<td>指示时间戳查询（<code>vkGetDeviceQueue</code> 或 <code>vkCmdWriteTimestamp</code>）中有效的时间戳位数。例如，如果值为 32，则表示时间戳的低 32 位是有效的。</td>
</tr>
<tr>
<td>minImageTransferGranularity</td>
<td>图像传输操作的最小粒度</td>
<td><code>width</code>：宽度方向的最小粒度。 <br /><code>height</code>：高度方向的最小粒度。 <br /><code>depth</code>：深度方向的最小粒度。</td>
</tr>
</tbody></table>
<p>这个函数需要两次调用，首先将 <code>pQueueFamilyProperties</code> 设置为 <code>nullptr</code>，获取队列族数量，然后再调用并传入 <code>VkQueueFamilyProperties</code> 指针来获取队列族列表，这里通过扩展 <code>isDeviceSuitable</code> 函数来检查物理设备是否支持我们需要的队列族，并进行队列族的选择：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Get the number of queue families */</span></span><br><span class="line">	<span class="type">uint32_t</span> queueFamilyCount = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="literal">nullptr</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Get queue family details */</span></span><br><span class="line">	<span class="function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="title">queueFamilies</span><span class="params">(queueFamilyCount)</span></span>;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里使用 <code>-1</code> 来表示尚未查询到，对于图形队列族 <code>VK_QUEUE_GRAPHICS_BIT</code> 和传输队列族 <code>VK_QUEUE_TRANSFER_BIT</code> 分别进行查询：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> graphics = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> transfer = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queueFamilyCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (graphics == <span class="number">-1</span> &amp;&amp; queueFamilies[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT)</span><br><span class="line">	    &#123;</span><br><span class="line">	        graphics = i;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">if</span> (transfer == <span class="number">-1</span> &amp;&amp; queueFamilies[i].queueFlags &amp; VK_QUEUE_TRANSFER_BIT)</span><br><span class="line">		&#123;</span><br><span class="line">	        transfer = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用函数 <code>vkGetPhysicalDeviceSurfaceSupportKHR</code> 来检查物理设备的某个队列族是否能够与给定的表面兼容，从而确定是否可以在该表面上进行图像呈现，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkGetPhysicalDeviceSurfaceSupportKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    queueFamilyIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR                                surface,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBool32*                                   pSupported)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询的物理设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>queueFamilyIndex</td>
<td>队列族索引</td>
<td>指定要查询的队列族的索引。</td>
</tr>
<tr>
<td>输入参数</td>
<td>surface</td>
<td>窗口表面</td>
<td>要检查的表面（Surface）。表面通常是与平台相关的窗口系统对象</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSupported</td>
<td>存储查询结果</td>
<td>指向一个 <code>VkBool32</code> 变量的指针，用于存储查询结果。如果指定的队列族支持与表面进行呈现，则设置为 <code>VK_TRUE</code>，否则为 <code>VK_FALSE</code>。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示查询是否成功</td>
<td><code>VK_SUCCESS</code>：表示查询成功，其他错误码表示查询失败。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> present = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queueFamilyCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">	    VkBool32 presentSupport = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(<span class="keyword">this</span>-&gt;physicalDevice, i, <span class="keyword">this</span>-&gt;surface, &amp;presentSupport);</span><br><span class="line">		<span class="keyword">if</span> (present != <span class="number">-1</span> &amp;&amp; presentSupport)</span><br><span class="line">		&#123;</span><br><span class="line">		    present = i;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在查询成功后，将得到的队列族索引存储起来并返回 <code>true</code> 来表示当前的物理设备满足需求，否则返回 <code>false</code>。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (graphics != <span class="number">-1</span> &amp;&amp; transfer != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">this</span>-&gt;graphicsFamily = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(graphics);</span><br><span class="line">	    <span class="keyword">this</span>-&gt;transferFamily = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(transfer);</span><br><span class="line">	    <span class="keyword">this</span>-&gt;presentFamily = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(present);</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="逻辑设备和队列"><a href="#逻辑设备和队列" class="headerlink" title="逻辑设备和队列"></a>逻辑设备和队列</h1><p>在完成物理设备的选择之后，就可以在其上创建逻辑设备。逻辑设备是与物理设备交互的接口，同一个物理设备上可以创建多个逻辑设备以满足不同的需求。一个<strong>逻辑设备</strong>由 <code>VkDevice</code> 描述。</p>
<p>创建一个逻辑设备通常需要首先描述 <strong>逻辑设备队列</strong>、<strong>物理设备特性</strong>，并通过其形成 <strong>逻辑设备描述信息</strong>，最后通过调用<strong>逻辑设备创建函数</strong>来完成逻辑设备的创建。</p>
<p>添加 <code>VkDevice</code> 为类成员，并添加 <code>createLogicalDevice</code> 函数来创建逻辑设备：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkDevice device;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createLogicalDevice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="逻辑设备队列"><a href="#逻辑设备队列" class="headerlink" title="逻辑设备队列"></a>逻辑设备队列</h2><p>首先，通过结构体 <code>VkDeviceQueueCreateInfo</code> 来描述一个逻辑设备队列，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDeviceQueueCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext;</span><br><span class="line">    VkDeviceQueueCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                    queueFamilyIndex;</span><br><span class="line">    <span class="type">uint32_t</span>                    queueCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>*                pQueuePriorities;</span><br><span class="line">&#125; VkDeviceQueueCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</code>，以表明这是一个 <strong>逻辑设备队列创建信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定队列创建时的附加标志。</td>
<td>通常设置为 <code>0</code>，可能的值包括：<br /><code>VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT</code>：用于创建受保护的队列，适用于需要硬件级别保护的场景。</td>
</tr>
<tr>
<td>queueFamilyIndex</td>
<td>指定队列所属的队列族的索引</td>
<td>该索引是在物理设备中通过调用 <code>vkGetPhysicalDeviceQueueFamilyProperties</code> 获取的。</td>
</tr>
<tr>
<td>queueCount</td>
<td>请求的队列数量</td>
<td>该数量不能超过指定队列族支持的最大队列数（通过 <code>VkQueueFamilyProperties.queueCount</code> 获取）。</td>
</tr>
<tr>
<td>pQueuePriorities</td>
<td>优先级数组</td>
<td>一个浮点数数组，用于指定每个队列的优先级。数组的大小必须等于 <code>queueCount</code>。优先级的值范围为 <code>[0.0, 1.0]</code>，其中 <code>1.0</code> 表示最高优先级。</td>
</tr>
</tbody></table>
<p>通常情况下，需求的多个不同类型的队列族的索引往往相同，在这里通过 <code>std::set</code> 去重。然后使用在选择物理设备时确定的队列族索引来填充信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;</span><br><span class="line">    std::set&lt;<span class="type">uint32_t</span>&gt; uniqueQueueFamilies = &#123;<span class="keyword">this</span>-&gt;graphicsFamily, <span class="keyword">this</span>-&gt;transferFamily, </span><br><span class="line">                                              <span class="keyword">this</span>-&gt;presentFamily&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> queuePriority = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> queueFamily : uniqueQueueFamilies)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Information about the queues used by the logical device */</span></span><br><span class="line">        VkDeviceQueueCreateInfo queueCreateInfo&#123;&#125;;</span><br><span class="line">        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;</span><br><span class="line">        queueCreateInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        queueCreateInfo.flags = <span class="number">0</span>;</span><br><span class="line">        queueCreateInfo.queueFamilyIndex = queueFamily;</span><br><span class="line">        queueCreateInfo.queueCount = <span class="number">1</span>;</span><br><span class="line">        queueCreateInfo.pQueuePriorities = &amp;queuePriority;</span><br><span class="line">        queueCreateInfos.<span class="built_in">push_back</span>(queueCreateInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="物理设备特性"><a href="#物理设备特性" class="headerlink" title="物理设备特性"></a>物理设备特性</h2><p>通过结构体 <code>VkPhysicalDeviceFeatures</code> 来描述一个设备特性，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceFeatures</span> &#123;</span><br><span class="line">    VkBool32    robustBufferAccess;</span><br><span class="line">    VkBool32    fullDrawIndexUint32;</span><br><span class="line">    VkBool32    imageCubeArray;</span><br><span class="line">    VkBool32    independentBlend;</span><br><span class="line">    VkBool32    geometryShader;</span><br><span class="line">    VkBool32    tessellationShader;</span><br><span class="line">    VkBool32    sampleRateShading;</span><br><span class="line">    VkBool32    dualSrcBlend;</span><br><span class="line">    VkBool32    logicOp;</span><br><span class="line">    VkBool32    multiDrawIndirect;</span><br><span class="line">    VkBool32    drawIndirectFirstInstance;</span><br><span class="line">    VkBool32    depthClamp;</span><br><span class="line">    VkBool32    depthBiasClamp;</span><br><span class="line">    VkBool32    fillModeNonSolid;</span><br><span class="line">    VkBool32    depthBounds;</span><br><span class="line">    VkBool32    wideLines;</span><br><span class="line">    VkBool32    largePoints;</span><br><span class="line">    VkBool32    alphaToOne;</span><br><span class="line">    VkBool32    multiViewport;</span><br><span class="line">    VkBool32    samplerAnisotropy;</span><br><span class="line">    VkBool32    textureCompressionETC2;</span><br><span class="line">    VkBool32    textureCompressionASTC_LDR;</span><br><span class="line">    VkBool32    textureCompressionBC;</span><br><span class="line">    VkBool32    occlusionQueryPrecise;</span><br><span class="line">    VkBool32    pipelineStatisticsQuery;</span><br><span class="line">    VkBool32    vertexPipelineStoresAndAtomics;</span><br><span class="line">    VkBool32    fragmentStoresAndAtomics;</span><br><span class="line">    VkBool32    shaderTessellationAndGeometryPointSize;</span><br><span class="line">    VkBool32    shaderImageGatherExtended;</span><br><span class="line">    VkBool32    shaderStorageImageExtendedFormats;</span><br><span class="line">    VkBool32    shaderStorageImageMultisample;</span><br><span class="line">    VkBool32    shaderStorageImageReadWithoutFormat;</span><br><span class="line">    VkBool32    shaderStorageImageWriteWithoutFormat;</span><br><span class="line">    VkBool32    shaderUniformBufferArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderSampledImageArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderStorageBufferArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderStorageImageArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderClipDistance;</span><br><span class="line">    VkBool32    shaderCullDistance;</span><br><span class="line">    VkBool32    shaderFloat64;</span><br><span class="line">    VkBool32    shaderInt64;</span><br><span class="line">    VkBool32    shaderInt16;</span><br><span class="line">    VkBool32    shaderResourceResidency;</span><br><span class="line">    VkBool32    shaderResourceMinLod;</span><br><span class="line">    VkBool32    sparseBinding;</span><br><span class="line">    VkBool32    sparseResidencyBuffer;</span><br><span class="line">    VkBool32    sparseResidencyImage2D;</span><br><span class="line">    VkBool32    sparseResidencyImage3D;</span><br><span class="line">    VkBool32    sparseResidency2Samples;</span><br><span class="line">    VkBool32    sparseResidency4Samples;</span><br><span class="line">    VkBool32    sparseResidency8Samples;</span><br><span class="line">    VkBool32    sparseResidency16Samples;</span><br><span class="line">    VkBool32    sparseResidencyAliased;</span><br><span class="line">    VkBool32    variableMultisampleRate;</span><br><span class="line">    VkBool32    inheritedQueries;</span><br><span class="line">&#125; VkPhysicalDeviceFeatures;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>robustBufferAccess</code></td>
<td>是否支持鲁棒的缓冲区访问。</td>
<td>如果启用，Vulkan 会确保对缓冲区的访问不会超出其边界，即使访问越界也不会导致崩溃或未定义行为。</td>
</tr>
<tr>
<td><code>fullDrawIndexUint32</code></td>
<td>是否支持完整的 32 位索引缓冲区。</td>
<td>如果启用，可以使用 32 位无符号整数作为索引缓冲区的数据类型。</td>
</tr>
<tr>
<td><code>imageCubeArray</code></td>
<td>是否支持立方体纹理数组。</td>
<td>如果启用，可以使用立方体纹理数组（<code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>）。</td>
</tr>
<tr>
<td><code>independentBlend</code></td>
<td>是否支持独立的混合状态。</td>
<td>如果启用，可以为每个颜色附件设置独立的混合状态。</td>
</tr>
<tr>
<td><code>geometryShader</code></td>
<td>是否支持几何着色器。</td>
<td>如果启用，可以在图形管线中使用几何着色器。</td>
</tr>
<tr>
<td><code>tessellationShader</code></td>
<td>是否支持曲面细分着色器。</td>
<td>如果启用，可以在图形管线中使用曲面细分控制着色器和曲面细分评估着色器。</td>
</tr>
<tr>
<td><code>sampleRateShading</code></td>
<td>是否支持采样率着色。</td>
<td>如果启用，可以在片段着色器中对每个采样点进行着色，而不是每个像素。</td>
</tr>
<tr>
<td><code>dualSrcBlend</code></td>
<td>是否支持双源混合。</td>
<td>如果启用，可以在混合操作中使用第二个颜色附件作为混合因子。</td>
</tr>
<tr>
<td><code>logicOp</code></td>
<td>是否支持逻辑操作。</td>
<td>如果启用，可以在颜色附件上执行逻辑操作（如 AND、OR、XOR 等）。</td>
</tr>
<tr>
<td><code>multiDrawIndirect</code></td>
<td>是否支持多绘制间接命令。</td>
<td>如果启用，可以使用 vkCmdDrawIndirect 和 vkCmdDrawIndexedIndirect 命令一次提交多个绘制命令。</td>
</tr>
<tr>
<td><code>drawIndirectFirstInstance</code></td>
<td>是否支持在间接绘制命令中指定第一个实例。</td>
<td>如果启用，可以在间接绘制命令中指定第一个实例的索引。</td>
</tr>
<tr>
<td><code>depthClamp</code></td>
<td>是否支持深度夹紧。</td>
<td>如果启用，可以将深度值夹紧到 [0, 1] 范围内，而不是丢弃超出范围的片段。</td>
</tr>
<tr>
<td><code>depthBiasClamp</code></td>
<td>是否支持深度偏置夹紧。</td>
<td>如果启用，可以限制深度偏置的最大值。</td>
</tr>
<tr>
<td><code>fillModeNonSolid</code></td>
<td>是否支持非实心填充模式。</td>
<td>如果启用，可以使用线框模式或点模式进行渲染。</td>
</tr>
<tr>
<td><code>wideLines</code></td>
<td>是否支持宽线渲染。</td>
<td>如果启用，可以渲染宽度大于 1.0 的线。</td>
</tr>
<tr>
<td><code>largePoints</code></td>
<td>是否支持大点渲染。</td>
<td>如果启用，可以渲染直径大于 1.0 的点。</td>
</tr>
<tr>
<td><code>alphaToOne</code></td>
<td>是否支持 Alpha-to-One 操作。</td>
<td>如果启用，可以将片段的 Alpha 值强制设置为 1.0。</td>
</tr>
<tr>
<td><code>multiViewport</code></td>
<td>是否支持多视口。</td>
<td>如果启用，可以在图形管线中使用多个视口。</td>
</tr>
<tr>
<td><code>samplerAnisotropy</code></td>
<td>是否支持各向异性过滤。</td>
<td>如果启用，可以在采样器中使用各向异性过滤。</td>
</tr>
<tr>
<td><code>textureCompressionETC2</code></td>
<td>是否支持 ETC2 纹理压缩格式。</td>
<td>如果启用，可以使用 ETC2 压缩格式的纹理。</td>
</tr>
<tr>
<td><code>textureCompressionASTC_LDR</code></td>
<td>是否支持 ASTC LDR 纹理压缩格式。</td>
<td>如果启用，可以使用 ASTC LDR 压缩格式的纹理。</td>
</tr>
<tr>
<td><code>textureCompressionBC</code></td>
<td>是否支持 BC（Block Compression）纹理压缩格式。</td>
<td>如果启用，可以使用 BC 压缩格式的纹理。</td>
</tr>
<tr>
<td><code>occlusionQueryPrecise</code></td>
<td>是否支持精确的遮挡查询。</td>
<td>如果启用，可以执行精确的遮挡查询。</td>
</tr>
<tr>
<td><code>pipelineStatisticsQuery</code></td>
<td>是否支持管线统计查询。</td>
<td>如果启用，可以查询图形管线的统计信息（如顶点数量、图元数量等）。</td>
</tr>
<tr>
<td><code>vertexPipelineStoresAndAtomics</code></td>
<td>是否支持顶点着色器中的存储和原子操作。</td>
<td>如果启用，顶点着色器可以使用存储缓冲区和原子操作。</td>
</tr>
<tr>
<td><code>fragmentStoresAndAtomics</code></td>
<td>是否支持片段着色器中的存储和原子操作。</td>
<td>如果启用，片段着色器可以使用存储缓冲区和原子操作。</td>
</tr>
<tr>
<td><code>shaderTessellationAndGeometryPointSize</code></td>
<td>是否支持在曲面细分和几何着色器中设置点大小。</td>
<td>如果启用，曲面细分和几何着色器可以设置点的大小。</td>
</tr>
<tr>
<td><code>shaderImageGatherExtended</code></td>
<td>是否支持扩展的图像聚集操作。</td>
<td>如果启用，着色器可以使用扩展的图像聚集指令。</td>
</tr>
<tr>
<td><code>shaderStorageImageExtendedFormats</code></td>
<td>是否支持扩展的存储图像格式。</td>
<td>如果启用，存储图像可以使用扩展的格式。</td>
</tr>
<tr>
<td><code>shaderStorageImageMultisample</code></td>
<td>是否支持多采样的存储图像。</td>
<td>如果启用，存储图像可以支持多采样。</td>
</tr>
<tr>
<td><code>shaderStorageImageReadWithoutFormat</code></td>
<td>是否支持无格式的存储图像读取。</td>
<td>如果启用，存储图像可以在不指定格式的情况下读取。</td>
</tr>
<tr>
<td><code>shaderStorageImageWriteWithoutFormat</code></td>
<td>是否支持无格式的存储图像写入。</td>
<td>如果启用，存储图像可以在不指定格式的情况下写入。</td>
</tr>
<tr>
<td><code>shaderUniformBufferArrayDynamicIndexing</code></td>
<td>是否支持动态索引的统一缓冲区数组。</td>
<td>如果启用，着色器可以动态索引统一缓冲区数组。</td>
</tr>
<tr>
<td><code>shaderSampledImageArrayDynamicIndexing</code></td>
<td>是否支持动态索引的采样图像数组。</td>
<td>如果启用，着色器可以动态索引采样图像数组。</td>
</tr>
<tr>
<td><code>shaderStorageBufferArrayDynamicIndexing</code></td>
<td>是否支持动态索引的存储缓冲区数组。</td>
<td>如果启用，着色器可以动态索引存储缓冲区数组。</td>
</tr>
<tr>
<td><code>shaderStorageImageArrayDynamicIndexing</code></td>
<td>是否支持动态索引的存储图像数组。</td>
<td>如果启用，着色器可以动态索引存储图像数组。</td>
</tr>
<tr>
<td><code>shaderClipDistance</code></td>
<td>是否支持裁剪距离。</td>
<td>如果启用，着色器可以计算裁剪距离。</td>
</tr>
<tr>
<td><code>shaderCullDistance</code></td>
<td>是否支持剔除距离。</td>
<td>如果启用，着色器可以计算剔除距离。</td>
</tr>
<tr>
<td><code>shaderFloat64</code></td>
<td>是否支持 64 位浮点数。</td>
<td>如果启用，着色器可以使用 64 位浮点数。</td>
</tr>
<tr>
<td><code>shaderInt64</code></td>
<td>是否支持 64 位整数。</td>
<td>如果启用，着色器可以使用 64 位整数。</td>
</tr>
<tr>
<td><code>shaderInt16</code></td>
<td>是否支持 16 位整数。</td>
<td>如果启用，着色器可以使用 16 位整数。</td>
</tr>
<tr>
<td><code>shaderResourceResidency</code></td>
<td>是否支持资源常驻性查询。</td>
<td>如果启用，着色器可以查询资源的常驻性。</td>
</tr>
<tr>
<td><code>shaderResourceMinLod</code></td>
<td>是否支持资源的最小 LOD（Level of Detail）。</td>
<td>如果启用，着色器可以设置资源的最小 LOD。</td>
</tr>
<tr>
<td><code>sparseBinding</code></td>
<td>是否支持稀疏绑定。</td>
<td>如果启用，可以动态绑定内存到稀疏资源（如稀疏纹理或缓冲区）。</td>
</tr>
<tr>
<td><code>sparseResidencyBuffer</code></td>
<td>是否支持稀疏缓冲区的常驻性。</td>
<td>如果启用，稀疏缓冲区可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidencyImage2D</code></td>
<td>是否支持 2D 稀疏图像的常驻性。</td>
<td>如果启用，2D 稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidencyImage3D</code></td>
<td>是否支持 3D 稀疏图像的常驻性。</td>
<td>如果启用，3D 稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidency2Samples</code></td>
<td>是否支持 2 倍采样的稀疏图像常驻性。</td>
<td>如果启用，2 倍采样的稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidency4Samples</code></td>
<td>是否支持 4 倍采样的稀疏图像常驻性。</td>
<td>如果启用，4 倍采样的稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidency8Samples</code></td>
<td>是否支持 8 倍采样的稀疏图像常驻性。</td>
<td>如果启用，8 倍采样的稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidency16Samples</code></td>
<td>是否支持 16 倍采样的稀疏图像常驻性。</td>
<td>如果启用，16 倍采样的稀疏图像可以部分常驻。</td>
</tr>
<tr>
<td><code>sparseResidencyAliased</code></td>
<td>是否支持稀疏资源的别名绑定。</td>
<td>如果启用，稀疏资源可以绑定到多个内存区域。</td>
</tr>
<tr>
<td><code>variableMultisampleRate</code></td>
<td>是否支持可变的多采样率。</td>
<td>如果启用，可以为不同的渲染目标设置不同的多采样率。</td>
</tr>
<tr>
<td><code>inheritedQueries</code></td>
<td>是否支持继承查询。</td>
<td>如果启用，可以在次级命令缓冲区中继承查询。</td>
</tr>
</tbody></table>
<p>这里暂时不启用物理设备特性信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Physical device characteristic information used by logical devices */</span></span><br><span class="line">    VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="逻辑设备描述信息"><a href="#逻辑设备描述信息" class="headerlink" title="逻辑设备描述信息"></a>逻辑设备描述信息</h2><p>通过结构体 <code>VkDeviceCreateInfo</code> 来描述一个物理设备，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDeviceCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                        pNext;</span><br><span class="line">    VkDeviceCreateFlags                flags;</span><br><span class="line">    <span class="type">uint32_t</span>                           queueCreateInfoCount;</span><br><span class="line">    <span class="type">const</span> VkDeviceQueueCreateInfo*     pQueueCreateInfos;</span><br><span class="line">    <span class="comment">// enabledLayerCount is deprecated and should not be used</span></span><br><span class="line">    <span class="type">uint32_t</span>                           enabledLayerCount;</span><br><span class="line">    <span class="comment">// ppEnabledLayerNames is deprecated and should not be used</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*                 ppEnabledLayerNames;</span><br><span class="line">    <span class="type">uint32_t</span>                           enabledExtensionCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*                 ppEnabledExtensionNames;</span><br><span class="line">    <span class="type">const</span> VkPhysicalDeviceFeatures*    pEnabledFeatures;</span><br><span class="line">&#125; VkDeviceCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</code>，以表明这是一个 <strong>设备创建信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展信息的指针，如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>逻辑设备创建时的附加标志</td>
<td>目前没有任何标志定义，应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>queueCreateInfoCount</td>
<td>指定队列创建信息的数量</td>
<td>应用程序希望创建的队列数量。</td>
</tr>
<tr>
<td>pQueueCreateInfos</td>
<td>队列创建信息数组</td>
<td>指向一个或多个 <code>VkDeviceQueueCreateInfo</code> 结构体的数组，每个结构体描述一个队列及其相关配置。</td>
</tr>
<tr>
<td>enabledLayerCount</td>
<td>启用的设备层数量</td>
<td>设备层已被废弃，应设置为 <code>0</code>。如果需要兼容旧的 Vulkan 实现，该参数应该被设置为验证层名称数组的大小。</td>
</tr>
<tr>
<td>ppEnabledLayerNames</td>
<td>启用的设备层名称数组</td>
<td>设备层已被废弃，应设置为 <code>nullptr</code>。如果需要兼容旧的 Vulkan 实现，该参数应该被设置为验证层名称数组。</td>
</tr>
<tr>
<td>enabledExtensionCount</td>
<td>启用的设备扩展数量</td>
<td>指定要启用的设备扩展的数量。</td>
</tr>
<tr>
<td>ppEnabledExtensionNames</td>
<td>启用的设备扩展名称数组</td>
<td>指向一个字符串数组，数组中的每个字符串是一个设备扩展的名称。</td>
</tr>
<tr>
<td>pEnabledFeatures</td>
<td>物理设备特性指针</td>
<td>指向 <code>VkPhysicalDeviceFeatures</code> 结构体，用于启用设备特性。如果只启用默认特性，可以设置为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Logical device creation information */</span></span><br><span class="line">	VkDeviceCreateInfo createInfo&#123;&#125;;</span><br><span class="line">	createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;</span><br><span class="line">	createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	createInfo.flags = <span class="number">0</span>;</span><br><span class="line">	createInfo.queueCreateInfoCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(queueCreateInfos.<span class="built_in">size</span>());</span><br><span class="line">	createInfo.pQueueCreateInfos = queueCreateInfos.<span class="built_in">data</span>();</span><br><span class="line">	<span class="keyword">auto</span> extension = <span class="built_in">getRequiredDeviceExtensions</span>();</span><br><span class="line">	createInfo.enabledExtensionCount = extension.<span class="built_in">size</span>();</span><br><span class="line">	createInfo.ppEnabledExtensionNames = extension.<span class="built_in">data</span>();</span><br><span class="line">	createInfo.pEnabledFeatures = &amp;deviceFeatures;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> validationLayers = <span class="built_in">getRequiredValidationLayers</span>();</span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        createInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">        createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">        createInfo.ppEnabledLayerNames = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建逻辑设备"><a href="#创建逻辑设备" class="headerlink" title="创建逻辑设备"></a>创建逻辑设备</h2><p>通过函数 <code>vkCreateDevice</code>来创建一个逻辑设备，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDeviceCreateInfo*                   pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice*                                   pDevice)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定逻辑设备要基于的物理设备（<code>VkPhysicalDevice</code>）。通过物理设备枚举（<code>vkEnumeratePhysicalDevices</code>）获得。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>逻辑设备创建信息指针</td>
<td>指向一个 <code>VkDeviceCreateInfo</code> 结构体的指针，包含了逻辑设备的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pDevice</td>
<td>逻辑设备句柄指针</td>
<td>指向 <code>VkDevice</code> 变量的指针，存储创建的逻辑设备句柄。函数执行成功后，该变量将持有新创建的逻辑设备对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示逻辑设备是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示逻辑设备创建成功。其他错误码表示创建失败。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Creating a Logical Device */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateDevice</span>(<span class="keyword">this</span>-&gt;physicalDevice, &amp;createInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;device) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create logical device!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 中，在物理设备选择之后调用函数 <code>createLogicalDevice</code> 来创建逻辑设备：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">choosePhysicalDevice</span>();</span><br><span class="line">    <span class="built_in">createLogicalDevice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理逻辑设备"><a href="#清理逻辑设备" class="headerlink" title="清理逻辑设备"></a>清理逻辑设备</h2><p>在 <code>clear</code> 中清理逻辑设备，逻辑设备需要通过函数 <code>vkDestroyDevice</code> 来销毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要销毁的逻辑设备句柄。在销毁逻辑设备之前，应确保与其关联的所有 Vulkan 对象（如队列、命令缓冲区、图像、缓冲区等）已经释放，或者会被销毁时自动清理。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建逻辑设备时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>逻辑设备的销毁应当在实例销毁之前进行：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkDestroyDevice</span>(<span class="keyword">this</span>-&gt;device, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyInstance</span>(<span class="keyword">this</span>-&gt;instance, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="获取队列句柄"><a href="#获取队列句柄" class="headerlink" title="获取队列句柄"></a>获取队列句柄</h2><p>队列会在逻辑设备创建之后自动创建，现在需要从逻辑设备中获取队列句柄，首先添加 <code>VkQueue</code> 类型的成员变量：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkQueue graphicsQueue;</span><br><span class="line">    VkQueue transferQueue;</span><br><span class="line">    VkQueue presentQueue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后，调用函数 <code>vkGetDeviceQueue</code>，来从设备中获取句柄，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetDeviceQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    queueFamilyIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    queueIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue*                                    pQueue)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定获取队列句柄的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>queueFamilyIndex</td>
<td>队列族索引</td>
<td>指定从哪个队列族中获取队列。</td>
</tr>
<tr>
<td>输入参数</td>
<td>queueIndex</td>
<td>队列索引</td>
<td>一个队列族中可能有多个队列，你可以通过索引选择具体的队列。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pQueue</td>
<td>队列句柄指针</td>
<td>指向 <code>VkQueue</code> 变量的指针，存储创建的队列句柄。函数执行成功后，该变量将持有新创建的队列对象。</td>
</tr>
</tbody></table>
<p>在逻辑设备创建完成之后，就可以获取队列句柄：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get Queues */</span></span><br><span class="line">	<span class="built_in">vkGetDeviceQueue</span>(<span class="keyword">this</span>-&gt;device, <span class="keyword">this</span>-&gt;graphicsFamily, <span class="number">0</span>, &amp;<span class="keyword">this</span>-&gt;graphicsQueue);</span><br><span class="line">    <span class="built_in">vkGetDeviceQueue</span>(<span class="keyword">this</span>-&gt;device, <span class="keyword">this</span>-&gt;transferFamily, <span class="number">0</span>, &amp;<span class="keyword">this</span>-&gt;transferQueue);</span><br><span class="line">    <span class="built_in">vkGetDeviceQueue</span>(<span class="keyword">this</span>-&gt;device, <span class="keyword">this</span>-&gt;presentFamily, <span class="number">0</span>, &amp;<span class="keyword">this</span>-&gt;presentQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="窗口表面"><a href="#窗口表面" class="headerlink" title="窗口表面"></a>窗口表面</h1><p>Vulkan 是一个跨平台的 API，其本身无法与窗口系统直接交互。为了能够呈现渲染结果，需要使用 <strong>WSI扩展</strong>（Window System Integration，窗口系统集成）。如果不需要展现渲染结果，可以直接使用 Vulkan 进行离屏渲染。</p>
<p>常用的 WSI 扩展为 <code>VK_KHR_surface</code>，该扩展提供了一个抽象表面类型 <code>VkSurfaceKHR</code> 用来呈现渲染之后的图像。<code>VK_KHR_surface</code> 是一个实例级别的扩展。在类中添加 <code>VkSurfaceKHR</code> 成员来存储窗口表面对象：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkSurfaceKHR surface;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createSurface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="窗口表面的创建"><a href="#窗口表面的创建" class="headerlink" title="窗口表面的创建"></a>窗口表面的创建</h2><p>由于 GLFW 本身是一个跨平台的库，其封装了不同平台的窗口创建逻辑，直接调用即可完成跨平台的窗口创建。</p>
<p>通过调用函数 <code>glfwCreateWindowSurface</code> 即可完成窗口的创建，其定义如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">glfwCreateWindowSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    GLFWwindow* window,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks* allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR* surface</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>instance</td>
<td>Vulkan 实例</td>
<td>表示创建窗口表面所关联的 Vulkan 实例。</td>
</tr>
<tr>
<td>输入参数</td>
<td>window</td>
<td>GLFW 窗口对象</td>
<td>需要创建窗口表面的GLFW 窗口对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>allocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>surface</td>
<td>用于存储创建的 Vulkan 窗口表面句柄。</td>
<td>成功调用后，该参数将指向一个有效的 <code>VkSurfaceKHR</code> 对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示窗口表面是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示窗口创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createSurface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwCreateWindowSurface</span>(<span class="keyword">this</span>-&gt;instance, <span class="keyword">this</span>-&gt;window, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;surface) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create window surface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：调用此函数前需要确保 Vulkan 实例已启用 <code>VK_KHR_surface</code> 扩展。</p>
</blockquote>
<p>在 <code>init</code> 中，调用函数 <code>createSurface</code> 来创建窗口表面，窗口表面需要在实例创建之后立即创建，因为它实际上可能会影响物理设备的选择：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">createSurface</span>();</span><br><span class="line">    <span class="built_in">choosePhysicalDevice</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="窗口表面的销毁"><a href="#窗口表面的销毁" class="headerlink" title="窗口表面的销毁"></a>窗口表面的销毁</h2><p>创建的 <code>VkSurfaceKHR</code> 对象在不再需要时，应使用 <code>vkDestroySurfaceKHR</code> 销毁，其定义如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroySurfaceKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR surface,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks* pAllocator</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>instance</td>
<td>Vulkan 实例</td>
<td>指定与要销毁的表面关联的 Vulkan 实例。</td>
</tr>
<tr>
<td>输入参数</td>
<td>surface</td>
<td>要销毁的窗口表面对象</td>
<td>表示需要释放的 Vulkan 表面资源。</td>
</tr>
<tr>
<td>输入参数</td>
<td>allocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建窗口表面时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>销毁表面对象 <code>VkSurfaceKHR</code> 应该在销毁 Vulkan 实例 <code>VkInstance</code> 之前进行：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ..</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkDestroySurfaceKHR</span>(<span class="keyword">this</span>-&gt;instance, <span class="keyword">this</span>-&gt;surface, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyInstance</span>(<span class="keyword">this</span>-&gt;instance, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区</title>
    <url>/2025/03/20/Vulkan/3.%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过类 <code>BufferManager</code> 来实现缓冲区管理，添加 <code>ContentManagerSPtr</code> 成员对象来获取核心上下文，添加 <code>CommandManagerSPtr</code> 成员对象来进行一些缓冲区操作 。此处的 <code>init</code> 和 <code>clear</code> 是纯虚函数，以便在强制在子类中实现初始化和清理方法：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">BufferManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager);</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ContentManagerSPtr pContentManager;</span><br><span class="line">    CommandManagerSPtr pCommandManager;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;BufferManager&gt; BufferManagerSPtr;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;buffer_manager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BufferManager::<span class="built_in">BufferManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, </span><br><span class="line">                             <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pCommandManager = pCommandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h1><p>此处实现一个缓冲区创建辅助函数，其接收 <strong>缓冲区大小</strong>、<strong>缓冲区用途</strong>、<strong>绑定的内存属性</strong> 作为参数，创建对应的 <strong>缓冲区</strong> 和 <strong>缓冲区内存</strong>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                  VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                  VkDeviceMemory&amp; bufferMemory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VkBuffer buffer;</span><br><span class="line">	VkDeviceMemory bufferMemory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置缓冲区"><a href="#配置缓冲区" class="headerlink" title="配置缓冲区"></a>配置缓冲区</h2><p>在 Vulkan 中，缓冲区的创建需要首先填充结构体 <code>VkBufferCreateInfo</code>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*            pNext;</span><br><span class="line">    VkBufferCreateFlags    flags;</span><br><span class="line">    VkDeviceSize           size;</span><br><span class="line">    VkBufferUsageFlags     usage;</span><br><span class="line">    VkSharingMode          sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>               queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*        pQueueFamilyIndices;</span><br><span class="line">&#125; VkBufferCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</code>，以表明这是一个 <strong>缓冲区创建信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展信息的指针，如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td></td>
<td>缓冲区的创建标志，默认值为 <code>0</code>，可以是 <code>VkBufferCreateFlagBits</code> 枚举类型的组合，可选值包括：<br /><code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code>：稀疏绑定的缓冲区，物理内存可以不连续。<br /><code>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</code>：稀疏驻留的缓冲区，部分缓冲区可以没有物理内存绑定。<br /><code>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</code>：允许多个稀疏缓冲区共享相同的物理内存。<br /><code>VK_BUFFER_CREATE_PROTECTED_BIT</code>：允许缓冲区使用受保护内存，确保 GPU 端的数据安全，不可被非受保护的操作访问。<br /><code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT</code>：允许缓冲区支持设备地址的捕获和回放，在不同的 Vulkan 运行实例之间保持一致，用于调试和重现。<br /><code>VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT</code>：<code>EXT</code> 扩展，允许缓冲区支持描述符缓冲区的捕获和回放，用于调试和重现。<br /><code>VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR</code>：<code>KHR</code> 扩展，允许缓冲区在 多个视频解码配置之间通用使用<br /><code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT</code>：<code>EXT</code> 扩展别名，与 <code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT</code> 一致。<br /><code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR</code>：<code>KHR</code> 扩展别名，与 <code>VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT</code> 一致。</td>
</tr>
<tr>
<td>size</td>
<td>缓冲区的大小</td>
<td>缓冲区的大小（以字节为单位）。定义了缓冲区所需的内存大小。</td>
</tr>
<tr>
<td>usage</td>
<td>缓冲区的用途标志</td>
<td>缓冲区的用途标志，默认值为 <code>0</code>，可以是 <code>VkBufferUsageFlagBits</code> 枚举类型的组合，可选值包括：<br /><code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>：该缓冲区可用作数据传输的源（拷贝到另一个缓冲区或图像）。<br/><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>：该缓冲区可用作数据传输的目标（从另一个缓冲区或图像拷贝数据到该缓冲区）。<br/><code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code>：该缓冲区可以作为纹理缓冲区。<br/><code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code>：该缓冲区可以作为存储纹理缓冲区，支持在着色器中进行读取和写入。<br/><code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code>：该缓冲区可以作为统一缓冲区。<br/><code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code>：该缓冲区可以作为 存储缓冲区用于 GPU 计算或图形渲染时读写大块数据。<br/><code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code>：该缓冲区可作为索引缓冲区。<br/><code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code>：该缓冲区可作为顶点缓冲区。<br/><code>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</code>：该缓冲区可作为间接绘制缓冲区。<br/><code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code>：允许该缓冲区支持 着色器设备地址，用于 GPU 指针操作，如加速结构访问。<br/><code>VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR</code>：该缓冲区可用于视频解码的输入源。<br/><code>VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR</code>：该缓冲区可用于视频解码的输出目标。<br/><code>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT</code>：该缓冲区可用于变换反馈，用于存储经过顶点着色器处理后的顶点数据。<br/><code>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT</code>：该缓冲区用于存储变换反馈的计数器。<br/><code>VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT</code>：该缓冲区可用于 条件渲染，用于基于 GPU 计算的结果决定是否执行渲染操作。<br/><code>VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX</code>：该缓冲区用于 AMDX 执行图的 Scratch 数据存储。<br/><code>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</code>：该缓冲区用于光线追踪加速结构的构建输入。<br/><code>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</code>：该缓冲区可用于存储光线追踪加速结构。<br/><code>VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</code>：该缓冲区用于光线追踪着色器绑定表。<br/><code>VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR</code>：该缓冲区可作为视频编码的目标。<br/><code>VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR</code>：该缓冲区可作为视频编码的输入源。<br/><code>VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT</code>：允许该缓冲区作为采样器描述符缓冲区。<br/><code>VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT</code>：允许该缓冲区作为资源描述符缓冲区。<br/><code>VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT</code>：允许该缓冲区用于 Push Descriptors。<br/><code>VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT</code>：允许该缓冲区作为 Micromap 构建输入。<br/><code>VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT</code>：允许该缓冲区用于 存储 Micromap。<br/><code>VK_BUFFER_USAGE_RAY_TRACING_BIT_NV</code>：<code>VK_NV_ray_tracing</code> 扩展别名，与 <code>VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</code> 相同。<br/><code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT</code>：<code>EXT</code> 扩展别名，与 <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> 相同。<br/><code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR</code>：<code>KHR</code> 扩展别名，与 <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> 相同。</td>
</tr>
<tr>
<td>sharingMode</td>
<td>缓冲区的共享模式</td>
<td>缓冲区的共享模式，默认值为 <code>0</code>，指定该缓冲区将如何被多个队列族使用，可选值包括：<br /><code>VK_SHARING_MODE_EXCLUSIVE</code>：缓冲区只由一个队列族访问，默认值。<br /><code>VK_SHARING_MODE_CONCURRENT</code>：缓冲区可以由多个队列族同时访问。</td>
</tr>
<tr>
<td>queueFamilyIndexCount</td>
<td>队列族索引数组大小</td>
<td>队列族索引的数量，仅在 <code>sharingMode</code> 为 <code>VK_SHARING_MODE_CONCURRENT</code> 时使用。<br />在其他模式下应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>pQueueFamilyIndices</td>
<td>队列族索引数组指针</td>
<td>队列族索引的数组，仅在 <code>sharingMode</code> 为 <code>VK_SHARING_MODE_CONCURRENT</code> 时使用。<br />在其他模式下应设置为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                  VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                  VkDeviceMemory&amp; bufferMemory)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo&#123;&#125;;</span><br><span class="line">	bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</span><br><span class="line">	bufferInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	bufferInfo.flags = <span class="number">0</span>;</span><br><span class="line">	bufferInfo.size = size;</span><br><span class="line">	bufferInfo.usage = usage;</span><br><span class="line">	bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">	bufferInfo.queueFamilyIndexCount = <span class="number">0</span>;</span><br><span class="line">	bufferInfo.pQueueFamilyIndices = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建缓冲区-1"><a href="#创建缓冲区-1" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h2><p>调用函数 <code>vkCreateBuffer</code> 来完成缓冲区的建立，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCreateInfo*                   pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer*                                   pBuffer)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上创建缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>缓冲区创建信息指针</td>
<td>指向 <code>VkBufferCreateInfo</code> 结构体的指针，该结构体定义了缓冲区的创建参数。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果传入 <code>nullptr</code>，则使用默认的内存分配机制。如果应用程序需要对内存分配和释放进行控制，可实现自定义分配器并通过此参数传递。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pBuffer</td>
<td>缓冲区指针</td>
<td>指向 <code>VkBuffer</code> 变量的指针，用于接收创建的缓冲区句柄，存储 Vulkan 创建的缓冲区对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示缓冲区创建是否成功</td>
<td><code>VK_SUCCESS</code>：表示缓冲区创建成功。  其他错误代码：表示创建失败，具体原因可能包括内存不足或者地址无效。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateBuffer</span>(pContentManager-&gt;device, &amp;bufferInfo, <span class="literal">nullptr</span>, &amp;buffer) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create buffer!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：缓冲区创建之后不会自动分配内存。<code>VkBuffer</code> 是一个逻辑对象，定义了缓冲区的属性和用途（如大小、用途标志等）。<code>VkDeviceMemory</code> 是实际的物理内存，用于存储缓冲区的数据。为了使用缓冲区，必须将 <code>VkBuffer</code> 绑定到 <code>VkDeviceMemory</code> 上。这种设计使得 Vulkan 能够灵活地管理内存，并支持多种内存分配策略。</p>
<h2 id="内存需求"><a href="#内存需求" class="headerlink" title="内存需求"></a>内存需求</h2><p>缓冲区创建之后，需要为其进行内存分配，在这之前需要先查询内存需求，通过调用函数 <code>vkGetBufferMemoryRequirements</code>来进行查询，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetBufferMemoryRequirements</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryRequirements*                       pMemoryRequirements)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要查询缓冲区的内存需求的 Vulkan 设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>buffer</td>
<td>缓冲区句柄</td>
<td>需要查询内存需求的缓冲区对象</td>
</tr>
<tr>
<td>输出参数</td>
<td>pMemoryRequirements</td>
<td>内存需求指针</td>
<td>指向 <code>VkMemoryRequirements</code> 结构体的指针，函数调用后，该结构体会被填充相关的内存需求信息，包括：<br /><code>size</code>：所需内存大小（以字节为单位），可能与 <code>bufferInfo.size</code> 不同<br /><code>alignment</code>：缓冲区在分配的内存区域中的起始偏移量（以字节为单位），取决于 <code>bufferInfo.usage</code> 和 <code>bufferInfo.flags</code>。<br /><code>memoryTypeBits</code>：适用于该缓冲区的内存类型位掩码。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">	<span class="built_in">vkGetBufferMemoryRequirements</span>(pContentManager-&gt;device, buffer, &amp;memRequirements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择内存类型"><a href="#选择内存类型" class="headerlink" title="选择内存类型"></a>选择内存类型</h2><p>显卡通常提供不同类型的显存，每种显存在允许的操作和性能特性方面可能有所不同。我们需要结合缓冲区的要求和应用程序的需求来选择合适的显存类型，需要通过函数 <code>vkGetPhysicalDeviceMemoryProperties</code> 来查询显卡提供的可用显存类型信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetPhysicalDeviceMemoryProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDeviceMemoryProperties*           pMemoryProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要查询缓冲区的内存需求的 Vulkan 设备。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pMemoryProperties</td>
<td>物理设备的内存属性信息指针</td>
<td>指向 <code>VkPhysicalDeviceMemoryProperties</code> 结构体的指针，调用后，该结构体会被填充物理设备的内存属性信息，包括：<br /><code>memoryTypeCount</code>：可用的内存类型数量。<br /><code>memoryTypes</code>：一个 <code>VkMemoryType</code> 数组，描述不同的内存类型。<br /><code>memoryHeapCount</code>：可用的内存堆数量。<br /><code>memoryHeaps</code>：一个 <code>VkMemoryHeap</code> 数组，描述不同的内存堆。</td>
</tr>
</tbody></table>
<p><code>VkMemoryHeap</code> 结构体描述了 Vulkan 物理设备（GPU）提供的内存堆的相关信息。其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryHeap</span> &#123;</span><br><span class="line">    VkDeviceSize         size;</span><br><span class="line">    VkMemoryHeapFlags    flags;</span><br><span class="line">&#125; VkMemoryHeap;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>size</td>
<td>内存堆的大小</td>
<td>这个值表示该内存堆可以提供的最大内存量。例如，一个 8GB 的 VRAM 可能对应 <code>size = 8 * 1024 * 1024 * 1024</code>。但并不意味着所有这部分内存都可以分配给 Vulkan 使用，部分可能被操作系统或驱动程序占用。</td>
</tr>
<tr>
<td>flags</td>
<td>内存堆的标志位</td>
<td>指示了内存堆的特性，可能的值包括：<br /><code>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code>：该内存堆位于设备本地（通常指 GPU 专用的 VRAM）。如果没有设置该标志，则表示该内存堆可能是共享的（例如，集成显卡使用的系统 RAM）<br /><code>VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</code>：多 GPU 配置中的多实例内存。<br /><code>VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR</code>：<code>KHR</code> 扩展别名，与 <code>VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</code> 相同。</td>
</tr>
</tbody></table>
<p><code>VkMemoryType</code> 结构体描述了 Vulkan 物理设备（GPU）提供的内存类型特性，它决定了如何访问特定的内存堆，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryType</span> &#123;</span><br><span class="line">    VkMemoryPropertyFlags    propertyFlags;</span><br><span class="line">    <span class="type">uint32_t</span>                 heapIndex;</span><br><span class="line">&#125; VkMemoryType;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>propertyFlags</td>
<td>内存属性的标志位</td>
<td>指示了该内存的访问模式和特性，可以组合多个标志，可能的值包括：<br /><code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>：该内存是设备本地的，通常指 GPU VRAM（显存）。访问速度快，适合存放经常使用的图形数据（如顶点缓冲、纹理等）。<br/><code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>：该内存对主机（CPU）可见，可以通过 <code>vkMapMemory</code> 访问。适合存放 CPU 需要修改的数据，如动态更新的顶点缓冲区。<br/><code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>：主机一致性（Coherent），即 CPU 写入数据后，GPU 可以直接读取，无需手动 <code>vkFlushMappedMemoryRanges</code>。适合小型数据传输，但写入性能可能较低。<br/><code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>：该内存支持 CPU 缓存，适用于频繁读取的数据，如只读缓冲（Read-Only Buffers）。但可能需要 <code>vkInvalidateMappedMemoryRanges</code> 以保证 CPU 读取最新的 GPU 数据。<br/><code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>：该内存懒分配，通常用于纹理或帧缓冲（Framebuffer）。只在真正需要时才分配实际物理内存，适合离屏渲染（Offscreen Rendering）。<br/><code>VK_MEMORY_PROPERTY_PROTECTED_BIT</code>：该内存受保护（Protected），不能被 CPU 直接访问，仅适用于保护内容的场景（如 DRM）。（Vulkan 1.1+）<br/><code>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD</code> &#x2F; <code>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD</code>：AMD GPU 的特殊内存属性，控制 GPU 访问一致性。（AMD 专有）<br /><code>VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV</code>：允许远程设备（如其他 GPU 或网络设备） 直接访问该内存，而无需经过 CPU 处理，从而减少延迟、提升数据传输效率，比如 GPU 直连存储。NVIDIA 在 Vulkan 1.3.236 版本中引入的扩展内存属性。</td>
</tr>
<tr>
<td>heapIndex</td>
<td>内存堆索引</td>
<td>指定该内存类型所属的内存堆索引。<br />物理设备的 <code>VkPhysicalDeviceMemoryProperties</code> 结构体中有 <code>memoryHeaps</code> 数组，每个 <code>VkMemoryType</code> 都映射到其中的一个 <code>heapIndex</code>。</td>
</tr>
</tbody></table>
<p><code>VkMemoryRequirements.memoryTypeBits</code> 是一个 位掩码（bitmask），用于指示该缓冲区（<code>VkBuffer</code>）或图像（<code>VkImage</code>）可以使用哪些内存类型。</p>
<ul>
<li>它的每一位对应 <code>VkPhysicalDeviceMemoryProperties.memoryTypes</code> 数组中的一个内存类型索引。</li>
<li>如果 <code>memoryTypeBits</code> 的 第 <code>i</code> 位 为 <code>1</code>，表示 该资源（Buffer &#x2F; Image）可以使用 <code>memoryTypes[i]</code>。</li>
<li>需要通过 <code>memoryTypeBits</code> 结合应用需求，在 <code>VkPhysicalDeviceMemoryProperties::memoryTypes</code> 中选择合适的内存类型。</li>
</ul>
<p>一个辅助函数的实现示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">findMemoryType</span><span class="params">(<span class="type">uint32_t</span> typeFilter, VkMemoryPropertyFlags properties)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">BufferManager::findMemoryType</span><span class="params">(<span class="type">uint32_t</span> typeFilter, VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkPhysicalDeviceMemoryProperties memoryProperties;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceMemoryProperties</span>(pContentManager-&gt;physicalDevice, &amp;memoryProperties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; memoryProperties.memoryTypeCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((typeFilter &amp; (<span class="number">1</span> &lt;&lt; i)) &amp;&amp; (memoryProperties.memoryTypes[i].propertyFlags &amp; properties) == properties)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to find suitable memory type!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置内存"><a href="#配置内存" class="headerlink" title="配置内存"></a>配置内存</h2><p>在完成了合适的内存类型的确定之后，就可以进行内存的申请。首先，需要填充结构体 <code>VkMemoryAllocateInfo</code>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    VkDeviceSize       allocationSize;</span><br><span class="line">    <span class="type">uint32_t</span>           memoryTypeIndex;</span><br><span class="line">&#125; VkMemoryAllocateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</code>，以表明这是一个内存申请信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>allocationSize</td>
<td>申请的内存大小</td>
<td>需要分配的内存的大小（以字节为单位）。此大小应大于或等于所有分配的资源大小的总和。</td>
</tr>
<tr>
<td>memoryTypeIndex</td>
<td>内存类型的索引</td>
<td>这个索引来自于 <code>VkPhysicalDeviceMemoryProperties</code> 结构中的 <code>memoryTypes</code> 数组，它告诉 Vulkan 使用哪种类型的物理设备内存。通常通过查询设备的内存类型来获取这个索引。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VkMemoryAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">	allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">	allocInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">	allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>然后，通过调用函数 <code>vkAllocateMemory</code> 来完成内存的分配，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult VKAPI_CALL <span class="title">vkAllocateMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryAllocateInfo*                 pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory*                             pMemory)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上进行内存分配。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocateInfo</td>
<td>内存分配信息指针</td>
<td>指向 <code>VkMemoryAllocateInfo</code> 结构的指针，该结构包含了分配内存所需要的所有信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果传入 <code>nullptr</code>，则使用默认的内存分配机制。如果应用程序需要对内存分配和释放进行控制，可实现自定义分配器并通过此参数传递。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pMemory</td>
<td>设备内存对象指针</td>
<td>指向 <code>VkDeviceMemory</code> 的指针。函数执行成功后，这个指针将会指向分配的设备内存对象。你可以使用这个内存对象与缓冲区、图像等资源绑定。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示内存分配是否成功</td>
<td><code>VK_SUCCESS</code>：表示内存分配成功。  其他错误代码：表示分配失败，具体原因可能包括内存不足。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(pContentManager-&gt;device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate buffer memory!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要注意，在实际应用程序中，不应为每个单独的缓冲区调用 <code>vkAllocateMemory</code>。物理设备对<strong>最大同时分配的内存块数</strong>有限制，由 <code>maxMemoryAllocationCount</code> 限定。正确的做法是创建自定义内存分配器，通过偏移量（offset）在单个分配的内存块中拆分多个对象，而不是为每个对象单独分配内存。</p>
<h2 id="绑定缓冲区内存"><a href="#绑定缓冲区内存" class="headerlink" title="绑定缓冲区内存"></a>绑定缓冲区内存</h2><p>最后，通过调用函数  <code>vkBindBufferMemory</code> 来完成缓冲区和缓冲区内存的绑定，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult VKAPI_CALL <span class="title">vkBindBufferMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                memoryOffset)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上进行内存绑定。</td>
</tr>
<tr>
<td>输入参数</td>
<td>buffer</td>
<td>缓冲区句柄</td>
<td>需要绑定内存的缓冲区对象的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memory</td>
<td>设备内存句柄</td>
<td>需要绑定的设备内存对象的句柄，表示要绑定到缓冲区的内存。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memoryOffset</td>
<td>指定绑定内存时的偏移量</td>
<td>通常，对于一个单独的缓冲区，偏移量是 <code>0</code>，表示内存从缓冲区对象的开始位置绑定。如果使用内存的某个子部分时，可以设置为适当的偏移量。此偏移量必须是绑定内存的对齐要求 <code>memRequirements.alignment</code> 的整数倍。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> VkMemoryPropertyFlags properties)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkBindBufferMemory</span>(pContentManager-&gt;device, buffer, bufferMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理缓冲区"><a href="#清理缓冲区" class="headerlink" title="清理缓冲区"></a>清理缓冲区</h2><p>在缓冲区使用完毕之后，需要调用函数 <code>vkDestroyBuffer</code> 来销毁缓冲区以释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁缓冲区的 Vulkan 设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>buffer</td>
<td>缓冲区句柄</td>
<td>指定需要销毁的缓冲区对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建窗口表面时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h2 id="清理内存"><a href="#清理内存" class="headerlink" title="清理内存"></a>清理内存</h2><p>在完成缓冲区内存的使用时候，需要调用函数 <code>vkFreeMemory</code> 来完成内存的释放，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkFreeMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上进行内存释放。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memory</td>
<td>设备内存句柄</td>
<td>指定要释放的设备内存对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建窗口表面时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h1 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h1><p>执行缓冲区复制命令需要一个支持传输操作（transfer operations）的队列族。队列族的能力由 <code>queueFlags</code> 指定，其中 <code>VK_QUEUE_TRANSFER_BIT</code> 表示该队列族支持传输操作。通常支持 <code>VK_QUEUE_GRAPHICS_BIT</code> 或 <code>VK_QUEUE_COMPUTE_BIT</code> 的队列族也隐式支持 <code>VK_QUEUE_TRANSFER_BIT</code>，所以执行传输操作可以复用图形队列。此处为了最佳性能，已经事先准备了传输队列。</p>
<p>在 Vulkan 中，内存传输操作需要使用命令来执行。此处实现一个辅助函数来实现缓冲区的拷贝：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyBuffer</span><span class="params">(<span class="type">const</span> VkBuffer&amp; srcBuffer, VkBuffer&amp; dstBuffer, <span class="type">const</span> VkDeviceSize size)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>首先，使用命令管理器中的开始传输命令记录函数 <code>beginTransferCommands</code> 来获取一个临时的命令缓冲区。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::copyBuffer</span><span class="params">(<span class="type">const</span> VkBuffer&amp; srcBuffer, VkBuffer&amp; dstBuffer, <span class="type">const</span> VkDeviceSize size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后调用函数 <code>vkCmdCopyBuffer</code> 来记录一个缓冲区拷贝命令，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> VKAPI_CALL <span class="title">vkCmdCopyBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    dstBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCopy*                         pRegions)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定要记录此命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>srcBuffer</td>
<td>源缓冲区句柄</td>
<td>数据拷贝的来源。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dstBuffer</td>
<td>目标缓冲区句柄</td>
<td>数据拷贝的目的地。</td>
</tr>
<tr>
<td>输入参数</td>
<td>regionCount</td>
<td>区域数量</td>
<td>需要拷贝的区域数，即 <code>pRegions</code> 数组的大小。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pRegions</td>
<td>拷贝区域数组</td>
<td>指向一个或多个 <code>VkBufferCopy</code> 结构体的数组，每个结构体定义了一个拷贝区域：<br /><code>srcOffset</code>：源缓冲区的偏移量（以字节为单位）<br /><code>dstOffset</code>：目标缓冲区的偏移量（以字节为单位）。<br /><code>size</code>：要拷贝的数据大小，注意不能使用 <code>VK_WHOLE_SIZE</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::copyBuffer</span><span class="params">(<span class="type">const</span> VkBuffer&amp; srcBuffer, VkBuffer&amp; dstBuffer, <span class="type">const</span> VkDeviceSize size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line">    </span><br><span class="line">    VkBufferCopy copyRegion&#123;&#125;;</span><br><span class="line">	copyRegion.srcOffset = <span class="number">0</span>;</span><br><span class="line">	copyRegion.dstOffset = <span class="number">0</span>;</span><br><span class="line">	copyRegion.size = size;</span><br><span class="line">	<span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：<code>srcBuffer</code> 必须 包含 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>，<code>dstBuffer</code> 必须包含 <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code></p>
<p>最后，调用命令管理器中的终止命令记录函数来结束命令录制并提交执行：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::copyBuffer</span><span class="params">(<span class="type">const</span> VkBuffer&amp; srcBuffer, VkBuffer&amp; dstBuffer, <span class="type">const</span> VkDeviceSize size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line">    </span><br><span class="line">    VkBufferCopy copyRegion&#123;&#125;;</span><br><span class="line">	copyRegion.srcOffset = <span class="number">0</span>;</span><br><span class="line">	copyRegion.dstOffset = <span class="number">0</span>;</span><br><span class="line">	copyRegion.size = size;</span><br><span class="line">	<span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line">    </span><br><span class="line">    pCommandManager-&gt;<span class="built_in">endTransferCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="设备本地缓冲区"><a href="#设备本地缓冲区" class="headerlink" title="设备本地缓冲区"></a>设备本地缓冲区</h1><p>对于 GPU 来说，最优的内存类型通常具有 <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> 标志，这种内存通常无法被 CPU 直接访问（尤其是在独立显卡上）。为了实现最佳性能，同时上传数据，需要创建两个缓冲区：</p>
<ol>
<li>暂存缓冲区：位于 CPU 可访问的内存中，用于上传数据。</li>
<li>最终的缓冲区：位于设备本地（device local）的内存中，以提高 GPU 访问速度。</li>
</ol>
<p>此处实现一个辅助函数 <code>createDeviceLocalBuffer</code>，来实现为指定数据创建设备本地缓冲区：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createDeviceLocalBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">								 <span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">								 <span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">								 VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">								 VkDeviceMemory&amp; bufferMemory)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建暂存缓冲区"><a href="#创建暂存缓冲区" class="headerlink" title="创建暂存缓冲区"></a>创建暂存缓冲区</h2><p>首先，像创建普通的缓冲区一样，创建一个临时的暂存缓冲区，由于将会执行从暂存缓冲区到目的缓冲区的拷贝，应该设置其标志为 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>。同时设置内存类型为主机一致性 <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> 和主机可见性 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> 使得可以将数据从主机内存拷贝到缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createDeviceLocalBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkDeviceMemory&amp; bufferMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkBuffer stagingBuffer;</span><br><span class="line">	VkDeviceMemory stagingBufferMemory;</span><br><span class="line">	<span class="built_in">createBuffer</span>(size,</span><br><span class="line">				 VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">				 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">				 stagingBuffer,</span><br><span class="line">				 stagingBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="复制数据到暂存缓冲区"><a href="#复制数据到暂存缓冲区" class="headerlink" title="复制数据到暂存缓冲区"></a>复制数据到暂存缓冲区</h2><p>在这之后，将数据拷贝到暂存缓冲区中。首先，通过函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkMapMemory.html"><code>vkMapMemory</code></a> 将缓冲区内存映射到 CPU 可访问的内存空间，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkMapMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                size,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryMapFlags                            flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>**                                      ppData)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上进行内存映射。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memory</td>
<td>设备内存句柄</td>
<td>指定要映射的设备内存对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>offset</td>
<td>偏移量</td>
<td>以字节为单位的偏移量，指定从 <code>memory</code> 的哪个位置开始映射。<br />必须是 <code>VkPhysicalDeviceLimits::nonCoherentAtomSize</code> 的整数倍（对于 <code>non-coherent</code> 内存）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>size</td>
<td>映射大小</td>
<td>以字节为单位的映射大小，如果设置为 <code>VK_WHOLE_SIZE</code>，表示映射 <code>offset</code> 之后的整个可用内存。</td>
</tr>
<tr>
<td>输入参数</td>
<td>flags</td>
<td></td>
<td>对于该函数目前应设置为 <code>0</code>，其他的值包括：<br /><code>VK_MEMORY_MAP_PLACED_BIT_EXT</code>：该标志位用于 <code>vkMapMemory2EXT</code>，允许应用程序在映射内存时提供特定的 GPU 地址（<code>VkMemoryMapInfoEXT::offset</code>），而不是由 Vulkan 驱动自动决定映射的地址。<br /><code>VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>输出参数</td>
<td>ppData</td>
<td></td>
<td>返回指向映射内存的指针，可以使用 <code>memcpy</code> 直接读写该指针指向的内存区域，该指针仅在 <code>vkUnmapMemory</code> 之前有效，之后访问它会导致未定义行为。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>映射操作是否执行成功</td>
<td></td>
</tr>
</tbody></table>
<p>然后，通过调用函数 <code>memcpy</code> 进行内存拷贝，并通过调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkUnmapMemory.html"><code>vkUnmapMemory</code></a> 来解除映射，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkUnmapMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定在哪个 Vulkan 设备上解除内存映射。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memory</td>
<td>设备内存句柄</td>
<td>指定要解除映射的设备内存对象。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createDeviceLocalBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkDeviceMemory&amp; bufferMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="type">void</span>* tempData;</span><br><span class="line">	<span class="built_in">vkMapMemory</span>(pContentManager-&gt;device, stagingBufferMemory, <span class="number">0</span>, size, <span class="number">0</span>, &amp;tempData);</span><br><span class="line">	<span class="built_in">memcpy</span>(tempData, data, (<span class="type">size_t</span>)size);</span><br><span class="line">	<span class="built_in">vkUnmapMemory</span>(pContentManager-&gt;device, stagingBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，驱动程序可能不会立即将数据复制到 GPU 的缓冲区内存。例如，可能由于缓存机制的影响，写入的内容不会立刻反映在 GPU 可见的内存中。有两种方式可以解决这个问题：</p>
<ol>
<li>使用主机一致（host-coherent）的内存堆<ul>
<li>这由 <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> 标志指示，它确保映射的内存始终与分配的 GPU 内存内容保持一致。</li>
</ul>
</li>
<li>显式刷新内存范围<ul>
<li>在写入映射内存后，调用 <code>vkFlushMappedMemoryRanges</code> 刷新内存范围，以确保数据被提交到 GPU。</li>
<li>在从映射内存读取数据前，调用 <code>vkInvalidateMappedMemoryRanges</code> 使缓存失效，以获取最新的 GPU 数据。</li>
</ul>
</li>
</ol>
<blockquote>
<p>即使使用了一致性内存堆或刷新了内存范围，也不能保证数据立即对 GPU 可见。数据传输到 GPU 是一个后台操作，而 Vulkan 规范只是保证在下次调用 <code>vkQueueSubmit</code> 之前，数据传输完成。</p>
</blockquote>
<h2 id="创建设备本地缓冲区"><a href="#创建设备本地缓冲区" class="headerlink" title="创建设备本地缓冲区"></a>创建设备本地缓冲区</h2><p>然后，创建目的缓冲区，由于将会执行从暂存缓冲区到目的缓冲区的拷贝，应该设置其标志为 <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>，设置内存类型为设备本地 <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> 以获得最佳性能，并执行从暂存缓冲区到顶点缓冲区的拷贝：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createDeviceLocalBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkDeviceMemory&amp; bufferMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="built_in">createBuffer</span>(size, </span><br><span class="line">                 VK_BUFFER_USAGE_TRANSFER_DST_BIT | usage, </span><br><span class="line">                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, </span><br><span class="line">                 buffer, </span><br><span class="line">                 bufferMemory);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">copyBuffer</span>(stagingBuffer, buffer, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，释放暂存缓冲区：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferManager::createDeviceLocalBuffer</span><span class="params">(<span class="type">const</span> VkDeviceSize size,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> <span class="type">void</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">											<span class="type">const</span> VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">											VkDeviceMemory&amp; bufferMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkDestroyBuffer</span>(pContentManager-&gt;device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">vkFreeMemory</span>(pContentManager-&gt;device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>图像</title>
    <url>/2025/03/20/Vulkan/4.%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过 <code>ImageManager</code> 类来实现图像管理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ImageManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ImageManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; commandManager);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setExtent</span><span class="params">(<span class="type">const</span> VkExtent2D&amp; extent)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    VkExtent3D extent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line">ImageManager::<span class="built_in">ImageManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, </span><br><span class="line">                           <span class="type">const</span> CommandManagerSPtr&amp; commandManager)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pCommandManager = commandManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::setExtent</span><span class="params">(<span class="type">const</span> VkExtent2D&amp; extent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;extent = &#123;extent.width, extent.height, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="创建和清理"><a href="#创建和清理" class="headerlink" title="创建和清理"></a>创建和清理</h1><p>与缓冲区的管理类似，实现一个辅助函数<code>createImage</code> 来创建图像对象，这个函数接收一些图像的创建信息，并将创建的图像和图像内存输出：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createImage</span><span class="params">(<span class="type">const</span> VkExtent3D&amp; extent,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> VkImageTiling tiling,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                     VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                     VkDeviceMemory&amp; imageMemory)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置图像对象"><a href="#配置图像对象" class="headerlink" title="配置图像对象"></a>配置图像对象</h2><p>通过结构体 <code>VkImageCreateInfo</code> 来说明一个图像对象的创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    VkImageCreateFlags       flags;</span><br><span class="line">    VkImageType              imageType;</span><br><span class="line">    VkFormat                 format;</span><br><span class="line">    VkExtent3D               extent;</span><br><span class="line">    <span class="type">uint32_t</span>                 mipLevels;</span><br><span class="line">    <span class="type">uint32_t</span>                 arrayLayers;</span><br><span class="line">    VkSampleCountFlagBits    samples;</span><br><span class="line">    VkImageTiling            tiling;</span><br><span class="line">    VkImageUsageFlags        usage;</span><br><span class="line">    VkSharingMode            sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>                 queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pQueueFamilyIndices;</span><br><span class="line">    VkImageLayout            initialLayout;</span><br><span class="line">&#125; VkImageCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</code>，以表明这是一个图像创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>创建图像时的附加标志</td>
<td>用于指定图像的创建标志，通常为 <code>0</code>，其他常见值包括：<br /><code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code>: 图像支持稀疏绑定。<br /><code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>: 图像可以用于立方体贴图。</td>
</tr>
<tr>
<td>imageType</td>
<td>图像类型</td>
<td>指定图像的类型，决定图像的维度。可选值：<br /><code>VK_IMAGE_TYPE_1D</code>: 一维图像。<br /><code>VK_IMAGE_TYPE_2D</code>: 二维图像（最常用）。<br /><code>VK_IMAGE_TYPE_3D</code>: 三维图像。<br /><code>VK_IMAGE_TYPE_MAX_ENUM</code> ：保留值。</td>
</tr>
<tr>
<td>format</td>
<td>图像格式</td>
<td>指定图像的像素格式，决定每个纹素的存储方式，常见值包括：<br /><code>VK_FORMAT_R8G8B8A8_SRGB</code>: 8 位 RGBA 格式，使用 sRGB 颜色空间。<br /><code>VK_FORMAT_B8G8R8A8_UNORM</code>: 8 位 BGRA 格式，未标准化。</td>
</tr>
<tr>
<td>extent</td>
<td>图像的宽度、高度和深度</td>
<td>指定图像的宽度、高度和深度，成员包括：<br /><code>width</code>: 图像的宽度（以纹素为单位）。<br /><code>height</code>: 图像的高度（以纹素为单位）。<br /><code>depth</code>: 图像的深度（以纹素为单位），对于 1D 和 2D 图像，通常为 <code>1</code>。</td>
</tr>
<tr>
<td>mipLevels</td>
<td>图像的多级渐远纹理层级数</td>
<td>指定图像的多级渐远纹理（mipmap）层级数。通常为 <code>1</code>，表示不使用多级渐远纹理。</td>
</tr>
<tr>
<td>arrayLayers</td>
<td>图像的数组层数</td>
<td>指定图像的数组层数。通常为 <code>1</code>，表示不使用纹理数组。</td>
</tr>
<tr>
<td>samples</td>
<td>图像的多重采样数</td>
<td>该值决定了每个像素所采集的样本数，通常用于控制抗锯齿的效果与性能之间的权衡，可用的值包括：<br /><code>VK_SAMPLE_COUNT_1_BIT</code>：不使用多重采样。<br /><code>VK_SAMPLE_COUNT_2_BIT </code>：每像素 <code>2</code> 重采样。<br /><code>VK_SAMPLE_COUNT_4_BIT </code>：每像素 <code>4</code> 重采样。<br /><code>VK_SAMPLE_COUNT_8_BIT </code>：每像素 <code>8</code> 重采样。<br /><code>VK_SAMPLE_COUNT_16_BIT </code>：每像素 <code>16</code> 重采样。<br /><code>VK_SAMPLE_COUNT_32_BIT </code>：每像素 <code>32</code> 重采样。<br /><code>VK_SAMPLE_COUNT_64_BIT </code>：每像素 <code>64</code> 重采样。<br /><code>VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>tiling</td>
<td>图像的平铺方式</td>
<td>指定图像的平铺方式，决定纹素在内存中的排列方式。<br /><code>K_IMAGE_TILING_LINEAR</code>: 纹素按行优先顺序排列，适合 CPU 访问。<br /><code>VK_IMAGE_TILING_OPTIMAL</code>: 纹素按实现定义的顺序排列，适合 GPU 访问。<br /><code>VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT</code>：指定图像的平铺由 Linux DRM 格式修饰符定义。<br /><code>VK_IMAGE_TILING_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>usage</td>
<td>图像的用途</td>
<td>指定图像的用途，决定图像可以用于哪些操作，常见值包括：<br /><code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code>: 图像可以作为传输操作的源。<br /><code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code>: 图像可以作为传输操作的目标。<br /><code>VK_IMAGE_USAGE_SAMPLED_BIT</code>: 图像可以在着色器中被采样。<br /><code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>: 图像可以用作颜色附件。</td>
</tr>
<tr>
<td>sharingMode</td>
<td>图像的共享模式</td>
<td>指定图像的共享模式，决定图像是否可以被多个队列族同时访问，可选值包括：<br /><code>VK_SHARING_MODE_EXCLUSIVE</code>: 图像只能由一个队列族访问（默认）。<br /><code>VK_SHARING_MODE_CONCURRENT</code>: 图像可以由多个队列族访问。</td>
</tr>
<tr>
<td>queueFamilyIndexCount</td>
<td>共享队列族索引数组数量</td>
<td>当 <code>sharingMode</code> 为 <code>VK_SHARING_MODE_CONCURRENT</code> 时，指定共享图像所需的队列族数量。</td>
</tr>
<tr>
<td>pQueueFamilyIndices</td>
<td>共享队列族索引数组指针</td>
<td>当 <code>sharingMode</code> 为 <code>VK_SHARING_MODE_CONCURRENT</code> 时，指定共享图像的队列族索引数组。</td>
</tr>
<tr>
<td>initialLayout</td>
<td>图像的初始布局</td>
<td>指定图像的初始布局，决定图像在创建时的内存布局，常见值包括：<br /><code>VK_IMAGE_LAYOUT_UNDEFINED</code>: 初始布局未定义，适合用作传输目标。此时GPU 不可用，第一次转换时将丢弃纹素。<br /><code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>: 初始布局已预初始化，适合用作传输源，此时GPU 不可用，但第一次转换时将保留纹素。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::createImage</span><span class="params">(<span class="type">const</span> VkExtent3D&amp; extent,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageTiling tiling,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkImageCreateInfo imageInfo&#123;&#125;;</span><br><span class="line">	imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;</span><br><span class="line">	imageInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	imageInfo.flags = <span class="number">0</span>;</span><br><span class="line">	imageInfo.imageType = VK_IMAGE_TYPE_2D;</span><br><span class="line">	imageInfo.format = format;</span><br><span class="line">	imageInfo.extent = extent;</span><br><span class="line">	imageInfo.mipLevels = <span class="number">1</span>;</span><br><span class="line">	imageInfo.arrayLayers = <span class="number">1</span>;</span><br><span class="line">	imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">	imageInfo.tiling = tiling;</span><br><span class="line">	imageInfo.usage = usage;</span><br><span class="line">	imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">	imageInfo.queueFamilyIndexCount = <span class="number">0</span>;</span><br><span class="line">	imageInfo.pQueueFamilyIndices = <span class="literal">nullptr</span>;</span><br><span class="line">	imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建图像对象"><a href="#创建图像对象" class="headerlink" title="创建图像对象"></a>创建图像对象</h2><p>然后，调用函数 <code>vkCreateImage</code> 来创建图像，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageCreateInfo*                    pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage*                                    pImage)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建图像的逻辑设备，图像与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>图像创建信息指针</td>
<td><code>VkImageCreateInfo</code> 结构体的指针，包含图像的属性、用途和内存布局等信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pImage</td>
<td>图像指针</td>
<td>指向 <code>VkImage</code> 变量的指针，存储创建的图像句柄。函数执行成功后，该变量将持有新创建的图像对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示图像是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示图像创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::createImage</span><span class="params">(<span class="type">const</span> VkExtent3D&amp; extent,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageTiling tiling,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateImage</span>(pContentManager-&gt;device, &amp;imageInfo, <span class="literal">nullptr</span>, &amp;image) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create image!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="为图像对象分配内存"><a href="#为图像对象分配内存" class="headerlink" title="为图像对象分配内存"></a>为图像对象分配内存</h2><p>最后，为图像分配内存，其方式与为缓冲区分配内存的方式完全相同。使用 <code>vkGetImageMemoryRequirements</code> 代替 <code>vkGetBufferMemoryRequirements</code>，并使用 <code>vkBindImageMemory</code> 代替 <code>vkBindBufferMemory</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::createImage</span><span class="params">(<span class="type">const</span> VkExtent3D&amp; extent,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageTiling tiling,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> VkMemoryPropertyFlags properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                               VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	VkMemoryRequirements memRequirements;</span><br><span class="line">	<span class="built_in">vkGetImageMemoryRequirements</span>(pContentManager-&gt;device, image, &amp;memRequirements);</span><br><span class="line"></span><br><span class="line">	VkMemoryAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">	allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">	allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">	allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(pContentManager-&gt;device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate image memory!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkBindImageMemory</span>(pContentManager-&gt;device, image, imageMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理图像对象"><a href="#清理图像对象" class="headerlink" title="清理图像对象"></a>清理图像对象</h2><p>在纹理图像使用完成之后，调用函数 <code>vkDestroyImage</code> 来销毁图像以释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage                                     image,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁图像的 Vulkan 设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>image</td>
<td>图像句柄</td>
<td>指定需要销毁的图像对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建图像时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：在销毁图像时同时需要释放对应的内存。</p>
</blockquote>
<h1 id="从缓冲区拷贝数据到图像"><a href="#从缓冲区拷贝数据到图像" class="headerlink" title="从缓冲区拷贝数据到图像"></a>从缓冲区拷贝数据到图像</h1><p>加载图像到设备内存和加载数据到设备内存类似，由于 CPU 不能直接接触对于设备本地类型的内存，所以需要通过暂存缓冲区进行数据传输。实现一个辅助函数 <code>copyBufferToImage</code> 来进行从缓冲区到图像内存的数据拷贝，这个函数接收缓冲区对象，图像对象和复制区域作为参数：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyBufferToImage</span><span class="params">(VkBuffer buffer, VkImage image, <span class="type">const</span> VkExtent3D&amp; extent)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置复制操作"><a href="#配置复制操作" class="headerlink" title="配置复制操作"></a>配置复制操作</h2><p>通过结构体 <code>VkBufferImageCopy</code> 来完成从缓冲区到图像复制操作的配置，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferImageCopy</span> &#123;</span><br><span class="line">    VkDeviceSize                bufferOffset;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferRowLength;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferImageHeight;</span><br><span class="line">    VkImageSubresourceLayers    imageSubresource;</span><br><span class="line">    VkOffset3D                  imageOffset;</span><br><span class="line">    VkExtent3D                  imageExtent;</span><br><span class="line">&#125; VkBufferImageCopy;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>bufferOffset</td>
<td>缓冲区中数据起始偏移量</td>
<td>这是从缓冲区起始位置到像素数据开始处的字节偏移量。</td>
</tr>
<tr>
<td>bufferRowLength</td>
<td>缓冲区中每行像素数</td>
<td>指定缓冲区中每行的像素数。<br />如果缓冲区中的数据在内存中存在行填充（padding），可以通过此字段指定实际的行长度。如果设置为 <code>0</code>，则表示行长度与图像的宽度相同。</td>
</tr>
<tr>
<td>bufferImageHeight</td>
<td>缓冲区中图像的高度</td>
<td>指定缓冲区中图像的高度（以像素为单位）。<br />如果缓冲区中的数据在内存中存在高度填充（padding），可以通过此字段指定实际的图像高度。如果设置为 <code>0</code>，则表示高度与图像的高度相同。</td>
</tr>
<tr>
<td>imageSubresource</td>
<td>目标图像的子资源信息</td>
<td>指定目标图像的子资源（Subresource）信息，成员包括：<br /><code>aspectMask</code>: 指定图像的哪些方面（aspect）将被复制（例如颜色、深度、模板等）。 <br /><code>mipLevel</code>: 指定目标图像的 mipmap 层级。 <br /><code>baseArrayLayer</code>: 指定目标图像的起始数组层。 <br /><code>layerCount</code>: 指定目标图像的数组层数。</td>
</tr>
<tr>
<td>imageOffset</td>
<td>目标图像中复制区域起始偏移量</td>
<td>指定目标图像中复制区域的起始偏移量（以像素为单位）。三维偏移量，用于指定复制区域在图像中的起始位置。</td>
</tr>
<tr>
<td>imageExtent</td>
<td>目标图像中复制区域大小</td>
<td>指定目标图像中复制区域的大小（以像素为单位）。三维范围，用于指定复制区域的宽度、高度和深度。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::copyBufferToImage</span><span class="params">(VkBuffer buffer, VkImage image, <span class="type">const</span> VkExtent3D&amp; extent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkBufferImageCopy region&#123;&#125;;</span><br><span class="line">    region.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    region.bufferRowLength = <span class="number">0</span>;</span><br><span class="line">    region.bufferImageHeight = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    region.imageSubresource.mipLevel = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.layerCount = <span class="number">1</span>;</span><br><span class="line">    region.imageOffset = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    region.imageExtent = extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="执行复制操作"><a href="#执行复制操作" class="headerlink" title="执行复制操作"></a>执行复制操作</h2><p>然后，调用函数 <code>vkCmdCopyBufferToImage</code> 来将复制命令录入命令缓冲区中，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdCopyBufferToImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage                                     dstImage,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImageLayout                               dstImageLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferImageCopy*                    pRegions)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定记录复制命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>srcBuffer</td>
<td>源缓冲区句柄</td>
<td>指定源缓冲区，即从中复制数据的缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dstImage</td>
<td>目标图像句柄</td>
<td>指定目标图像，即数据将被复制到的图像。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dstImageLayout</td>
<td>目标图像布局</td>
<td>指定目标图像的当前布局。  目标图像必须处于适合接收数据的布局（例如 <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>regionCount</td>
<td>复制区域数组数量</td>
<td>指定复制区域的数量。如果有多组数据需要从缓冲区复制到图像的不同区域，可以指定多个 <code>VkBufferImageCopy</code> 结构体。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pRegions</td>
<td>复制区域数组指针</td>
<td>指向 <code>VkBufferImageCopy</code> 结构体数组的指针，每个结构体定义了一个复制区域。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::copyBufferToImage</span><span class="params">(VkBuffer buffer, VkImage image, <span class="type">const</span> VkExtent3D&amp; extent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkCmdCopyBufferToImage</span>(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="number">1</span>, &amp;region);</span><br><span class="line"></span><br><span class="line">    pCommandManager-&gt;<span class="built_in">endTransferCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：图像布局需要处于 <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>。</p>
</blockquote>
<h1 id="从图像拷贝数据到缓冲区"><a href="#从图像拷贝数据到缓冲区" class="headerlink" title="从图像拷贝数据到缓冲区"></a>从图像拷贝数据到缓冲区</h1><p>以类似的方法，将图像数据拷贝到缓冲区中，此处实现一个辅助函数来实行拷贝：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyImageToBuffer</span><span class="params">(VkImage image, VkBuffer buffer, <span class="type">const</span> VkExtent3D&amp; extent)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>和缓冲区拷贝数据到图像类似，只需要把函数 <code>vkCmdCopyBufferToImage</code> 替换为 <code>vkCmdCopyImageToBuffer</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::copyImageToBuffer</span><span class="params">(VkImage image, VkBuffer buffer, <span class="type">const</span> VkExtent3D&amp; extent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkBufferImageCopy region&#123;&#125;;</span><br><span class="line">    region.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    region.bufferRowLength = <span class="number">0</span>;</span><br><span class="line">    region.bufferImageHeight = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    region.imageSubresource.mipLevel = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.layerCount = <span class="number">1</span>;</span><br><span class="line">    region.imageOffset = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    region.imageExtent = extent;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkCmdCopyImageToBuffer</span>(commandBuffer, image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, buffer, <span class="number">1</span>, &amp;region);</span><br><span class="line"></span><br><span class="line">    pCommandManager-&gt;<span class="built_in">endTransferCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：图像布局需要处于 <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code>。</p>
</blockquote>
<h1 id="布局转换"><a href="#布局转换" class="headerlink" title="布局转换"></a>布局转换</h1><p>在将图像数据从缓冲区复制到图像对象中时，需要首先保证图像处于正确的布局。执行布局转换的最常见方法之一是使用 <strong>图像内存屏障</strong>。图像内存障通常用于同步对资源的访问，例如确保在从缓冲区读取之前完成对缓冲区的写入，但它也可以用于转换图像布局，转移队列所有权。</p>
<p>实现一个辅助函数来实现图像的布局转换：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transformLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置屏障"><a href="#配置屏障" class="headerlink" title="配置屏障"></a>配置屏障</h2><p>通过结构体 <code>VkImageMemoryBarrier</code> 来描述一个屏障，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageMemoryBarrier</span> &#123;</span><br><span class="line">    VkStructureType            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                pNext;</span><br><span class="line">    VkAccessFlags              srcAccessMask;</span><br><span class="line">    VkAccessFlags              dstAccessMask;</span><br><span class="line">    VkImageLayout              oldLayout;</span><br><span class="line">    VkImageLayout              newLayout;</span><br><span class="line">    <span class="type">uint32_t</span>                   srcQueueFamilyIndex;</span><br><span class="line">    <span class="type">uint32_t</span>                   dstQueueFamilyIndex;</span><br><span class="line">    VkImage                    image;</span><br><span class="line">    VkImageSubresourceRange    subresourceRange;</span><br><span class="line">&#125; VkImageMemoryBarrier;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</code>，以表明这是一个图像内存屏障信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>srcAccessMask</td>
<td>在屏障之前必须完成的操作</td>
<td>指定在屏障之前必须完成的内存访问类型。这些访问操作将在屏障之前被同步，常见标志：<br /><code>VK_ACCESS_TRANSFER_READ_BIT</code>: 传输读取操作。 <br /><code>VK_ACCESS_TRANSFER_WRITE_BIT</code>: 传输写入操作。 <br /><code>VK_ACCESS_SHADER_READ_BIT</code>: 着色器读取操作。 <br /><code>VK_ACCESS_SHADER_WRITE_BIT</code>: 着色器写入操作。</td>
</tr>
<tr>
<td>dstAccessMask</td>
<td>在屏障之后必须等待的内存访问类型</td>
<td>指定在屏障之后必须等待的内存访问类型。这些访问操作将在屏障之后被同步。</td>
</tr>
<tr>
<td>oldLayout</td>
<td>图像在屏障之前的布局</td>
<td>指定图像在屏障之前的布局，常见值：<br /><code>VK_IMAGE_LAYOUT_UNDEFINED</code>: 图像内容未定义。 <br /><code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>: 图像作为传输目标。<br /> <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>: 图像作为着色器只读资源。</td>
</tr>
<tr>
<td>newLayout</td>
<td>图像在屏障之后的布局</td>
<td>指定图像在屏障之后的布局。</td>
</tr>
<tr>
<td>srcQueueFamilyIndex</td>
<td>在屏障之前拥有图像资源的队列族索引</td>
<td>指定在屏障之前拥有图像资源的队列族索引。如果不需要转移队列族所有权，设置为 <code>VK_QUEUE_FAMILY_IGNORED</code>。</td>
</tr>
<tr>
<td>dstQueueFamilyIndex</td>
<td>在屏障之后拥有图像资源的队列族索引</td>
<td>指定在屏障之后拥有图像资源的队列族索引。如果不需要转移队列族所有权，设置为 <code>VK_QUEUE_FAMILY_IGNORED</code>。</td>
</tr>
<tr>
<td>image</td>
<td>图像句柄</td>
<td>指定受屏障影响的图像对象。</td>
</tr>
<tr>
<td>subresourceRange</td>
<td>图像中受屏障影响的子资源范围。</td>
<td>成员包括:  <br /><code>aspectMask</code>: 指定图像的哪些方面（aspect）受屏障影响（例如颜色、深度、模板等）。 <br /><code>baseMipLevel</code>: 指定起始的 mipmap 层级。 <br /><code>levelCount</code>: 指定受影响的 mipmap 层级数。 <br /><code>baseArrayLayer</code>: 指定起始的数组层。 <br /><code>layerCount</code>: 指定受影响的数组层数。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::transformLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkImageMemoryBarrier barrier&#123;&#125;;</span><br><span class="line">    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</span><br><span class="line">    barrier.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    barrier.dstAccessMask = <span class="number">0</span>;</span><br><span class="line">    barrier.oldLayout = oldLayout;</span><br><span class="line">    barrier.newLayout = newLayout;</span><br><span class="line">    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.image = image;</span><br><span class="line">    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    barrier.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    barrier.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在完成基本屏障操作之后，还需要处理 <code>VkImageMemoryBarrier</code> 中访问掩码与 <code>vkCmdPipelineBarrier</code> 中管道阶段掩码的匹配。通常需要处理的转换有两种：</p>
<ol>
<li><p>未定义布局 到 传输目标布局，用于图像读取</p>
<p>在这个转换中，传输写入操作不需要等待任何内容。因此，在这个转换中，屏障的源访问掩码无须设置，但目的访问掩码需要设置为 <code>VK_ACCESS_TRANSFER_WRITE_BIT</code> 以指明在屏障之后等待传输写入完成。同时源管道阶段掩码设置为 <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，目的管道阶段掩码设置为 <code>VK_PIPELINE_STAGE_TRANSFER_BIT</code> 以表示数据传输阶段：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)</span><br><span class="line">&#123;</span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line"></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;</span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>传输目标布局 到 着色器读取布局，用于纹理加载</p>
<p>在这个转换中，着色器读取操作应等待传输写入操作完成。因此，在这个转换中屏障的源访问掩码需要设置问为 <code>VK_ACCESS_TRANSFER_WRITE_BIT</code> 以指明在屏障之前等待传输写入完成，目的访问掩码需要设置为 <code>VK_ACCESS_SHADER_READ_BIT</code> 以指明在屏障之后等待着色器读取可用。同时源管道阶段掩码设置为 <code>VK_PIPELINE_STAGE_TRANSFER_BIT</code> 以表示屏障之前的管线阶段为传输操作阶段，目的管道阶段掩码设置为 <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code> 以表示屏障之后的管道阶段为片段着色器阶段：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp;</span><br><span class="line">    newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)</span><br><span class="line">&#123;</span><br><span class="line">    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</span><br><span class="line"></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>一个完整的示例如下，后续将在深度缓冲区中扩展这个函数来使用深度图像：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::transformLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkImageMemoryBarrier barrier&#123;&#125;;</span><br><span class="line">    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</span><br><span class="line">    barrier.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    barrier.dstAccessMask = <span class="number">0</span>;</span><br><span class="line">    barrier.oldLayout = oldLayout;</span><br><span class="line">    barrier.newLayout = newLayout;</span><br><span class="line">    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.image = image;</span><br><span class="line">    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    barrier.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    barrier.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VkPipelineStageFlags sourceStage;</span><br><span class="line">    VkPipelineStageFlags destinationStage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line"></span><br><span class="line">        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;</span><br><span class="line">        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</span><br><span class="line"></span><br><span class="line">        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;unsupported layout transition!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="执行布局转化"><a href="#执行布局转化" class="headerlink" title="执行布局转化"></a>执行布局转化</h2><p>然后调用函数 <code>vkCmdPipelineBarrier</code> 来将转换命令提交到命令缓冲区，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdPipelineBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        srcStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        dstStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDependencyFlags                           dependencyFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    memoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bufferMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    imageMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定记录屏障命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>srcStageMask</td>
<td>屏障之前的管道阶段掩码</td>
<td>指定屏障之前的管道阶段掩码，表示哪些阶段的操作必须在屏障之前完成。常见值：<br /><code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>: 管道的最开始阶段。 <br /><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code>: 传输操作阶段。 <br /><code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>: 片段着色器阶段。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dstStageMask</td>
<td>屏障之后的管道阶段掩码</td>
<td>指定屏障之后的管道阶段掩码，表示哪些阶段的操作必须等待屏障完成。常见值：<br /><code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code>: 管道的最后阶段。 <br /><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code>: 传输操作阶段。 <br /><code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>: 片段着色器阶段。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dependencyFlags</td>
<td>屏障的依赖标志</td>
<td>指定屏障的依赖标志，用于控制屏障的行为，常见值:<br /> <code>0</code>：默认行为。 <br /><code>VK_DEPENDENCY_BY_REGION_BIT</code>：将屏障限制为按区域同步。</td>
</tr>
<tr>
<td>输入参数</td>
<td>memoryBarrierCount</td>
<td>内存屏障数组数量</td>
<td>指定内存屏障的数量，如果没有内存屏障，设置为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pMemoryBarriers</td>
<td>内存屏障数组指针</td>
<td>指向内存屏障数组的指针，如果没有内存屏障，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>bufferMemoryBarrierCount</td>
<td>缓冲区内存屏障数组数量</td>
<td>指定缓冲区内存屏障的数量，如果没有缓冲区内存屏障，设置为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pBufferMemoryBarriers</td>
<td>缓冲区内存屏障数组指针</td>
<td>指向缓冲区内存屏障数组的指针，如果没有缓冲区内存屏障，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>imageMemoryBarrierCount</td>
<td>图像内存屏障数组数量</td>
<td>指定图像内存屏障的数量，如果没有图像内存屏障，设置为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pImageMemoryBarriers</td>
<td>图像内存屏障数组指针</td>
<td>指向图像内存屏障数组的指针，如果没有图像内存屏障，设置为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitionImageLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    VkCommandBuffer commandBuffer = pCommandManager-&gt;<span class="built_in">beginTransferCommands</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkCmdPipelineBarrier</span>(commandBuffer, sourceStage, destinationStage, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">1</span>, &amp;barrier);</span><br><span class="line"></span><br><span class="line">	pCommandManager-&gt;<span class="built_in">endTransferCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="读取图像数据"><a href="#读取图像数据" class="headerlink" title="读取图像数据"></a>读取图像数据</h1><p>图像创建的总体流程和使用暂存缓冲区加载数据一致：</p>
<ol>
<li>使用 CPU 读取图像文件。</li>
<li>创建暂存缓冲区，并将图像数据拷贝到暂存缓冲区中。</li>
<li>创建图像对象和对应的设备内存。</li>
<li>将图像数据从暂存缓冲区拷贝到图像对象中。</li>
<li>清理暂存缓冲区。</li>
</ol>
<p>使用一个辅助函数 <code>loadImage</code> 来实现图像数据的读取，这个函数接收图像路径，最终布局作为参数并输出图像对象和图像内存：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                   VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                   VkDeviceMemory&amp; imageMemory)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="加载图像数据"><a href="#加载图像数据" class="headerlink" title="加载图像数据"></a>加载图像数据</h2><p>使用 <a class="link"   href="https://github.com/nothings/stb" >stb<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 库中的 <code>stb_image_manager.h</code> 来完成图像的加载，使用时需要定义宏 <code>STB_IMAGE_IMPLEMENTATION</code> 来包含函数体：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stb_image_manager.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br></pre></td></tr></table></figure></div>

<p>调用函数 <code>stbi_load</code> 来加载图像，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">stbi_uc *<span class="title">stbi_load</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *comp, <span class="type">int</span> req_comp)</span></span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>filename</td>
<td>图像文件路径</td>
<td>指定要加载的图像文件。</td>
</tr>
<tr>
<td>输出参数</td>
<td>x</td>
<td>图像宽度</td>
<td>指向一个整数的指针，用于存储图像的宽度（以像素为单位）。</td>
</tr>
<tr>
<td>输出参数</td>
<td>y</td>
<td>图像高度</td>
<td>指向一个整数的指针，用于存储图像的高度（以像素为单位）。</td>
</tr>
<tr>
<td>输出参数</td>
<td>comp</td>
<td>图像通道数量</td>
<td>指向一个整数的指针，用于存储图像文件中实际的通道数（例如，RGB 图像为 <code>3</code>，RGBA 图像为 <code>4</code>）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>req_comp</td>
<td>加载图像时希望得到的通道数</td>
<td>控制加载图像时的通道数。常见值包括：<br /><code>STBI_default</code>：使用图像文件中的原始通道数。<br /><code>STBI_grey</code>：加载为单通道（灰度图像）。<br /><code>STBI_grey_alpha</code>：加载为双通道（灰度 + Alpha）。<br /><code>STBI_rgb</code>：加载为 RGB（三通道）。<br /><code>STBI_rgb_alpha</code>：加载为 RGBA（四通道，带 Alpha 通道）。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>图像像素数据指针</td>
<td>指向图像像素数据的指针。像素数据按行优先顺序排列，每个像素的通道数由 <code>req_comp</code> 决定。<br />如果加载失败，返回 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>一个示例如下，为了能够统一处理所有类型的纹理，使用 <code>STBI_rgb_alpha</code> 强制获取四通道的图像：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width, height, channels;</span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(imagePath.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, STBI_rgb_alpha);</span><br><span class="line">    VkDeviceSize imageSize = width * height * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> extent = VkExtent3D&#123;<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width), <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height), <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pixels)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建暂存缓冲区"><a href="#创建暂存缓冲区" class="headerlink" title="创建暂存缓冲区"></a>创建暂存缓冲区</h2><p>调用缓冲区创建函数来创建暂存缓冲区，设置其标志为 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> 使得稍后能够将缓冲区复制到图像。同时设置内存类型为主机一致性 <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> 和主机可见性 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> 使得可以将纹理数据拷贝到缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    VkBuffer stagingBuffer</span>;</span><br><span class="line">	VkDeviceMemory stagingBufferMemory;</span><br><span class="line">	<span class="built_in">createBuffer</span>(imageSize,</span><br><span class="line">             	VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">             	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">             	stagingBuffer,</span><br><span class="line">             	stagingBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，将纹理数据拷贝到暂存缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="type">void</span>* data</span>;</span><br><span class="line">	<span class="built_in">vkMapMemory</span>(pContentManager-&gt;device, stagingBufferMemory, <span class="number">0</span>, imageSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">	<span class="built_in">memcpy</span>(data, pixels, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(imageSize));</span><br><span class="line">	<span class="built_in">vkUnmapMemory</span>(pContentManager-&gt;device, stagingBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建图像对象和内存"><a href="#创建图像对象和内存" class="headerlink" title="创建图像对象和内存"></a>创建图像对象和内存</h2><p>通过调用辅助函数 <code>createImage</code> 来创建图像对象和内存：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="title">createImage</span><span class="params">(extent,</span></span></span><br><span class="line"><span class="params"><span class="function">            	VK_FORMAT_R8G8B8A8_SRGB,</span></span></span><br><span class="line"><span class="params"><span class="function">            	VK_IMAGE_TILING_OPTIMAL,</span></span></span><br><span class="line"><span class="params"><span class="function">            	VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,</span></span></span><br><span class="line"><span class="params"><span class="function">            	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span></span></span><br><span class="line"><span class="params"><span class="function">            	image,</span></span></span><br><span class="line"><span class="params"><span class="function">            	imageMemory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="拷贝图像数据"><a href="#拷贝图像数据" class="headerlink" title="拷贝图像数据"></a>拷贝图像数据</h2><p>首先，调用 <code>transformLayout</code> 将创建的图像对象布局转化为 <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> 使其准备从缓冲区接收图像数据：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="title">transformLayout</span><span class="params">(image, </span></span></span><br><span class="line"><span class="params"><span class="function">                    VK_FORMAT_R8G8B8A8_SRGB, </span></span></span><br><span class="line"><span class="params"><span class="function">                    VK_IMAGE_LAYOUT_UNDEFINED, </span></span></span><br><span class="line"><span class="params"><span class="function">                    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，调用辅助函数 <code>copyBufferToImage</code> 执行从暂存缓冲区拷贝数据到图像中的操作：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">   <span class="title">copyBufferToImage</span><span class="params">(stagingBuffer, image, extent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这之后，调用 <code>transformLayout</code> 将复制完数据的图像布局转化为参数指定的最终布局：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="title">transformLayout</span><span class="params">(image, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, layout)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理资源"><a href="#清理资源" class="headerlink" title="清理资源"></a>清理资源</h2><p>最后，销毁暂存缓冲区释放资源，并调用函数 <code>stbi_image_free</code> 释放像素数据指针：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageManager::loadImage</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> VkImageLayout layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             VkDeviceMemory&amp; imageMemory)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="title">vkDestroyBuffer</span><span class="params">(pContentManager-&gt;device, stagingBuffer, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">	<span class="built_in">vkFreeMemory</span>(pContentManager-&gt;device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stbi_image_free</span>(pixels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="图像视图"><a href="#图像视图" class="headerlink" title="图像视图"></a>图像视图</h1><p>在 Vulkan 中，图像视图 <code>VkImageView</code> 是对 <code>VkImage</code> 的一种抽象化表示，它定义了如何访问图像资源以及图像资源的哪一部分可以被管线使用。图像视图的主要作用是将图像的原始数据映射到特定的格式和布局，使得 Vulkan 的着色器或渲染管线能够以一致的方式访问这些数据。例如，可以将图像视为 2D 纹理、深度纹理。</p>
<p>使用一个辅助函数 <code>loadImage</code> 来实现图像视图的创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">VkImageView <span class="title">createView</span><span class="params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置图像视图"><a href="#配置图像视图" class="headerlink" title="配置图像视图"></a>配置图像视图</h2><p>通过结构体 <code>VkImageViewCreateInfo</code> 可以设置图像视图的相关信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageViewCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                pNext;</span><br><span class="line">    VkImageViewCreateFlags     flags;</span><br><span class="line">    VkImage                    image;</span><br><span class="line">    VkImageViewType            viewType;</span><br><span class="line">    VkFormat                   format;</span><br><span class="line">    VkComponentMapping         components;</span><br><span class="line">    VkImageSubresourceRange    subresourceRange;</span><br><span class="line">&#125; VkImageViewCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</code>，以表明这是一个图像视图创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定图像视图创建时的附加标志</td>
<td>保留字段，目前必须为 0。</td>
</tr>
<tr>
<td>image</td>
<td>图像句柄</td>
<td>指定需要创建视图的 <code>VkImage</code> 对象。</td>
</tr>
<tr>
<td>viewType</td>
<td>图像视图的类型</td>
<td><code>VK_IMAGE_VIEW_TYPE_1D</code>：1D 图像视图。<br /><code>VK_IMAGE_VIEW_TYPE_2D</code>：2D 图像视图。<br /><code>VK_IMAGE_VIEW_TYPE_3D</code>：3D 图像视图。<br /><code>VK_IMAGE_VIEW_TYPE_CUBE</code>：立方体贴图视图。<br /><code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code>：2D 图像数组视图。<br /><code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>：立方体贴图数组视图。</td>
</tr>
<tr>
<td>format</td>
<td>图像视图的格式</td>
<td>例如 <code>VK_FORMAT_R8G8B8A8_SRGB</code>，指定了图像的像素格式和颜色通道顺序。</td>
</tr>
<tr>
<td>components</td>
<td>颜色通道的映射方式</td>
<td><code>r</code>、<code>g</code>、<code>b</code>、<code>a</code>：分别对应红、绿、蓝和 alpha 通道，可以设置为<br /><code>VK_COMPONENT_SWIZZLE_IDENTITY</code>（不变）<br /><code>VK_COMPONENT_SWIZZLE_ZERO</code>（置零）<br /><code>VK_COMPONENT_SWIZZLE_ONE</code>（置一）</td>
</tr>
<tr>
<td>subresourceRange</td>
<td>图像视图访问的子资源范围</td>
<td><code>aspectMask</code>：指定访问的图像方面。例如 <code>VK_IMAGE_ASPECT_COLOR_BIT</code>（颜色）或 <code>VK_IMAGE_ASPECT_DEPTH_BIT</code>（深度）。<br /><code>baseMipLevel</code>：指定从哪个 mipmap 级别开始访问。<br /><code>levelCount</code>：指定访问的 mipmap 级别数量。<br /><code>baseArrayLayer</code>：指定从哪个图层开始访问（用于数组或立方体贴图）<br /><code>layerCount</code>：指定访问的图层数量</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function">VkImageView <span class="title">ImageManager::createView</span><span class="params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkImageViewCreateInfo viewInfo&#123;&#125;;</span><br><span class="line">    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">    viewInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    viewInfo.flags = <span class="number">0</span>;</span><br><span class="line">    viewInfo.image = image;</span><br><span class="line">    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">    viewInfo.format = format;</span><br><span class="line">    viewInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    viewInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    viewInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    viewInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    viewInfo.subresourceRange.aspectMask = aspectFlags;</span><br><span class="line">    viewInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    viewInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建图像视图"><a href="#创建图像视图" class="headerlink" title="创建图像视图"></a>创建图像视图</h2><p>通过函数 <code>vkCreateImageView</code> 可以完成图像视图的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateImageView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageViewCreateInfo*                pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImageView*                                pView)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定图像视图所属的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>图像视图创建信息</td>
<td>指向描述图像视图创建信息的结构体的指针。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>可选的分配器回调函数</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果应用程序需要对内存分配和释放进行控制，可实现自定义分配器并通过此参数传递。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pView</td>
<td>图像视图句柄指针</td>
<td>指向存储创建的图像视图句柄的指针。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示图像视图是否成功</td>
<td><code>VK_SUCCESS</code>：表示创建成功。 <br />其他错误代码：表示创建失败，具体原因可能包括无效参数或设备不支持该功能。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function">VkImageView <span class="title">ImageManager::createView</span><span class="params">(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    VkImageView imageView;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImageView</span>(pContentManager-&gt;device, &amp;viewInfo, <span class="literal">nullptr</span>, &amp;imageView) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create texture image view!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理图像视图"><a href="#清理图像视图" class="headerlink" title="清理图像视图"></a>清理图像视图</h2><p>在图像视图使用完毕之后，需要显式释放资源。使用函数 <code>vkDestroyImageView</code> 可以完成图像视图的释放，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyImageView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImageView                                 imageView,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定图像视图所属的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>imageView</td>
<td>图像视图句柄</td>
<td>需要释放图像视图句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>可选的分配器回调函数</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建图像视图时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2025/03/20/Vulkan/2.%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过类 <code>CommandManager</code> 来管理命令的执行与命令缓冲区：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CommandManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CommandManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ContentManagerSPtr pContentManager;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;CommandManager&gt; CommandManagerSPtr;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line">CommandManager::<span class="built_in">CommandManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="命令池"><a href="#命令池" class="headerlink" title="命令池"></a>命令池</h1><p>在 Vulkan 中，想要使用命令缓冲区需要首先创建<strong>命令池</strong>（Command pools）。添加两个 <code>VkCommandPool</code> 成员变量，其中 <code>graphicsCommandPool</code> 用于分配记录绘制命令的命令缓冲区，<code>transferCommandPool</code> 用于分配记录转换命令的命令缓冲区，并添加函数 <code>createCommandPool</code> 来创建命令池：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createCommandPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VkCommandPool graphicsCommandPool = VK_NULL_HANDLE;</span><br><span class="line">    VkCommandPool transferCommandPool = VK_NULL_HANDLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置命令池"><a href="#配置命令池" class="headerlink" title="配置命令池"></a>配置命令池</h2><p>通过函数 <code>VkCommandPoolCreateInfo</code> 来描述一个命令池的创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext;</span><br><span class="line">    VkCommandPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                    queueFamilyIndex;</span><br><span class="line">&#125; VkCommandPoolCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</code>，以表明这是一个命令池创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定命令池创建时的附加标志。</td>
<td>指定命令池的行为，可取以下值（可组合）：<br/><code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>：提示 Vulkan 该命令池分配的命令缓冲区会被频繁重置或重新记录，可能影响内存分配策略。<br /><code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>：允许单独重置命令缓冲区（如果不设置此标志，所有命令缓冲区必须一起重置）。<br /><code>VK_COMMAND_POOL_CREATE_PROTECTED_BIT</code>：说明：用于受保护的命令缓冲区，与受保护资源交互（如 DRM 保护的图像）。</td>
</tr>
<tr>
<td>queueFamilyIndex</td>
<td>队列族索引</td>
<td>指定命令池分配的命令缓冲区所属的队列族索引，命令池只能分配适用于该队列族的命令缓冲区。</td>
</tr>
</tbody></table>
<p>一个示例如下，由于转换命令通常只需要一次执行，设置转换命令池为 <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::createCommandPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkCommandPoolCreateInfo graphicsPoolInfo&#123;&#125;;</span><br><span class="line">	graphicsPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line">	graphicsPoolInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	graphicsPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</span><br><span class="line">	graphicsPoolInfo.queueFamilyIndex = pContentManager-&gt;graphicsFamily;</span><br><span class="line">	</span><br><span class="line">	VkCommandPoolCreateInfo transferPoolInfo&#123;&#125;;</span><br><span class="line">	transferPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line">	transferPoolInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	transferPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT | </span><br><span class="line">        					 VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;</span><br><span class="line">	transferPoolInfo.queueFamilyIndex = pContentManager-&gt;transferFamily;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建命令池"><a href="#创建命令池" class="headerlink" title="创建命令池"></a>创建命令池</h2><p>然后，通过函数 <code>vkCreateCommandPool</code> 来创建命令池，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateCommandPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandPoolCreateInfo*              pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandPool*                              pCommandPool)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建命令池的逻辑设备，命令池与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>命令池创建信息指针</td>
<td><code>VkCommandPoolCreateInfo</code> 结构体的指针，包含命令池的创建信息。定义命令池的行为，如是否允许单独重置命令缓冲区，以及所属的队列族索引。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pCommandPool</td>
<td>命令池指针</td>
<td>指向 <code>VkCommandPool</code> 变量的指针，存储创建的命令池句柄。函数执行成功后，该变量将持有新创建的命令池对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示命令池是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示命令池创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::createCommandPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateCommandPool</span>(pContentManager-&gt;device, &amp;graphicsPoolInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;graphicsCommandPool) </span><br><span class="line">    != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create graphics command pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateCommandPool</span>(pContentManager-&gt;device, &amp;transferPoolInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;transferCommandPool) </span><br><span class="line">	!= VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create transfer command pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，在 <code>init</code> 函数中调用 <code>createCommandPool</code> 来创建命令池：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理命令池"><a href="#清理命令池" class="headerlink" title="清理命令池"></a>清理命令池</h2><p>在命令池使用完毕之后，需要调用 <code>vkDestroyCommandPool</code> 来销毁命令池，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyCommandPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandPool                               commandPool,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁命令池的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>commandPool</td>
<td>命令池句柄</td>
<td>指定要销毁命令池的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建命令池时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkDestroyCommandPool</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;graphicsCommandPool, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyCommandPool</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;transferCommandPool, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h1><p>在 Vulkan 中<strong>命令缓冲区</strong>（Command Buffer）的类型为 <code>VkCommandBuffer</code>，添加 <code>VkCommandBuffer</code> 数组变量来存储分配的绘制命令缓冲区，并通过函数 <code>createCommandBuffers</code> 进行创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;VkCommandBuffer&gt; graphicsCommandBuffers;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createCommandBuffers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置命令缓冲区"><a href="#配置命令缓冲区" class="headerlink" title="配置命令缓冲区"></a>配置命令缓冲区</h2><p>通过结构体 <code>VkCommandBufferAllocateInfo</code> 来描述一个命令缓冲区的分配信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkCommandPool           commandPool;</span><br><span class="line">    VkCommandBufferLevel    level;</span><br><span class="line">    <span class="type">uint32_t</span>                commandBufferCount;</span><br><span class="line">&#125; VkCommandBufferAllocateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</code>，以表明这是一个命令缓冲区分配信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>commandPool</td>
<td>命令池句柄</td>
<td>命令缓冲区的分配必须基于某个命令池 (<code>VkCommandPool</code>)，命令缓冲区将在该池管理的内存区域中分配。需要确保命令池是适用于相应的队列族（如图形队列或计算队列）。</td>
</tr>
<tr>
<td>level</td>
<td>命令缓冲区级别</td>
<td>指定命令缓冲区的级别，可能的值包括：<br /><code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code>：主命令缓冲区，可直接提交到队列执行，但不能被其他命令缓冲区调用。<br/><code>VK_COMMAND_BUFFER_LEVEL_SECONDARY</code>：次级命令缓冲区，不能直接提交到队列，但可以被主命令缓冲区调用，适用于重复的渲染指令。<br/></td>
</tr>
<tr>
<td>commandBufferCount</td>
<td>命令缓冲区数量</td>
<td>指定要分配的命令缓冲区数量。例如，如果需要多个命令缓冲区用于不同的帧，可以分配多个。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::createCommandBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    graphicsCommandBuffers.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line"></span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    allocInfo.commandPool = graphicsCommandPool;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>MAX_FRAMES_IN_FLIGHT</code> 将在多帧并行中使用。</p>
</blockquote>
<h2 id="分配命令缓冲区"><a href="#分配命令缓冲区" class="headerlink" title="分配命令缓冲区"></a>分配命令缓冲区</h2><p>然后，通过函数 <code>vkAllocateCommandBuffers</code> 来完成命令缓冲区的分配，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateCommandBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandBufferAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer*                            pCommandBuffers)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定进行命令缓冲区分配的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocateInfo</td>
<td>命令缓冲区分配信息指针</td>
<td>该参数是一个指向 <code>VkCommandBufferAllocateInfo</code> 结构体的指针，该结构体说明了命令缓冲区分配的相关信息。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pCommandBuffers</td>
<td>命令缓冲区指针</td>
<td>该参数是一个指向 <code>VkCommandBuffer</code> 数组的指针，存储分配的命令缓冲区。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示命令缓冲区是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示命令池创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::createCommandBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateCommandBuffers</span>(pContentManager-&gt;device, &amp;allocInfo, &amp;graphicsCommandBuffers) </span><br><span class="line">        != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate command buffers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理命令缓冲区"><a href="#清理命令缓冲区" class="headerlink" title="清理命令缓冲区"></a>清理命令缓冲区</h2><p>通过函数 <code>vkFreeCommandBuffers</code> 来清理命令缓冲区，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkFreeCommandBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandPool                               commandPool,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    commandBufferCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandBuffer*                      pCommandBuffers)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要释放命令缓冲区的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>commandPool</td>
<td>命令池句柄</td>
<td>指定要释放命令缓冲区的命令池句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>commandBufferCount</td>
<td>命令缓冲区句柄数组大小</td>
<td>指定要释放的指令缓冲区数量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCommandBuffers</td>
<td>命令缓冲区句柄数组指针</td>
<td>指向要释放的指令缓冲区句柄数组的指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：命令缓冲区在其所属的命令池销毁时会自动释放，因此不需要显式地清理。清理通常发生在只执行一次的命令缓冲区上。</p>
</blockquote>
<h1 id="记录命令缓冲区"><a href="#记录命令缓冲区" class="headerlink" title="记录命令缓冲区"></a>记录命令缓冲区</h1><p>记录命令缓冲区通常涉及三个部分，开始命令缓冲区录制，录制命令，结束命令缓冲区录制。</p>
<p>这里以两个辅助函数为例，完成转化命令的开始录制 <code>beginTransferCommands</code>，转化命令的结束录制和提交执行 <code>endTransferCommands</code> ：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">VkCommandBuffer <span class="title">beginTransferCommands</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">endTransferCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="开始记录"><a href="#开始记录" class="headerlink" title="开始记录"></a>开始记录</h2><p>在 Vulkan 中，通过函数 <code>vkBeginCommandBuffer</code> 来开始记录命令缓冲区，其通过结构体  <code>VkCommandBufferBeginInfo</code>来进行描述，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferBeginInfo</span> &#123;</span><br><span class="line">    VkStructureType                          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                              pNext;</span><br><span class="line">    VkCommandBufferUsageFlags                flags;</span><br><span class="line">    <span class="type">const</span> VkCommandBufferInheritanceInfo*    pInheritanceInfo;</span><br><span class="line">&#125; VkCommandBufferBeginInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</code>，以表明这是一个命令缓冲区开始记录信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>命令缓冲区记录标志</td>
<td>指定命令缓冲区记录的标志，可能的值包括：<br /><code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>：该命令缓冲区只会被提交一次，之后会被重录。<br/><code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>：缓冲区是二级命令缓冲区，将会被完全包含在一个渲染通道内。<br/><code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code>：该缓冲区可以在执行时同时重新提交。<br/><code>VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>pInheritanceInfo</td>
<td>继承信息指针</td>
<td>指向 <code>VkCommandBufferInheritanceInfo</code> 的指针。此成员仅对二级命令缓冲区有效。它包含了需要从主命令缓冲区继承的状态信息（例如，是否继续渲染通道、是否继承某些资源绑定等）。对于主命令缓冲区，此成员应为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>附加信息：<code>VkCommandBufferInheritanceInfo</code> 的声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferInheritanceInfo</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkRenderPass                     renderPass;</span><br><span class="line">    <span class="type">uint32_t</span>                         subpass;</span><br><span class="line">    VkFramebuffer                    framebuffer;</span><br><span class="line">    VkBool32                         occlusionQueryEnable;</span><br><span class="line">    VkQueryControlFlags              queryFlags;</span><br><span class="line">    VkQueryPipelineStatisticFlags    pipelineStatistics;</span><br><span class="line">&#125; VkCommandBufferInheritanceInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO</code>，以表明这是一个命令缓冲区继承信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>renderPass</td>
<td>渲染通道句柄</td>
<td>主命令缓冲区中正在使用的渲染通道对象。二级命令缓冲区将继承这个渲染通道的状态信息（如输入附件、输出附件等）。</td>
</tr>
<tr>
<td>subpass</td>
<td>子通道索引</td>
<td>主命令缓冲区正在使用的渲染通道中的子通道（subpass）的索引。二级命令缓冲区将在这个子通道内执行。</td>
</tr>
<tr>
<td>framebuffer</td>
<td>帧缓冲区句柄</td>
<td>主命令缓冲区正在使用的帧缓冲区对象。二级命令缓冲区将继承与此帧缓冲区相关的状态。</td>
</tr>
<tr>
<td>occlusionQueryEnable</td>
<td>是否启用遮挡查询</td>
<td>如果为 <code>VK_TRUE</code>，则启用遮挡查询（occlusion query）。遮挡查询用于检查某些对象是否可见。如果为 <code>VK_FALSE</code>，则禁用遮挡查询。</td>
</tr>
<tr>
<td>queryFlags</td>
<td>查询标志</td>
<td>用于设置查询的行为。例如，控制查询是否需要精确结果或是否是离线查询等。</td>
</tr>
<tr>
<td>pipelineStatistics</td>
<td>管道统计标志</td>
<td>用于指定需要收集的管道统计信息。例如，是否收集各个渲染阶段的计数器数据。</td>
</tr>
</tbody></table>
<p>实现 <code>beginTransferCommands</code> 函数，首先需要分配一个临时的命令缓冲区。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function">VkCommandBuffer <span class="title">CommandManager::beginTransferCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Creating a temporary command buffer */</span></span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    allocInfo.commandPool = <span class="keyword">this</span>-&gt;transferCommandPool;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    VkCommandBuffer commandBuffer;</span><br><span class="line">    <span class="built_in">vkAllocateCommandBuffers</span>(pContentManager-&gt;device, &amp;allocInfo, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于通常传输命令只会执行一次，为了让 Vulkan 优化 这个命令，指定了 <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> 标志：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function">VkCommandBuffer <span class="title">CommandManager::beginTransferCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    VkCommandBufferBeginInfo beginInfo&#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    beginInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line">    beginInfo.pInheritanceInfo = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后通过调用函数 <code>vkBeginCommandBuffer</code> 来开始命令缓冲区的记录，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkBeginCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandBufferBeginInfo*             pBeginInfo)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定开始进行命令记录的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pBeginInfo</td>
<td>命令缓冲区开始记录信息指针</td>
<td>指向 <code>VkCommandBufferBeginInfo</code> 结构体的指针，该结构体包含有关如何开始记录命令的信息。</td>
</tr>
</tbody></table>
<p>注意：如果命令缓冲区已经被记录过一次，那么再次调用 <code>vkBeginCommandBuffer</code> 会自动重置它，调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function">VkCommandBuffer <span class="title">CommandManager::beginTransferCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);</span><br><span class="line">    <span class="keyword">return</span> commandBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="结束录制"><a href="#结束录制" class="headerlink" title="结束录制"></a>结束录制</h2><p>在完成命令记录之后，通过调用函数 <code>vkEndCommandBuffer</code> 来结束命令记录，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult VKAPI_CALL <span class="title">vkEndCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定结束命令记录的命令缓冲区。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>命令记录结束是否成功</td>
<td><code>VK_SUCCESS</code>：成功结束命令缓冲区的记录。其他错误码表示结束失败</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::endTransferCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkEndCommandBuffer</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="提交命令缓冲区"><a href="#提交命令缓冲区" class="headerlink" title="提交命令缓冲区"></a>提交命令缓冲区</h1><h2 id="配置提交信息"><a href="#配置提交信息" class="headerlink" title="配置提交信息"></a>配置提交信息</h2><p>通过结构体 <code>VkSubmitInfo</code> 来完成队列提交和同步的配置，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubmitInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                       waitSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pWaitSemaphores;</span><br><span class="line">    <span class="type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;</span><br><span class="line">    <span class="type">uint32_t</span>                       commandBufferCount;</span><br><span class="line">    <span class="type">const</span> VkCommandBuffer*         pCommandBuffers;</span><br><span class="line">    <span class="type">uint32_t</span>                       signalSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pSignalSemaphores;</span><br><span class="line">&#125; VkSubmitInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SUBMIT_INFO</code>，以表明这是一个提交信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>waitSemaphoreCount</td>
<td>等待的信号量数量</td>
<td>用于指定在执行命令缓冲区之前，需要等待的 <code>VkSemaphore</code> 数量。</td>
</tr>
<tr>
<td>pWaitSemaphores</td>
<td>等待的信号量数组</td>
<td>指定在提交的命令缓冲区执行之前需要等待的信号量。</td>
</tr>
<tr>
<td>pWaitDstStageMask</td>
<td>等待的管线阶段</td>
<td>与 <code>pWaitSemaphores</code> 对应，指定在管线的哪个阶段等待信号量。</td>
</tr>
<tr>
<td>commandBufferCount</td>
<td>提交的命令缓冲区数量</td>
<td><code>pCommandBuffers</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pCommandBuffers</td>
<td>待执行的命令缓冲区数组</td>
<td>包含需要提交执行的 <code>VkCommandBuffer</code> 指针数组。</td>
</tr>
<tr>
<td>signalSemaphoreCount</td>
<td>提交完成后要发出的信号量数量</td>
<td><code>pSignalSemaphores</code> 数组的中的元素数量。</td>
</tr>
<tr>
<td>pSignalSemaphores</td>
<td>提交完成后要发出的信号量数组</td>
<td>用于通知 GPU 某些操作已经完成，例如渲染完成可以进行显示。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::endTransferCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">	submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">	submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	submitInfo.waitSemaphoreCount = <span class="number">0</span>;</span><br><span class="line">	submitInfo.pWaitSemaphores = <span class="literal">nullptr</span>;</span><br><span class="line">	submitInfo.pWaitDstStageMask = <span class="literal">nullptr</span>;</span><br><span class="line">	submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">	submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">	submitInfo.signalSemaphoreCount = <span class="number">0</span>;</span><br><span class="line">	submitInfo.pSignalSemaphores = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="执行命令提交"><a href="#执行命令提交" class="headerlink" title="执行命令提交"></a>执行命令提交</h2><p>然后通过函数 <code>vkQueueSubmit</code> 来将命令缓冲区提交到传输队列中，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkQueueSubmit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue                                     queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    submitCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSubmitInfo*                         pSubmits,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>queue</td>
<td>队列句柄</td>
<td>目标 Vulkan 队列（如图形队列、计算队列），命令缓冲区将在此队列上执行。</td>
</tr>
<tr>
<td>输入参数</td>
<td>submitCount</td>
<td>提交的信息数组大小</td>
<td>提交的 <code>VkSubmitInfo</code> 结构体数量，即 <code>pSubmits</code> 数组的大小。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pSubmits</td>
<td>提交的信息数组指针</td>
<td>提交的信息数组，包含 <code>submitCount</code> 个 <code>VkSubmitInfo</code> 结构体，描述命令缓冲区及同步信息。</td>
</tr>
<tr>
<td>输出参数</td>
<td>fence</td>
<td>栅栏句柄</td>
<td>可选的同步对象，用于在命令执行完成后通知 CPU，通常用于确保 CPU 不会过早修改资源（可传 <code>VK_NULL_HANDLE</code>）。在命令缓冲区执行完毕之后会触发该栅栏。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>提交是否成功</td>
<td>可能的值包括：<br /><code>VK_SUCCESS</code>：成功提交。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足，无法完成操作。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足，无法完成操作。</td>
</tr>
</tbody></table>
<p>一个示例如下，由于此处没有使用信号量和栅栏，通过函数 <code>vkQueueWaitIdle</code> 来等待传输命令执行结束并释放命令缓冲区：：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandManager::endTransferCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">vkQueueSubmit</span>(pContentManager-&gt;transferQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);</span><br><span class="line">	<span class="built_in">vkQueueWaitIdle</span>(pContentManager-&gt;transferQueue);</span><br><span class="line">	<span class="built_in">vkFreeCommandBuffers</span>(pContentManager-&gt;device, transferCommandPool, <span class="number">1</span>, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链</title>
    <url>/2025/03/20/Vulkan/5.%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>在使用交换链之前需要启用 <code>VK_KHR_swapchain</code> 扩展，该扩展是设备扩展，需要在逻辑设备创建时开启，这里扩展函数 <code>ContentManager::getRequiredDeviceExtensions</code>，使其包含 <code>VK_KHR_swapchain</code> 扩展，这里使用宏 <code>VK_KHR_SWAPCHAIN_EXTENSION_NAME</code> 以避免拼写出错 ：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredDeviceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; deviceExtensions&#123;&#125;;</span><br><span class="line">    deviceExtensions.<span class="built_in">push_back</span>(VK_KHR_SWAPCHAIN_EXTENSION_NAME);</span><br><span class="line">    <span class="keyword">return</span> deviceExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了模块化设计，使用类 <code>SwapChainManager</code> 来管理交换链，其中 <code>init</code> 函数将执行所有初始化操作，<code>clear</code> 函数将执行所有清理操作：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SwapChainManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SwapChainManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; commandManager);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;SwapChainManager&gt; SwapChainManagerSPtr;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line">SwapChainManager::<span class="built_in">SwapChainManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; commandManager)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pCommandManager = commandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>交换链存在多种属性，基本上，需要检查以下三类属性：</p>
<ol>
<li><strong>基本表面能力</strong>（交换链中的图像最小&#x2F;最大数量，图像的最小&#x2F;最大宽度和高度）</li>
<li><strong>表面格式</strong>（像素格式、颜色空间）</li>
<li><strong>可用呈现模式</strong></li>
</ol>
<h1 id="基本表面能力"><a href="#基本表面能力" class="headerlink" title="基本表面能力"></a>基本表面能力</h1><p>在类中添加 <code>VkSurfaceCapabilitiesKHR</code> 类型的成员变量用于存储查询得到的基本表面能力，并添加 <code>getExtend</code> 成员函数来查询并选择正确的交换范围：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">VkExtent2D <span class="title">getExtent</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VkSurfaceCapabilitiesKHR capabilities;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="查询基本表面能力"><a href="#查询基本表面能力" class="headerlink" title="查询基本表面能力"></a>查询基本表面能力</h2><p>通过函数 <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> 可以查询指定物理设备与特定表面（surface）相关的<strong>基本表面能力</strong>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR surface,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询的物理设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>surface</td>
<td>窗口表面句柄</td>
<td>指定需要查询的窗口表面。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSurfaceCapabilities</td>
<td>指向一个 <code>VkSurfaceCapabilitiesKHR</code> 结构的指针</td>
<td>函数会填充该结构以返回表面能力的信息。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示能力查询是否成功</td>
<td><code>VK_SUCCESS</code>：表示查询成功。  其他错误代码：表示查询失败，具体原因可能包括无效参数或设备不支持该功能。</td>
</tr>
</tbody></table>
<p>注意：在调用此函数之前，确保 <code>physicalDevice</code> 和 <code>surface</code> 都已经有效初始化。</p>
<p>在结构体 <code>VkSurfaceCapabilitiesKHR</code> 中包含了 Vulkan 表面的基本能力信息，其声明如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct VkSurfaceCapabilitiesKHR &#123;</span><br><span class="line"> uint32_t                         minImageCount;</span><br><span class="line"> uint32_t                         maxImageCount;</span><br><span class="line"> VkExtent2D                       currentExtent;</span><br><span class="line"> VkExtent2D                       minImageExtent;</span><br><span class="line"> VkExtent2D                       maxImageExtent;</span><br><span class="line"> uint32_t                         maxImageArrayLayers;</span><br><span class="line"> VkSurfaceTransformFlagsKHR       supportedTransforms;</span><br><span class="line"> VkSurfaceTransformFlagBitsKHR    currentTransform;</span><br><span class="line"> VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;</span><br><span class="line"> VkImageUsageFlags                supportedUsageFlags;</span><br><span class="line">&#125; VkSurfaceCapabilitiesKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>minImageCount</td>
<td>表示交换链中至少需要的图像数量</td>
<td>交换链的图像数量必须大于或等于此值</td>
</tr>
<tr>
<td>xxxxxxxxxx &#x2F;&#x2F; image_manager.cppvoid DepthImageManager::clear(){    vkDestroyImage(pContentManager-&gt;device, this-&gt;image, nullptr);    vkFreeMemory(pContentManager-&gt;device, this-&gt;imageMemory, nullptr);    vkDestroyImageView(pContentManager-&gt;device, this-&gt;imageView, nullptr);}c++</td>
<td>表示交换链中最多允许的图像数量</td>
<td>如果此值为 <code>0</code>，则表示没有上限</td>
</tr>
<tr>
<td>currentExtent</td>
<td>表示当前表面的分辨率（宽度和高度），单位为像素</td>
<td>如果 <code>currentExtent</code> 的宽度和高度都为 <code>uint32_t</code> 的最大值（<code>0xFFFFFFFF</code>），则表明窗口管理器允许选择不同的分辨率</td>
</tr>
<tr>
<td>minImageExtent</td>
<td>表示交换链图像分辨率的最小宽度和高度</td>
<td>单位为像素</td>
</tr>
<tr>
<td>maxImageExtent</td>
<td>表示交换链图像分辨率的最大宽度和高度</td>
<td>单位为像素</td>
</tr>
<tr>
<td>maxImageArrayLayers</td>
<td>表示交换链中单个图像所支持的最大数组层数</td>
<td>对于大多数应用，这个值通常为 <code>1</code>，除非需要使用图像数组。</td>
</tr>
<tr>
<td>supportedTransforms</td>
<td>表示支持的图像变换操作（如旋转、镜像等）</td>
<td>使用 <code>VkSurfaceTransformFlagsKHR</code> 标志位表示。</td>
</tr>
<tr>
<td>currentTransform</td>
<td>表示当前表面应用的变换操作</td>
<td>使用 <code>VkSurfaceTransformFlagBitsKHR</code> 标志位表示。</td>
</tr>
<tr>
<td>supportedCompositeAlpha</td>
<td>表示支持的 alpha 混合操作</td>
<td>使用 <code>VkCompositeAlphaFlagsKHR</code> 标志位表示。</td>
</tr>
<tr>
<td>supportedUsageFlags</td>
<td>表示交换链图像的支持用途</td>
<td>使用 <code>VkImageUsageFlags</code> 标志位表示。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function">VkExtent2D <span class="title">SwapChainManager::getExtent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Query surface capabilities */</span></span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(</span><br><span class="line">        pContentManager-&gt;physicalDevice, pContentManager-&gt;surface, &amp;<span class="keyword">this</span>-&gt;capabilities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择正确的交换范围"><a href="#选择正确的交换范围" class="headerlink" title="选择正确的交换范围"></a>选择正确的交换范围</h2><p>在交换链中，图像的分辨率又称为<strong>交换范围</strong>（swap extent）。通常情况下，交换范围与渲染窗口的分辨率一致。但在部分情况下，窗口管理器允许选择不同的分辨率，此时，<code>currentExtent</code> 的宽度和高度都为 <code>uint32_t</code> 的最大值。在这种时候则需要使用函数 <code>glfwGetFramebufferSize</code> 来查询窗口的像素分辨率来作为实际的交换范围，同时限制交换范围到支持的最大和最小值之间，示例代码：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function">VkExtent2D <span class="title">SwapChainManager::getExtent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;capabilities.currentExtent.width != std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;capabilities.currentExtent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> width, height;</span><br><span class="line">        <span class="built_in">glfwGetFramebufferSize</span>(pContentManager-&gt;window, &amp;width, &amp;height);</span><br><span class="line"></span><br><span class="line">        VkExtent2D resultlExtent = &#123;<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width), <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height)&#125;;</span><br><span class="line"></span><br><span class="line">        resultlExtent.width = std::<span class="built_in">clamp</span>(</span><br><span class="line">            resultlExtent.width, <span class="keyword">this</span>-&gt;capabilities.minImageExtent.width, </span><br><span class="line">            <span class="keyword">this</span>-&gt;capabilities.maxImageExtent.width);</span><br><span class="line">        resultlExtent.height = std::<span class="built_in">clamp</span>(</span><br><span class="line">            resultlExtent.height, <span class="keyword">this</span>-&gt;capabilities.minImageExtent.height, </span><br><span class="line">            <span class="keyword">this</span>-&gt;capabilities.maxImageExtent.height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlExtent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="表面格式"><a href="#表面格式" class="headerlink" title="表面格式"></a>表面格式</h1><p>在类中添加 <code>std::vector&lt;VkSurfaceFormatKHR&gt;</code> 类型的成员变量用于存储查询得到的表面格式，并添加 <code>getFormat</code> 成员函数来查询并选择最佳的表面格式：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">VkSurfaceFormatKHR <span class="title">getFormat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;VkSurfaceFormatKHR&gt; formats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="查询表面格式"><a href="#查询表面格式" class="headerlink" title="查询表面格式"></a>查询表面格式</h2><p>通过函数 <code>vkGetPhysicalDeviceSurfaceFormatsKHR</code> 来查询窗口表面的<strong>表面格式</strong> (Surface formats)，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkGetPhysicalDeviceSurfaceFormatsKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR surface,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>* pSurfaceFormatCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceFormatKHR* pSurfaceFormats</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询的物理设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>surface</td>
<td>窗口表面句柄</td>
<td>指定需要查询的窗口表面。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSurfaceFormatCount</td>
<td>整数变量指针</td>
<td>第一次调用时，该变量会被填充为支持的表面格式的数量。如果第二次调用时 <code>pSurfaceFormats</code> 为非空，则该变量应包含可写入的表面格式数量。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSurfaceFormats</td>
<td><code>VkSurfaceFormatKHR</code> 数组指针</td>
<td>如果为 <code>nullptr</code>，函数只返回支持的表面格式的数量（写入 <code>pSurfaceFormatCount</code>。如果不为 <code>nullptr</code>，函数会填充该数组，包含所有支持的表面格式。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示表面格式是否成功</td>
<td><code>VK_SUCCESS</code>：表示查询成功。  其他错误代码：表示查询失败，具体原因可能包括无效参数或设备不支持该功能。</td>
</tr>
</tbody></table>
<p>注意：在调用此函数之前，确保 <code>physicalDevice</code> 和 <code>surface</code> 都已经有效初始化。</p>
<p>由于查询结果是数组，需要先查询结果数组的大小，然后申请对应大小的内存，最后获取结果数组：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function">VkSurfaceFormatKHR <span class="title">SwapChainManager::getFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Query surface format */</span></span><br><span class="line">    <span class="type">uint32_t</span> formatCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(</span><br><span class="line">        pContentManager-&gt;physicalDevice, pContentManager-&gt;surface, &amp;formatCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (formatCount != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;formats.<span class="built_in">resize</span>(formatCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(</span><br><span class="line">            pContentManager-&gt;physicalDevice, pContentManager-&gt;surface, &amp;formatCount, <span class="keyword">this</span>-&gt;formats.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择最佳表现模式"><a href="#选择最佳表现模式" class="headerlink" title="选择最佳表现模式"></a>选择最佳表现模式</h2><p>在结构体 <code>VkSurfaceFormatKHR</code> 中，存在两个成员变量，分别为 <code>format</code> 和 <code>colorSpace</code> ，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSurfaceFormatKHR</span> </span><br><span class="line">&#123;</span><br><span class="line">    VkFormat           format;</span><br><span class="line">    VkColorSpaceKHR    colorSpace;</span><br><span class="line">&#125; VkSurfaceFormatKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>format</td>
<td>表示表面支持的颜色格式（像素格式）</td>
<td>该值定义了每个像素的颜色通道（例如红、绿、蓝、透明度）的存储顺序和数据类型。例如<code>VK_FORMAT_B8G8R8A8_SRGB</code>: 每像素包含蓝 (B)、绿 (G)、红 (R) 和透明度 (A) 通道，每个通道 8 位，总计 32 位，使用 SRGB 色彩空间。</td>
</tr>
<tr>
<td>colorSpace</td>
<td>表示表面支持的色彩空间</td>
<td>色彩空间定义了颜色如何被解释或显示。例如 <code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> 表示支持 SRGB 非线性色彩空间。</td>
</tr>
</tbody></table>
<p>选择最佳表现模式需要根据需求选择合适的颜色格式和色彩空间组合，通常使用 <code>VkSurfaceFormatKHR</code> 中的第一个元素：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function">VkSurfaceFormatKHR <span class="title">SwapChainManager::getFormat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; format : <span class="keyword">this</span>-&gt;formats)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (format.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; </span><br><span class="line">            format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;formats[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="呈现模式"><a href="#呈现模式" class="headerlink" title="呈现模式"></a>呈现模式</h1><p>在类中添加 <code>std::vector&lt;VkPresentModeKHR&gt;</code> 类型的成员变量用于存储查询得到的呈现模式，并添加 <code>getPresentMode</code> 成员函数来查询并选择最佳的呈现模式：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">VkPresentModeKHR <span class="title">getPresentMode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;VkPresentModeKHR&gt; presentModes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="查询呈现模式"><a href="#查询呈现模式" class="headerlink" title="查询呈现模式"></a>查询呈现模式</h2><p>通过函数 <code>vkGetPhysicalDeviceSurfacePresentModesKHR</code> 来查询窗口表面的可用<strong>呈现模式</strong>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkGetPhysicalDeviceSurfacePresentModesKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR surface,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>* pPresentModeCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPresentModeKHR* pPresentModes</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询的物理设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>surface</td>
<td>窗口表面句柄</td>
<td>指定需要查询的窗口表面。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPresentModeCount</td>
<td>整数变量指针</td>
<td>如果 <code>pPresentModes</code> 为 <code>nullptr</code>，则此变量将返回支持的呈现模式总数，否则表示返回的呈现模式数组的大小。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPresentModes</td>
<td><code>VkPresentModeKHR</code> 数组指针</td>
<td>如果为 <code>nullptr</code>，函数只返回支持的呈现模式的数量（写入 <code>pPresentModeCount</code>。如果不为 <code>nullptr</code>，函数会填充该数组，包含所有支持的呈现模式。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示表面格式是否成功</td>
<td>**<code>VK_SUCCESS</code>**：表示查询成功。  <strong>其他错误代码</strong>：表示查询失败，具体原因可能包括无效参数或设备不支持该功能。</td>
</tr>
</tbody></table>
<p>注意：在调用此函数之前，确保 <code>physicalDevice</code> 和 <code>surface</code> 都已经有效初始化。</p>
<p>由于查询结果是数组，需要先查询结果数组的大小，然后申请对应大小的内存，最后获取结果数组：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function">VkPresentModeKHR <span class="title">SwapChainManager::getPresentMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Query rendering mode */</span></span><br><span class="line">    <span class="type">uint32_t</span> presentModeCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(</span><br><span class="line">        pContentManager-&gt;physicalDevice, pContentManager-&gt;surface, &amp;presentModeCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (presentModeCount != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;presentModes.<span class="built_in">resize</span>(presentModeCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(</span><br><span class="line">            pContentManager-&gt;physicalDevice, pContentManager-&gt;surface, &amp;presentModeCount, <span class="keyword">this</span>-&gt;presentModes.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择最佳呈现模式"><a href="#选择最佳呈现模式" class="headerlink" title="选择最佳呈现模式"></a>选择最佳呈现模式</h2><p><code>VkPresentModeKHR</code> 是枚举类型，其控制图像的呈现模式：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>VK_PRESENT_MODE_IMMEDIATE_KHR</td>
<td>图像在提交后立即传输到屏幕</td>
<td>优点：延迟最低<br/>缺点：可能导致屏幕撕裂</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_FIFO_KHR</td>
<td>图像按照队列顺序呈现，显示器刷新时从队列前端取出图像，队列满时，程序会阻塞，等待空间。</td>
<td>优点：垂直同步，画面流畅，无撕裂<br/>缺点：可能导致延迟增加</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_FIFO_RELAXED_KHR</td>
<td>如果程序未及时提交图像（队列为空），新图像会立即传输到屏幕，而无需等待下一次显示器刷新。</td>
<td>优点：减少延迟<br/>缺点：可能导致撕裂</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_MAILBOX_KHR</td>
<td>如果队列已满，新图像会覆盖旧图像，而不是等待队列变为空</td>
<td>优点：三重缓冲，支持高帧率渲染，避免撕裂<br/>缺点：对性能要求较高</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR</td>
<td>在共享模式下，图像的显示由应用程序控制，只有在应用程序请求刷新时，显示器才会更新图像</td>
<td>适用于对显示刷新频率有特定需求的场景。</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</td>
<td>在共享模式下，显示器会持续刷新图像，而不需要应用程序的明确请求</td>
<td>适用于需要持续刷新显示的场景，例如动态内容或视频播放</td>
</tr>
<tr>
<td>VK_PRESENT_MODE_MAX_ENUM_KHR</td>
<td>表示枚举的最大值，通常用于验证或保留</td>
<td>实际使用中不会选择此值</td>
</tr>
</tbody></table>
<p>其中 <code>VK_PRESENT_MODE_FIFO_KHR</code> 是 Vulkan 保证支持的模式，其他模式的支持情况依赖于具体的硬件和驱动。为了最佳性能，在可用时，通常选择 <code>VK_PRESENT_MODE_MAILBOX_KHR</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkPresentModeKHR <span class="title">SwapChainManager::getPresentMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; presentMode : <span class="keyword">this</span>-&gt;presentModes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (presentMode == VK_PRESENT_MODE_MAILBOX_KHR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> presentMode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="创建与清理"><a href="#创建与清理" class="headerlink" title="创建与清理"></a>创建与清理</h1><p>在类中添加 <code>VkSwapchainKHR</code> 类型的成员变量用于存储创建的交换链，并添加 <code>createSwapChain</code> 成员函数来创建交换链：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkSwapchainKHR swapchain;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createSwapChain</span><span class="params">()</span></span>;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置交换链"><a href="#配置交换链" class="headerlink" title="配置交换链"></a>配置交换链</h2><p>使用结构体 <code>VkSwapchainCreateInfoKHR</code> 来描述一个交换链的创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSwapchainCreateInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkSwapchainCreateFlagsKHR        flags;</span><br><span class="line">    VkSurfaceKHR                     surface;</span><br><span class="line">    <span class="type">uint32_t</span>                         minImageCount;</span><br><span class="line">    VkFormat                         imageFormat;</span><br><span class="line">    VkColorSpaceKHR                  imageColorSpace;</span><br><span class="line">    VkExtent2D                       imageExtent;</span><br><span class="line">    <span class="type">uint32_t</span>                         imageArrayLayers;</span><br><span class="line">    VkImageUsageFlags                imageUsage;</span><br><span class="line">    VkSharingMode                    imageSharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>                         queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*                  pQueueFamilyIndices;</span><br><span class="line">    VkSurfaceTransformFlagBitsKHR    preTransform;</span><br><span class="line">    VkCompositeAlphaFlagBitsKHR      compositeAlpha;</span><br><span class="line">    VkPresentModeKHR                 presentMode;</span><br><span class="line">    VkBool32                         clipped;</span><br><span class="line">    VkSwapchainKHR                   oldSwapchain;</span><br><span class="line">&#125; VkSwapchainCreateInfoKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</code>。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>通常设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>交换链的创建标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>surface</td>
<td>窗口表面句柄</td>
<td>交换链所关联的窗口表面。</td>
</tr>
<tr>
<td>minImageCount</td>
<td>交换链中的最小图像数量</td>
<td>交换链至少会包含这些图像。</td>
</tr>
<tr>
<td>imageFormat</td>
<td>交换链中图像的像素格式</td>
<td>例如 <code>VK_FORMAT_B8G8R8A8_SRGB</code>。</td>
</tr>
<tr>
<td>imageColorSpace</td>
<td>图像的颜色空间</td>
<td>例如 <code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code>。</td>
</tr>
<tr>
<td>imageExtent</td>
<td>交换链中图像的分辨率</td>
<td>以像素为单位。</td>
</tr>
<tr>
<td>imageArrayLayers</td>
<td>每个图像的层数</td>
<td>通常为 <code>1</code>，除非用于立体3D应用。</td>
</tr>
<tr>
<td>imageUsage</td>
<td>指定图像的用途</td>
<td>例如 <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> 表示用于颜色附件，使得能够直接渲染图像到交换链中。</td>
</tr>
<tr>
<td>imageSharingMode</td>
<td>指定图像的共享模式</td>
<td><code>VK_SHARING_MODE_EXCLUSIVE</code>，独占模式，图像一次只能被一个队列族拥有，转移所有权需要显式进行，性能最佳；<br/><code>VK_SHARING_MODE_CONCURRENT</code>，并发模式，图像被多个队列族共享使用，无需显式进行所有权转移；<br/>如果图形队列族和呈现队列族相同，应该使用独占模式。</td>
</tr>
<tr>
<td>queueFamilyIndexCount</td>
<td>共享图像的队列族数量</td>
<td>在使用并发模式时起效</td>
</tr>
<tr>
<td>pQueueFamilyIndices</td>
<td>指向队列族索引的指针</td>
<td>指定哪些队列族可以访问图像。</td>
</tr>
<tr>
<td>preTransform</td>
<td>指定交换链中的图像需要进行的变换</td>
<td>例如旋转或翻转。</td>
</tr>
<tr>
<td>compositeAlpha</td>
<td>指定与窗口系统的 alpha 混合方式</td>
<td>例如 <code>VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</code>。</td>
</tr>
<tr>
<td>presentMode</td>
<td>指定交换链的呈现模式</td>
<td>例如 <code>VK_PRESENT_MODE_FIFO_KHR</code> 或 <code>VK_PRESENT_MODE_MAILBOX_KH</code>。</td>
</tr>
<tr>
<td>clipped</td>
<td>指定是否对被其他窗口遮挡的像素进行裁剪</td>
<td><code>VK_TRUE</code> 表示裁剪。在窗口被遮挡时，被遮挡像素的颜色将不可获取。</td>
</tr>
<tr>
<td>oldSwapchain</td>
<td>旧的交换链句柄</td>
<td>用于重建交换链时传入，首次创建时设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::createSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkSwapchainCreateInfoKHR createInfo&#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;</span><br><span class="line">    createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    createInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    createInfo.surface = pContentManager-&gt;surface;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> imageCount = <span class="keyword">this</span>-&gt;capabilities.minImageCount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;capabilities.maxImageCount &gt; <span class="number">0</span> &amp;&amp; imageCount &gt; <span class="keyword">this</span>-&gt;capabilities.maxImageCount)</span><br><span class="line">    &#123;</span><br><span class="line">        imageCount = <span class="keyword">this</span>-&gt;capabilities.maxImageCount;</span><br><span class="line">    &#125;</span><br><span class="line">    createInfo.minImageCount = imageCount;</span><br><span class="line"></span><br><span class="line">    VkSurfaceFormatKHR surfaceFormat = <span class="built_in">getFormat</span>();</span><br><span class="line">    createInfo.imageFormat = surfaceFormat.format;</span><br><span class="line">    createInfo.imageColorSpace = surfaceFormat.colorSpace;</span><br><span class="line"></span><br><span class="line">    VkExtent2D extent = <span class="built_in">getExtent</span>();</span><br><span class="line">    createInfo.imageExtent = extent;</span><br><span class="line"></span><br><span class="line">    createInfo.imageArrayLayers = <span class="number">1</span>;</span><br><span class="line">    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> queueFamilyIndices[] = &#123;pContentManager-&gt;graphicsFamily, pContentManager-&gt;presentFamily&#125;;</span><br><span class="line">    <span class="keyword">if</span> (pContentManager-&gt;graphicsFamily != pContentManager-&gt;presentFamily)</span><br><span class="line">    &#123;</span><br><span class="line">        createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;</span><br><span class="line">        createInfo.queueFamilyIndexCount = <span class="number">2</span>;</span><br><span class="line">        createInfo.pQueueFamilyIndices = queueFamilyIndices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">        createInfo.queueFamilyIndexCount = <span class="number">0</span>;</span><br><span class="line">        createInfo.pQueueFamilyIndices = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createInfo.preTransform = <span class="keyword">this</span>-&gt;capabilities.currentTransform;</span><br><span class="line">    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;</span><br><span class="line"></span><br><span class="line">    VkPresentModeKHR presentMode = <span class="built_in">getPresentMode</span>();</span><br><span class="line">    createInfo.presentMode = presentMode;</span><br><span class="line"></span><br><span class="line">    createInfo.clipped = VK_TRUE;</span><br><span class="line">    createInfo.oldSwapchain = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建交换链"><a href="#创建交换链" class="headerlink" title="创建交换链"></a>创建交换链</h2><p>然后调用 <code>vkCreateSwapchainKHR</code> 完成交换链的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSwapchainKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSwapchainCreateInfoKHR*             pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR*                             pSwapchain)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>Vulkan 逻辑设备的句柄</td>
<td>指定要创建交换链的的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>指向描述交换链创建信息的结构体指针</td>
<td>该结构体包含了交换链配置的详细信息，例如图像格式、分辨率等。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果应用程序需要对内存分配和释放进行控制，可实现自定义分配器并通过此参数传递。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSwapchain</td>
<td>交换链句柄指针</td>
<td>指向存储创建的交换链句柄的变量指针</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::createSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Create a swap chain */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateSwapchainKHR</span>(pContentManager-&gt;device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;swapChain) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create swap chain!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后在 <code>init</code> 函数中调用 <code>createSwapChain</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="built_in">createSwapChain</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理交换链"><a href="#清理交换链" class="headerlink" title="清理交换链"></a>清理交换链</h2><p>在不再使用交换链之后，需要通过 <code>vkDestroySwapchainKHR</code> 对于交换链进行销毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroySwapchainKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR                              swapchain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>Vulkan 逻辑设备的句柄</td>
<td>指定要销毁交换链的的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>swapchain</td>
<td>交换链句柄</td>
<td>要销毁的交换链的句柄。如果是 <code>VK_NULL_HANDLE</code>，函数将忽略并直接返回。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建交换链时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 函数中进行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="built_in">vkDestroySwapchainKHR</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;swapChain, <span class="literal">nullptr</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="交换链操作句柄"><a href="#交换链操作句柄" class="headerlink" title="交换链操作句柄"></a>交换链操作句柄</h1><p>在完成交换链的创建之后，需要从其中获取一些交换链的属性来为后续渲染做准备，主要涉及四项，交换链图像、交换链图像视图、交换链图像格式，交换链的布局：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkSwapchainKHR swapChain;</span><br><span class="line">	std::vector&lt;VkImage&gt; images;</span><br><span class="line">	std::vector&lt;VkImageView&gt; imageViews;</span><br><span class="line">	VkFormat format;</span><br><span class="line">	VkExtent2D extent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="交换链图像"><a href="#交换链图像" class="headerlink" title="交换链图像"></a>交换链图像</h2><p>通过函数 <code>vkGetSwapchainImagesKHR</code> 来获取交换链图像，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkGetSwapchainImagesKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR                              swapchain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pSwapchainImageCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage*                                    pSwapchainImages)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建获取交换链图像的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>swapchain</td>
<td>交换链句柄</td>
<td>指定要查询的交换链对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pSwapchainImageCount</td>
<td>交换链图像句柄数量</td>
<td>指向存储交换链图像数量的变量的指针。如果 <code>pSwapchainImages</code> 为 <code>nullptr</code>，则返回交换链中的图像数量；否则，返回实际写入的图像数量。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSwapchainImages</td>
<td>交换链图像句柄数组</td>
<td>指向存储交换链图像句柄数组的指针。如果为 <code>nullptr</code>，函数仅返回交换链中的图像数量。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示获取交换链图像是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示获取交换链图像创建成功，其他错误码表示创建失败。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::createSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the operation handle of the image in the swap chain */</span></span><br><span class="line">	<span class="built_in">vkGetSwapchainImagesKHR</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;swapChain, &amp;imageCount, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">this</span>-&gt;images.<span class="built_in">resize</span>(imageCount);</span><br><span class="line">	<span class="built_in">vkGetSwapchainImagesKHR</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;swapChain, &amp;imageCount, <span class="keyword">this</span>-&gt;images.<span class="built_in">data</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">this</span>-&gt;format = surfaceFormat.format;</span><br><span class="line">	<span class="keyword">this</span>-&gt;extent = extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="交换链图像视图"><a href="#交换链图像视图" class="headerlink" title="交换链图像视图"></a>交换链图像视图</h2><p>然后，使用图像视图创建函数来创建交换链图像的图像视图：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::createSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;imageViews.<span class="built_in">resize</span>(imageCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; imageCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;imageViews[i] = <span class="built_in">createView</span>(<span class="keyword">this</span>-&gt;images[i], <span class="keyword">this</span>-&gt;format, VK_IMAGE_ASPECT_COLOR_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理交换链操作句柄"><a href="#清理交换链操作句柄" class="headerlink" title="清理交换链操作句柄"></a>清理交换链操作句柄</h2><p>在清理交换链之前，从交换链上创建的图像会随着交换链的销毁而自动清理，所以只需要清理创建的图像视图对象，在 <code>clear</code> 函数中执行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; imageViews.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vkDestroyImageView</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;imageViews[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroySwapchainKHR</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;swapChain, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="交换链重建"><a href="#交换链重建" class="headerlink" title="交换链重建"></a>交换链重建</h1><p>在渲染过程中，某些事件会导致窗口表面发生变化，从而使得目前的交换链与其不再兼容。因此，需要捕捉这些事件并重新创建交换链。一个导致<strong>交换链重建</strong>的常见事件就是窗口大小改变。重新创建交换链的简单方法就是销毁交换链，然后再重新创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwapChainManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">recreate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap_chain_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapChainManager::recreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一种更符合实践的方法是在旧的交换链图像仍在被渲染的同时创建一个新的交换链。为此，需要在 <code>VkSwapchainCreateInfoKHR</code> 结构体的 <code>oldSwapchain</code> 字段中传入旧的交换链，并在完成对旧交换链的使用后立即销毁它。</p>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染通道</title>
    <url>/2025/03/20/Vulkan/7.%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过类 <code>RenderPassManager</code> 来管理渲染通道：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderPassManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RenderPassManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">RenderPassManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager,</span><br><span class="line">					  <span class="type">const</span> SwapChainManagerSPtr&amp; pSwapChainManager,</span><br><span class="line">					  <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	SwapChainManagerSPtr pSwapChainManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ContentManagerSPtr pContentManager;</span><br><span class="line">	CommandManagerSPtr pCommandManager;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;render_pass_manager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RenderPassManager::<span class="built_in">RenderPassManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager,</span><br><span class="line">									 <span class="type">const</span> SwapChainManagerSPtr&amp; pSwapChainManager,</span><br><span class="line">									 <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pSwapChainManager = pSwapChainManager;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pCommandManager = pCommandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><p>渲染通道和帧缓冲区通常需要一个深度附件，因此这里先初始化深度缓冲区，添加一个 <code>DepthImageManager</code> 类型的成员变量：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderPassManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DepthImageManager depthImageManager;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>并在 <code>init</code> 中初始化：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager = <span class="built_in">DepthImageManager</span>(<span class="keyword">this</span>-&gt;pContentManager, <span class="keyword">this</span>-&gt;pCommandManager);</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">setExtent</span>(pSwapChainManager-&gt;extent);</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>clear</code> 中清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="渲染通道"><a href="#渲染通道" class="headerlink" title="渲染通道"></a>渲染通道</h1><p>渲染通道的作用包括以下几点</p>
<ol>
<li>管理附件的生命周期：渲染通道明确指定了哪些附件（如颜色缓冲、深度缓冲）会被使用，以及它们的格式、加载&#x2F;存储操作等。是否需要清除附件内容，或者保留之前的数据。</li>
<li>定义子通道及其依赖关系：一个渲染通道可以包含多个子通道，每个子通道可以引用部分附件，并指定它们的用途（如颜色输出、深度测试输入等）。子通道之间可能存在依赖关系（如一个子通道需要等待另一个子通道完成对某个附件的写入），Vulkan 通过子通道依赖 显式同步这些操作。</li>
<li>优化渲染性能：通过合理设计子通道和依赖关系，Vulkan 驱动可以更好地利用 GPU 的 Tile-Based Rendering（在移动端 GPU 中常见）或内存带宽优化，避免不必要的内存读写。中间结果可以保留在片上内存（On-Chip Memory），而不必写回主存。</li>
<li>兼容帧缓冲：渲染通道需要与帧缓冲绑定，帧缓冲提供了实际的附件图像视图（Image Views）。渲染通道的附件描述必须与帧缓冲中的图像视图匹配。</li>
</ol>
<p>通过函数 <code>createRenderPass</code> 来创建一个渲染通道：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderPassManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkRenderPass renderPass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createRenderPass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="附件描述"><a href="#附件描述" class="headerlink" title="附件描述"></a>附件描述</h2><p>通过结构体 <code>VkAttachmentDescription</code>  来描述一个<strong>附件</strong>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAttachmentDescription</span> &#123;</span><br><span class="line">    VkAttachmentDescriptionFlags    flags;</span><br><span class="line">    VkFormat                        format;</span><br><span class="line">    VkSampleCountFlagBits           samples;</span><br><span class="line">    VkAttachmentLoadOp              loadOp;</span><br><span class="line">    VkAttachmentStoreOp             storeOp;</span><br><span class="line">    VkAttachmentLoadOp              stencilLoadOp;</span><br><span class="line">    VkAttachmentStoreOp             stencilStoreOp;</span><br><span class="line">    VkImageLayout                   initialLayout;</span><br><span class="line">    VkImageLayout                   finalLayout;</span><br><span class="line">&#125; VkAttachmentDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>flags</td>
<td>附件标志</td>
<td>这个字段用于指定附件的一些标志（Flags），它可以用来描述附件的一些特性，例如<code>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</code>表示该附件可能与其他附件重用同一块内存。</td>
</tr>
<tr>
<td>format</td>
<td>附件像素格式</td>
<td>该字段指定附件的像素格式。它描述了存储在附件中的数据类型和存储方式（如 <code>VK_FORMAT_R8G8B8A8_UNORM</code> 表示一个 8 位每通道的 RGBA 格式）。</td>
</tr>
<tr>
<td>samples</td>
<td>附件采样数量</td>
<td>值决定了每个像素所采集的样本数，通常用于控制抗锯齿的效果与性能之间的权衡，可用的值包括：<br /><code>VK_SAMPLE_COUNT_1_BIT</code>：不使用多重采样。<br /><code>VK_SAMPLE_COUNT_2_BIT </code>：每像素 <code>2</code> 重采样。<br /><code>VK_SAMPLE_COUNT_4_BIT </code>：每像素 <code>4</code> 重采样。<br /><code>VK_SAMPLE_COUNT_8_BIT </code>：每像素 <code>8</code> 重采样。<br /><code>VK_SAMPLE_COUNT_16_BIT </code>：每像素 <code>16</code> 重采样。<br /><code>VK_SAMPLE_COUNT_32_BIT </code>：每像素 <code>32</code> 重采样。<br /><code>VK_SAMPLE_COUNT_64_BIT </code>：每像素 <code>64</code> 重采样。<br /><code>VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>loadOp</td>
<td>附件加载操作</td>
<td>该字段指定如何加载附件的初始值，选项包括：<br/><code>VK_ATTACHMENT_LOAD_OP_LOAD</code>：在渲染开始时从附件中读取数据。<br/><code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>：在渲染开始时清除附件数据。<br/><code>VK_ATTACHMENT_LOAD_OP_DONT_CARE</code>：渲染开始时不关心附件的初始数据状态。<br/><code>VK_ATTACHMENT_LOAD_OP_NONE_KHR</code>：不对附件进行任何加载操作。<br/><code>VK_ATTACHMENT_LOAD_OP_NONE_EXT</code>：EXT扩展别名，同 <code>VK_ATTACHMENT_LOAD_OP_NONE_KHR</code>。<br/><code>VK_ATTACHMENT_LOAD_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>storeOp</td>
<td>附件存储操作</td>
<td>该字段指定渲染操作结束时对附件的处理方式，选项包括： <br/><code>VK_ATTACHMENT_STORE_OP_STORE</code>：将渲染结果写回到附件中。<br/><code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>：渲染结果不会被写回附件，可能用于不关心结果的场景。<br /><code>VK_ATTACHMENT_STORE_OP_NONE</code>：不对附件进行任何存储操作。<br/><code>VK_ATTACHMENT_STORE_OP_NONE_KHR</code>：KHR 扩展别名，同 <code>VK_ATTACHMENT_STORE_OP_NONE</code>。<br/><code>VK_ATTACHMENT_STORE_OP_NONE_QCOM</code>：QCOM 扩展别名，同 <code>VK_ATTACHMENT_STORE_OP_NONE</code>。<br/><code>VK_ATTACHMENT_STORE_OP_NONE_EXT</code>：EXT 扩展别名，同 <code>VK_ATTACHMENT_STORE_OP_NONE</code>。<br/><code>VK_ATTACHMENT_STORE_OP_MAX_ENUM</code>：保留值。<br/></td>
</tr>
<tr>
<td>stencilLoadOp</td>
<td>模版加载操作</td>
<td>该字段指定如何加载模板附件的初始值。选项与 <code>loadOp</code> 类似，但仅适用于模板缓冲。</td>
</tr>
<tr>
<td>stencilStoreOp</td>
<td>模版存储操作</td>
<td>xxxxxxxxxx &#x2F;&#x2F; image_manager.cppvoid DepthImageManager::clear(){    vkDestroyImage(pContentManager-&gt;device, this-&gt;image, nullptr);    vkFreeMemory(pContentManager-&gt;device, this-&gt;imageMemory, nullptr);    vkDestroyImageView(pContentManager-&gt;device, this-&gt;imageView, nullptr);}c++</td>
</tr>
<tr>
<td>initialLayout</td>
<td>初始图像布局</td>
<td>该字段指定附件在渲染通道开始前的初始图像布局。布局描述了图像或纹理的存储状态，常见的布局有：<br /><code>VK_IMAGE_LAYOUT_UNDEFINED</code>：图像没有有效数据。<br /><code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>：图像适合作为颜色附件进行渲染。<br /><code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>：图像适合作为深度&#x2F;模板附件进行渲染。</td>
</tr>
<tr>
<td>finalLayout</td>
<td>最终图像布局</td>
<td>该字段指定附件在渲染通道结束后的最终图像布局。此布局将影响附件的后续使用。例如：<br /><code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>：表示图像最终将用于交换链的呈现。<br /><code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>：图像将作为着色器资源读取。</td>
</tr>
</tbody></table>
<p>例如，渲染通道需要一个颜色附件来写入渲染得到的颜色，那个这个附件的格式应与交换链保持一致，而且需要在渲染之前执行清除操作，并在渲染之后存储渲染结果。同时，其布局应该由 <code>VK_IMAGE_LAYOUT_UNDEFINED</code> 转变为 <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> 来准备作为呈现源。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkAttachmentDescription colorAttachment&#123;&#125;;</span><br><span class="line">	colorAttachment.flags = <span class="number">0</span>;</span><br><span class="line">	colorAttachment.format = pSwapChainManager-&gt;format;</span><br><span class="line">	colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">	colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">	colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</span><br><span class="line">	colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">	colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">	colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">	colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此外，还需要在渲染通道里面包含深度附件，与颜色附件类似，由于深度图像通常不会被呈现，<code>storeOp</code> 可以设置为不关心 <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>，其最终布局应当为 <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> 来作为深度附件进行渲染：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	VkAttachmentDescription depthAttachment&#123;&#125;;</span><br><span class="line">	depthAttachment.flags = <span class="number">0</span>;</span><br><span class="line">	depthAttachment.format = depthImageManager.format;</span><br><span class="line">	depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">	depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">	depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">	depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">	depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">	depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">	depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="子通道和附件引用"><a href="#子通道和附件引用" class="headerlink" title="子通道和附件引用"></a>子通道和附件引用</h2><p><strong>子通道</strong>（Subpass）是 Vulkan 渲染通道中的一个重要概念，它允许在同一个渲染通道（Render Pass）中执行多个渲染操作。每个子通道都可以使用渲染通道中的附件（Attachments），并且这些子通道的渲染操作可以依赖于前一个子通道的输出。这为 Vulkan 提供了优化的机会，使得图形渲染更加高效。</p>
<p>在设置子通道之前，需要先设置附件引用，其由结构体 <code>VkAttachmentReference</code> 描述，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAttachmentReference</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>         attachment;</span><br><span class="line">    VkImageLayout    layout;</span><br><span class="line">&#125; VkAttachmentReference;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>attachment</td>
<td>附件索引</td>
<td>索引值，指向渲染通道的附件数组中的某个附件。该附件用于当前子通道的渲染操作。</td>
</tr>
<tr>
<td>layout</td>
<td>图像布局</td>
<td>该字段指定了附件在使用时的图像布局。图像布局决定了附件在内存中的组织方式，以及它如何与渲染通道中的其他操作交互。常见的布局值包括：<br/><code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>: 用于颜色附件（color attachment）的优化布局。<br/><code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>: 用于深度&#x2F;模板附件的优化布局。<br/><code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>: 用于着色器读取的布局。<br/><code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> &#x2F; <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>: 用于拷贝或传输操作时的布局。</td>
</tr>
</tbody></table>
<p>调用示例如下，分别为颜色附件和深度附件创建附件引用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	VkAttachmentReference colorAttachmentRef&#123;&#125;;</span><br><span class="line">	colorAttachmentRef.attachment = <span class="number">0</span>;</span><br><span class="line">	colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</span><br><span class="line"></span><br><span class="line">	VkAttachmentReference depthAttachmentRef&#123;&#125;;</span><br><span class="line">	depthAttachmentRef.attachment = <span class="number">1</span>;</span><br><span class="line">	depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这之后，可以通过 <code>VkSubpassDescription</code>来描述一个子通道，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubpassDescription</span> &#123;</span><br><span class="line">    VkSubpassDescriptionFlags       flags;</span><br><span class="line">    VkPipelineBindPoint             pipelineBindPoint;</span><br><span class="line">    <span class="type">uint32_t</span>                        inputAttachmentCount;</span><br><span class="line">    <span class="type">const</span> VkAttachmentReference*    pInputAttachments;</span><br><span class="line">    <span class="type">uint32_t</span>                        colorAttachmentCount;</span><br><span class="line">    <span class="type">const</span> VkAttachmentReference*    pColorAttachments;</span><br><span class="line">    <span class="type">const</span> VkAttachmentReference*    pResolveAttachments;</span><br><span class="line">    <span class="type">const</span> VkAttachmentReference*    pDepthStencilAttachment;</span><br><span class="line">    <span class="type">uint32_t</span>                        preserveAttachmentCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*                 pPreserveAttachments;</span><br><span class="line">&#125; VkSubpassDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>flags</td>
<td>子通道标志</td>
<td>设置子通道的标志，决定子通道的行为。例如，是否是一个独立的子通道等。</td>
</tr>
<tr>
<td>pipelineBindPoint</td>
<td>管线类型</td>
<td>指定与该子通道绑定的管线类型。常见的管线绑定点有 <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>（用于图形渲染）和 <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>（用于计算管线）。</td>
</tr>
<tr>
<td>inputAttachmentCount</td>
<td>输入附件数量</td>
<td>指定子通道使用的输入附件数量。输入附件是来自着色器中读取的，或者先前子通道的输出图像。</td>
</tr>
<tr>
<td>pInputAttachments</td>
<td>输入附件数组</td>
<td>指向 <code>VkAttachmentReference</code> 结构体的指针数组，描述每个输入附件的绑定信息（例如，附件的索引和布局）。</td>
</tr>
<tr>
<td>colorAttachmentCount</td>
<td>颜色附件数量</td>
<td>指定子通道所使用的颜色附件数量。</td>
</tr>
<tr>
<td>pColorAttachments</td>
<td>颜色附件数组</td>
<td>指向 <code>VkAttachmentReference</code> 结构体的指针数组，描述每个颜色附件的绑定信息。</td>
</tr>
<tr>
<td>pResolveAttachments</td>
<td>解决附件数组</td>
<td>指向 <code>VkAttachmentReference</code> 结构体的指针数组，描述每个解决附件的绑定信息。解决附件用于多重采样反走样操作。</td>
</tr>
<tr>
<td>pDepthStencilAttachment</td>
<td>深度&#x2F;模版附件数组</td>
<td>指向 <code>VkAttachmentReference</code> 结构体的指针，描述深度和&#x2F;或模板附件的绑定信息。</td>
</tr>
<tr>
<td>preserveAttachmentCount</td>
<td>保留附件数量</td>
<td>指定此子通道中保留附件的数量，保留附件不被修改。</td>
</tr>
<tr>
<td>pPreserveAttachments</td>
<td>保留附件索引数组</td>
<td>指向保留附件的索引数组，描述哪些附件在此子通道中不被修改，通常是一些不参与此次子通道渲染操作的附件。</td>
</tr>
</tbody></table>
<p>调用示例如下，在子通道中引用颜色和深度附件，并将子通道绑定到图形管线：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	VkSubpassDescription subpass&#123;&#125;;</span><br><span class="line">	subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</span><br><span class="line">	subpass.colorAttachmentCount = <span class="number">1</span>;</span><br><span class="line">	subpass.pColorAttachments = &amp;colorAttachmentRef;</span><br><span class="line">	subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="子通道依赖关系"><a href="#子通道依赖关系" class="headerlink" title="子通道依赖关系"></a>子通道依赖关系</h2><p>在一个渲染通道（render pass）中，子通道（subpasses）会自动处理图像布局转换。这些转换是通过 <strong>子通道依赖关系</strong> 来控制的，子通道依赖关系指定了子通道之间的内存和执行依赖。</p>
<p>子通道依赖关系通过结构体 <code>VkSubpassDependency</code> 来指定，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubpassDependency</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>                srcSubpass;</span><br><span class="line">    <span class="type">uint32_t</span>                dstSubpass;</span><br><span class="line">    VkPipelineStageFlags    srcStageMask;</span><br><span class="line">    VkPipelineStageFlags    dstStageMask;</span><br><span class="line">    VkAccessFlags           srcAccessMask;</span><br><span class="line">    VkAccessFlags           dstAccessMask;</span><br><span class="line">    VkDependencyFlags       dependencyFlags;</span><br><span class="line">&#125; VkSubpassDependency;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>srcSubpass</td>
<td>源子通道的索引</td>
<td>这个子通道将在依赖关系中作为“源”，即它会先执行。<br /><code>VK_SUBPASS_EXTERNAL</code> 表示外部子通道，通常用于指代渲染通道开始前的隐式子通道。</td>
</tr>
<tr>
<td>dstSubpass</td>
<td>目标子通道的索引</td>
<td>这个子通道将在依赖关系中作为“目标”，即它会在源子通道之后执行。<br /><code>VK_SUBPASS_EXTERNAL</code> 表示外部子通道，通常用于指代渲染通道结束后的隐式子通道。<br /><code>dstSubpass</code> 必须大于 <code>srcSubpass</code> 以避免出现循环依赖，除非 <code>srcSubpass</code> 或 <code>dstSubpass</code> 是 <code>VK_SUBPASS_EXTERNAL</code>。</td>
</tr>
<tr>
<td>srcStageMask</td>
<td>源子通道操作等待的管线阶段</td>
<td>指定源子通道的操作应该在哪些管线阶段<strong>等待</strong>执行。它是一个位掩码，表示所有需要等待的源阶段。例如，<code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> 表示颜色附件输出阶段。<br />如果源子通道中有多个操作，这个字段定义了哪些阶段必须完成才能继续执行目标子通道。</td>
</tr>
<tr>
<td>dstStageMask</td>
<td>目标子通道操作等待的管线阶段</td>
<td>指定目标子通道的操作在哪些管线阶段开始执行。它是一个位掩码，表示目标子通道中的哪些阶段可以执行，只有在源子通道依赖的阶段完成之后。<br />如果目标子通道的操作涉及到颜色附件的写入，可以使用 <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>。</td>
</tr>
<tr>
<td>srcAccessMask</td>
<td>源阶段中等待的内存访问类型</td>
<td>指定源阶段中应该等待哪些类型的内存访问。这是一个位掩码，表示所有相关的内存访问类型（如读取、写入等）。<br />如果源子通道涉及到颜色附件的写入，可以使用 <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>。</td>
</tr>
<tr>
<td>dstAccessMask</td>
<td>目标阶段中等待的内存访问类型</td>
<td>指定目标阶段中涉及的内存访问类型，表示哪些访问必须在源阶段完成之后才能开始。例如，如果目标子通道涉及读取颜色附件的内容，可以使用 <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code>。</td>
</tr>
<tr>
<td>dependencyFlags</td>
<td>设置依赖关系的标志</td>
<td>可选的值包括：<br /><code>0</code>：默认值。<br /><code>VK_DEPENDENCY_BY_REGION_BIT</code>：按区域控制依赖关系。<br/><code>VK_DEPENDENCY_DEVICE_GROUP_BIT</code>：跨设备的依赖关系，通常用于多GPU环境。<br/> <code>VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR</code>：前者的 KHR 扩展别名。<br/><code>VK_DEPENDENCY_VIEW_LOCAL_BIT</code>：局部视图依赖关系，适用于多个渲染目标时。<br/><code>VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR</code>：前者的 KHR 扩展别名。<br /><code>VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT</code>：表示一个反馈循环依赖，通常在图像或计算着色器中使用。<br/><code>VK_DEPENDENCY_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>调用示例如下，在渲染通道开始前的隐式子通道通常需要完成图像布局转换、附件清除、内存同步、交换链图像就绪、命令缓冲提交等操作。</p>
<p>在此处需要保证当前的子通道执行之前，颜色附件和深度附件的清除操作已经完成，可以写入，所以 <code>srcStageMask</code> 需要设置为 <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code>，Vulkan 规范允许对 <code>VK_SUBPASS_EXTERNAL</code> 的 <code>srcAccessMask</code> 设为 0，此时驱动会隐式处理外部操作的依赖关系。</p>
<p>此外，因为子通道需要向颜色附件和深度附件写入数据，需要设置 <code>dstStageMask</code> 为 <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> ，同时设置 <code>dstAccessMask</code> 为 <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code> 来表示颜色附件和深度附件的访问应在源阶段（附件清除）之后进行。深度图像首先在早期片段测试管道阶段访问，因为存在清除的加载操作，所以应该指定写入的访问掩码：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	VkSubpassDependency dependency&#123;&#125;;</span><br><span class="line">	dependency.srcSubpass = VK_SUBPASS_EXTERNAL;</span><br><span class="line">	dependency.dstSubpass = <span class="number">0</span>;</span><br><span class="line">	dependency.srcStageMask =</span><br><span class="line">		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;</span><br><span class="line">	dependency.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">	dependency.dstStageMask =</span><br><span class="line">		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;</span><br><span class="line">	dependency.dstAccessMask = </span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;</span><br><span class="line">	dependency.dependencyFlags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置渲染通道"><a href="#配置渲染通道" class="headerlink" title="配置渲染通道"></a>配置渲染通道</h2><p>在完成子通道、附件引用、子通道依赖关系的创建之后，就可以创建渲染通道了，通过结构体 <code>VkRenderPassCreateInfo</code> 就可以描述渲染通道，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRenderPassCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                   sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                       pNext;</span><br><span class="line">    VkRenderPassCreateFlags           flags;</span><br><span class="line">    <span class="type">uint32_t</span>                          attachmentCount;</span><br><span class="line">    <span class="type">const</span> VkAttachmentDescription*    pAttachments;</span><br><span class="line">    <span class="type">uint32_t</span>                          subpassCount;</span><br><span class="line">    <span class="type">const</span> VkSubpassDescription*       pSubpasses;</span><br><span class="line">    <span class="type">uint32_t</span>                          dependencyCount;</span><br><span class="line">    <span class="type">const</span> VkSubpassDependency*        pDependencies;</span><br><span class="line">&#125; VkRenderPassCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</code>，以表明这是一个渲染通道创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定图像视图创建时的附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>attachmentCount</td>
<td>附件数量</td>
<td>指明该渲染通道中附件的数量。附件是指在渲染通道中需要使用的图像（如颜色、深度、模板附件）。</td>
</tr>
<tr>
<td>pAttachments</td>
<td>附件数组</td>
<td>指向一个 <code>VkAttachmentDescription</code> 数组的指针，数组大小由 <code>attachmentCount</code> 指定。每个 <code>VkAttachmentDescription</code> 描述了一个附件的详细信息，如图像格式、操作、加载&#x2F;存储方式等。</td>
</tr>
<tr>
<td>subpassCount</td>
<td>子通道数量</td>
<td>指定渲染通道中包含多少个子通道。</td>
</tr>
<tr>
<td>pSubpasses</td>
<td>子通道数组</td>
<td>指向一个 <code>VkSubpassDescription</code> 数组的指针，数组大小由 <code>subpassCount</code> 指定。每个 <code>VkSubpassDescription</code> 描述了一个子通道的详细信息，包括附件引用、输入、输出等。</td>
</tr>
<tr>
<td>dependencyCount</td>
<td>依赖关系数量</td>
<td>指定渲染通道中依赖关系的数量。依赖关系用于描述一个子通道和另一个子通道之间的同步顺序。</td>
</tr>
<tr>
<td>pDependencies</td>
<td>依赖关系数组</td>
<td>指向一个 <code>VkSubpassDependency</code> 数组的指针，数组大小由 <code>dependencyCount</code> 指定。每个 <code>VkSubpassDependency</code> 描述了两个子通道之间的依赖关系，例如在渲染过程中哪个子通道需要等待另一个子通道完成。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;colorAttachment, depthAttachment&#125;;</span><br><span class="line">	VkRenderPassCreateInfo renderPassInfo&#123;&#125;;</span><br><span class="line">	renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;</span><br><span class="line">	renderPassInfo.attachmentCount = <span class="number">2</span>;</span><br><span class="line">	renderPassInfo.pAttachments = attachments.<span class="built_in">data</span>();</span><br><span class="line">	renderPassInfo.subpassCount = <span class="number">1</span>;</span><br><span class="line">	renderPassInfo.pSubpasses = &amp;subpass;</span><br><span class="line">	renderPassInfo.dependencyCount = <span class="number">1</span>;</span><br><span class="line">	renderPassInfo.pDependencies = &amp;dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建渲染通道"><a href="#创建渲染通道" class="headerlink" title="创建渲染通道"></a>创建渲染通道</h2><p>在这之后，需要通过函数 <code>vkCreateRenderPass</code> 完成渲染通道的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkRenderPassCreateInfo*               pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkRenderPass*                               pRenderPass)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>表示创建渲染通道的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>渲染通道创建信息结构体指针</td>
<td>该结构体包含有关渲染通道的详细信息（附件、子通道、依赖关系等）。这个结构体定义了渲染通道的配置。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pRenderPass</td>
<td>渲染通道句柄</td>
<td>指向 <code>VkRenderPass</code> 句柄的指针。在函数成功返回后，这个句柄将持有创建的渲染通道对象。该句柄用于在后续操作中引用该渲染通道。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示渲染通道是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示渲染通道创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createRenderPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateRenderPass</span>(pContentManager-&gt;device, &amp;renderPassInfo, <span class="literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create render pass!&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 函数中调用来执行创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="built_in">createRenderPass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理渲染通道"><a href="#清理渲染通道" class="headerlink" title="清理渲染通道"></a>清理渲染通道</h2><p>在渲染通道的使用完成之后，需要通过函数 <code>vkDestroyRenderPass</code> 来显示地销毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkRenderPass                                renderPass,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>表示要销毁渲染通道的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>renderPass</td>
<td>渲染通道句柄</td>
<td>要销毁的渲染通道句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建渲染通道时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 函数中进行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyRenderPass</span>(pContentManager-&gt;device, renderPass, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h1><p><strong>帧缓冲区</strong>是一个内存区域，用于存储渲染结果。在 Vulkan 中，帧缓冲区通常是一个包含多个图像附件（如颜色附件、深度附件、模板附件等）的对象，用来接收渲染操作的输出。帧缓冲区通过 <code>VkFramebuffer</code> 对象管理，一个 <code>VkFramebuffer</code> 对象引用了所有的用于表示附件的 <code>VkImageView</code> 对象。用于附件的图像依赖域从交换链中获取的图像，所以需要对于交换链中的所有图像创建帧缓冲区，并在绘制时使用对应的帧缓冲区对象。</p>
<p>创建一个辅助函数 <code>createFramebuffers</code> 来创建帧缓冲区，并添加相应的帧缓冲区对象：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderPassManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;VkFramebuffer&gt; framebuffers;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createFramebuffers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置帧缓冲区"><a href="#配置帧缓冲区" class="headerlink" title="配置帧缓冲区"></a>配置帧缓冲区</h2><p>通过 <code>VkFramebufferCreateInfo</code> 来描述帧缓冲区的创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkFramebufferCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext;</span><br><span class="line">    VkFramebufferCreateFlags    flags;</span><br><span class="line">    VkRenderPass                renderPass;</span><br><span class="line">    <span class="type">uint32_t</span>                    attachmentCount;</span><br><span class="line">    <span class="type">const</span> VkImageView*          pAttachments;</span><br><span class="line">    <span class="type">uint32_t</span>                    width;</span><br><span class="line">    <span class="type">uint32_t</span>                    height;</span><br><span class="line">    <span class="type">uint32_t</span>                    layers;</span><br><span class="line">&#125; VkFramebufferCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</code>，以表明这是一个<strong>帧缓冲区</strong>创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定图像视图创建时的附加标志</td>
<td>如果没有特殊需求，通常设置为 <code>0</code>，其他可能的值包括：<br/><code>VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT</code>：帧缓冲区将不会与图像直接关联。<br/><code>VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR</code>：Khronos 扩展版本，同<code>VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT</code> 。<br/><code>VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM </code>：保留值。</td>
</tr>
<tr>
<td>renderPass</td>
<td>渲染通道句柄</td>
<td>与帧缓冲区兼容的渲染通道对象。帧缓冲区只能与其兼容的渲染通道一起使用，<code>renderPass</code> 指定了一个渲染通道，该渲染通道定义了渲染过程中的附件和操作顺序。</td>
</tr>
<tr>
<td>attachmentCount</td>
<td>帧缓冲区中的附件数量</td>
<td>帧缓冲区中要绑定的图像附件的数量。</td>
</tr>
<tr>
<td>pAttachments</td>
<td>帧缓冲区中的附件数组</td>
<td>指向 <code>VkImageView</code> 数组的指针，每个 <code>VkImageView</code> 都代表一个帧缓冲区的附件。每个附件（如颜色附件、深度附件）都与渲染通道中的附件描述符匹配。图像视图是用来描述图像的数据格式和如何访问图像的方式。</td>
</tr>
<tr>
<td>width</td>
<td>帧缓冲区的宽度</td>
<td>定义了帧缓冲区的宽度（即渲染区域的宽度）。它应与渲染通道中的视口和图像的尺寸一致。以像素为单位，通常从交换链中直接获取。</td>
</tr>
<tr>
<td>height</td>
<td>帧缓冲区的高度</td>
<td>定义了帧缓冲区的高度（即渲染区域的高度）。它应与渲染通道中的视口和图像的尺寸一致。以像素为单位，通常从交换链中直接获取。</td>
</tr>
<tr>
<td>layers</td>
<td>帧缓冲区的层数</td>
<td>在 Vulkan 中，一个帧缓冲区可以由多个图像层（image layers）组成，这对于 3D 图像或立体渲染很重要。对于普通的 2D 渲染，通常该值为 <code>1</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createFramebuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;framebuffers.<span class="built_in">resize</span>(pSwapChainManager-&gt;imageViews.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pSwapChainManager-&gt;imageViews.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::array&lt;VkImageView, 2&gt; attachments = &#123;pSwapChainManager-&gt;imageViews[i], </span><br><span class="line">                                                  <span class="keyword">this</span>-&gt;depthImageManager.imageView&#125;;</span><br><span class="line"></span><br><span class="line">		VkFramebufferCreateInfo framebufferInfo&#123;&#125;;</span><br><span class="line">		framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;</span><br><span class="line">		framebufferInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		framebufferInfo.flags = <span class="number">0</span>;</span><br><span class="line">		framebufferInfo.renderPass = renderPass;</span><br><span class="line">		framebufferInfo.attachmentCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(attachments.<span class="built_in">size</span>());</span><br><span class="line">		framebufferInfo.pAttachments = attachments.<span class="built_in">data</span>();</span><br><span class="line">		framebufferInfo.width = pSwapChainManager-&gt;extent.width;</span><br><span class="line">		framebufferInfo.height = pSwapChainManager-&gt;extent.height;</span><br><span class="line">		framebufferInfo.layers = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建帧缓冲区"><a href="#创建帧缓冲区" class="headerlink" title="创建帧缓冲区"></a>创建帧缓冲区</h2><p>然后通过函数 <code>vkCreateFramebuffer</code> 来创建帧缓冲区，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateFramebuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFramebufferCreateInfo*              pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFramebuffer*                              pFramebuffer)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要创建帧缓冲区的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td><code>VkFramebufferCreateInfo</code> 结构体指针</td>
<td>指向一个 <code>VkFramebufferCreateInfo</code> 结构体的指针，该结构体包含了创建帧缓冲区所需的所有信息，如附件、尺寸等。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pFramebuffer</td>
<td>帧缓冲区对象的指针</td>
<td>指向返回创建的帧缓冲区对象的指针。创建成功后，该指针将指向新创建的帧缓冲区对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示帧缓冲区是否创建成功</td>
<td>返回值表示函数调用的结果，常见的值包括：<br /><code>VK_SUCCESS</code>：表示帧缓冲区创建成功。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：表示没有足够的主机内存来创建帧缓冲区。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：表示没有足够的设备内存来创建帧缓冲区。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::createFramebuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;framebuffers.<span class="built_in">resize</span>(pSwapChainManager-&gt;imageViews.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pSwapChainManager-&gt;imageViews.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		VkFramebufferCreateInfo framebufferInfo&#123;&#125;;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">vkCreateFramebuffer</span>(pContentManager-&gt;device, &amp;framebufferInfo, <span class="literal">nullptr</span>, &amp;framebuffers[i]) != VK_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create framebuffer!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 函数中调用来执行创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="built_in">createFramebuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理帧缓冲区"><a href="#清理帧缓冲区" class="headerlink" title="清理帧缓冲区"></a>清理帧缓冲区</h2><p>在帧缓冲区使用完毕时候，需要调用函数 <code>vkDestroyFramebuffer</code> 来销毁帧缓冲区，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyFramebuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFramebuffer                               framebuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>表示要销毁帧缓冲区的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>framebuffer</td>
<td>图形管线句柄</td>
<td>要销毁的帧缓冲区句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建帧缓冲区时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 函数中执行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> framebuffer : framebuffers)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vkDestroyFramebuffer</span>(pContentManager-&gt;device, framebuffer, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="重新创建帧缓冲区和深度图像"><a href="#重新创建帧缓冲区和深度图像" class="headerlink" title="重新创建帧缓冲区和深度图像"></a>重新创建帧缓冲区和深度图像</h1><p>在处理窗口大小变动时，除了重新创建交换链，还需要重新创建深度图像和帧缓冲区：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderPassManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">recreate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render_pass_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPassManager::recreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> framebuffer : framebuffers)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vkDestroyFramebuffer</span>(pContentManager-&gt;device, framebuffer, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">setExtent</span>(pSwapChainManager-&gt;extent);</span><br><span class="line">	<span class="keyword">this</span>-&gt;depthImageManager.<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">createFramebuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：由于交换链对象销毁后重新创建，其对应的共享指针也需要替换：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">swapChainManager.<span class="built_in">recreate</span>();</span><br><span class="line">renderPassManager.pSwapChainManager.<span class="built_in">swap</span>(std::<span class="built_in">make_shared</span>&lt;SwapChainManager&gt;(<span class="keyword">this</span>-&gt;swapChainManager));</span><br><span class="line">renderPassManager.<span class="built_in">recreate</span>();</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>深度缓冲区</title>
    <url>/2025/03/20/Vulkan/6.%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过类 <code>DepthImageManager</code> 来实现深度缓冲区的管理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepthImageManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DepthImageManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">DepthImageManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line">DepthImageManager::<span class="built_in">DepthImageManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager,</span><br><span class="line">									 <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pCommandManager = pCommandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="深度图像和视图"><a href="#深度图像和视图" class="headerlink" title="深度图像和视图"></a>深度图像和视图</h1><p>在 Vulkan 中，深度附件基于图像，因此使用深度缓冲区通常需要三种资源：图像、图像视图、设备内存：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepthImageManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkImage image;</span><br><span class="line">	VkDeviceMemory imageMemory;</span><br><span class="line">	VkImageView imageView;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>深度图像和颜色附件应该具有相同的分辨率，适合深度附件的图像用途，最佳平铺和设备内存。与颜色附件不同，深度图像只需要合理的精度即可，而不需要特定的格式，通常 <code>24</code> 位即可满足大部分程序的需求，符合要求的格式有，其中模板分量用于模板测试：</p>
<ul>
<li><code>VK_FORMAT_D32_SFLOAT</code>：32 位浮点数用于深度。</li>
<li><code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>：32 位有符号浮点数用于深度和 8 位模板分量。</li>
<li><code>VK_FORMAT_D24_UNORM_S8_UINT</code>：24 位浮点数用于深度和 8 位模板分量。</li>
</ul>
<blockquote>
<p>注意：默认情况下，GLM 生成的透视投影矩阵会使用 OpenGL 的深度范围 <code>-1.0</code> 到 <code>1.0</code>。需要通过定义宏 <code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code> 来配置它使用 Vulkan 的深度范围 <code>0.0</code> 到 <code>1.0</code>。</p>
</blockquote>
<h2 id="选择深度图像格式"><a href="#选择深度图像格式" class="headerlink" title="选择深度图像格式"></a>选择深度图像格式</h2><p>为了能够获取最佳格式，并在最佳格式不可用时自动选择可用格式，使用辅助函数 <code>findSupportedFormat</code> 来进行选择：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepthImageManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VkFormat format;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">VkFormat <span class="title">findSupportedFormat</span><span class="params">(<span class="type">const</span> std::vector&lt;VkFormat&gt;&amp; candidates)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过函数 <code>vkGetPhysicalDeviceFormatProperties</code> 能够查询物理设备对于图像格式的支持，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetPhysicalDeviceFormatProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice                            physicalDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFormat                                    format,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFormatProperties*                         pFormatProperties)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>physicalDevice</td>
<td>物理设备句柄</td>
<td>指定要查询格式属性的物理设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>format</td>
<td>图像格式句柄</td>
<td>指定要查询的图像格式。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pAllocator</td>
<td>格式属性指针</td>
<td>指向 <code>VkFormatProperties</code> 结构体的指针，用于存储查询到的格式属性。该结构体包含三个字段，分别表示格式在不同平铺模式下的支持特性：<br /><code>linearTilingFeatures</code>：指定格式在线性平铺模式（<code>VK_IMAGE_TILING_LINEAR</code>）下支持的特性。<br /><code>optimalTilingFeatures</code>：指定格式在最佳平铺模式（<code>VK_IMAGE_TILING_OPTIMAL</code>）下支持的特性。<br /><code>bufferFeatures</code>：指定格式在缓冲区（<code>VK_BUFFER_USAGE_*</code>）中支持的特性。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function">VkFormat <span class="title">DepthImageManager::findSupportedFormat</span><span class="params">(<span class="type">const</span> std::vector&lt;VkFormat&gt;&amp; candidates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (VkFormat format : candidates)</span><br><span class="line">	&#123;</span><br><span class="line">		VkFormatProperties props;</span><br><span class="line">		<span class="built_in">vkGetPhysicalDeviceFormatProperties</span>(pContentManager-&gt;physicalDevice, format, &amp;props);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((props.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) ==</span><br><span class="line">			VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;format = format;</span><br><span class="line">			<span class="keyword">return</span> format;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to find supported format!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建深度图像和视图"><a href="#创建深度图像和视图" class="headerlink" title="创建深度图像和视图"></a>创建深度图像和视图</h2><p>依次查询 <code>VK_FORMAT_D32_SFLOAT</code>，<code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>， <code>VK_FORMAT_D24_UNORM_S8_UINT</code> 是否可用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthImageManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkFormat depthFormat = <span class="built_in">findSupportedFormat</span>(&#123;VK_FORMAT_D32_SFLOAT, </span><br><span class="line">                                                VK_FORMAT_D32_SFLOAT_S8_UINT, </span><br><span class="line">                                                VK_FORMAT_D24_UNORM_S8_UINT&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，调用辅助函数来创建深度图像和深度图像视图：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthImageManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">createImage</span>(<span class="keyword">this</span>-&gt;extent,</span><br><span class="line">				depthFormat,</span><br><span class="line">				VK_IMAGE_TILING_OPTIMAL,</span><br><span class="line">				VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,</span><br><span class="line">				VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span><br><span class="line">				<span class="keyword">this</span>-&gt;image,</span><br><span class="line">				<span class="keyword">this</span>-&gt;imageMemory);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">this</span>-&gt;imageView = <span class="built_in">createView</span>(<span class="keyword">this</span>-&gt;image, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="深度图像布局转换"><a href="#深度图像布局转换" class="headerlink" title="深度图像布局转换"></a>深度图像布局转换</h2><p>在深度图像创建之后，需要将其布局由未定义 <code>VK_IMAGE_LAYOUT_UNDEFINED</code> 转换为最佳深度模版附件 <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> 来获取最佳性能，需要扩展辅助函数 <code>transitionImageLayout</code> 来实现，在转换函数中确定屏障的子资源范围：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitionImageLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkImageMemoryBarrier barrier&#123;&#125;;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)</span><br><span class="line">	&#123;</span><br><span class="line">		barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT)</span><br><span class="line">		&#123;</span><br><span class="line">			barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>深度缓冲区将被读取以执行深度测试，以查看片段是否可见，并在绘制新片段时写入。读取发生在 <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> 阶段，写入发生在 <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code> 阶段：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitionImageLayout</span><span class="params">(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp;</span><br><span class="line">        newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)</span><br><span class="line">	&#123;</span><br><span class="line">    	barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    	barrier.dstAccessMask = </span><br><span class="line">            VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;</span><br><span class="line"></span><br><span class="line">    	sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;</span><br><span class="line">    	destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，进行深度图像的布局转换：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthImageManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">transformLayout</span>(<span class="keyword">this</span>-&gt;image, </span><br><span class="line">                    depthFormat, </span><br><span class="line">                    VK_IMAGE_LAYOUT_UNDEFINED, </span><br><span class="line">                    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理深度图像和视图"><a href="#清理深度图像和视图" class="headerlink" title="清理深度图像和视图"></a>清理深度图像和视图</h2><p>在 <code>clear</code> 函数中执行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// image_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthImageManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyImage</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;image, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">vkFreeMemory</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;imageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">vkDestroyImageView</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;imageView, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>着色器模型</title>
    <url>/2025/03/20/Vulkan/8.%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>通过类 &#96;&#96; 来实现着色器字节码的加载和着色器模型的创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ShaderManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">ShaderManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setShaderName</span><span class="params">(<span class="type">const</span> std::string&amp; shaderName)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ContentManagerSPtr pContentManager;</span><br><span class="line">	std::string shaderName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shader_manager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ShaderManager::<span class="built_in">ShaderManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::setShaderName</span><span class="params">(<span class="type">const</span> std::string&amp; shaderName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;shaderName = shaderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="着色器代码编译"><a href="#着色器代码编译" class="headerlink" title="着色器代码编译"></a>着色器代码编译</h1><p>使用 Cmake 的 <code>add_custom_command</code> 功能来实现着色器代码的自动编译，一个示例如下：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(ShaderCompilation)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Vulkan REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Vulkan include dirs: $&#123;Vulkan_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Vulkan lib dirs: $&#123;Vulkan_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(VULKAN_BIN_DIR <span class="string">&quot;$&#123;Vulkan_INCLUDE_DIRS&#125;/../Bin&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Vulkan SDK Bin Directory: $&#123;VULKAN_BIN_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SHADER_COMPILING <span class="string">&quot;$&#123;VULKAN_BIN_DIR&#125;/glslc.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Supported shader types</span></span><br><span class="line"><span class="keyword">set</span>(SHADER_EXTS <span class="string">&quot;vert&quot;</span> <span class="string">&quot;frag&quot;</span> <span class="string">&quot;geom&quot;</span> <span class="string">&quot;comp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store all .spv output files</span></span><br><span class="line"><span class="keyword">set</span>(SPV_FILES <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over all shader types</span></span><br><span class="line"><span class="keyword">foreach</span>(EXT <span class="variable">$&#123;SHADER_EXTS&#125;</span>)</span><br><span class="line">	<span class="keyword">file</span>(GLOB SHADERS <span class="string">&quot;*.$&#123;EXT&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">foreach</span>(SHADER <span class="variable">$&#123;SHADERS&#125;</span>)</span><br><span class="line">		<span class="keyword">get_filename_component</span>(SHADER_NAME <span class="variable">$&#123;SHADER&#125;</span> NAME_WE)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Generates a file name in the format _ext.spv</span></span><br><span class="line">		<span class="keyword">set</span>(SPV_OUTPUT <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/shaders/$&#123;SHADER_NAME&#125;_$&#123;EXT&#125;.spv&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">add_custom_command</span>(</span><br><span class="line">			OUTPUT <span class="variable">$&#123;SPV_OUTPUT&#125;</span></span><br><span class="line">			<span class="keyword">COMMAND</span> <span class="variable">$&#123;SHADER_COMPILING&#125;</span> -O --<span class="keyword">target</span>-env=vulkan1.<span class="number">3</span> <span class="variable">$&#123;SHADER&#125;</span> -o <span class="variable">$&#123;SPV_OUTPUT&#125;</span></span><br><span class="line">			DEPENDS <span class="variable">$&#123;SHADER&#125;</span></span><br><span class="line">			COMMENT <span class="string">&quot;Compiling $&#123;SHADER&#125; to $&#123;SPV_OUTPUT&#125;&quot;</span></span><br><span class="line">			VERBATIM</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">list</span>(APPEND SPV_FILES <span class="variable">$&#123;SPV_OUTPUT&#125;</span>)</span><br><span class="line">	<span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create CMake targets to use all SPV files as build targets</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(CompileShaders ALL DEPENDS <span class="variable">$&#123;SPV_FILES&#125;</span>)</span><br></pre></td></tr></table></figure></div>

<p>同时设置字节码的生成目录宏：</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(VulkanManager PRIVATE SHADERS_DIR=<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/shaders/&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="加载字节码"><a href="#加载字节码" class="headerlink" title="加载字节码"></a>加载字节码</h1><p>此处实现一个辅助函数来完成字节码的加载：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">loadShaderCode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;<span class="type">char</span>&gt; code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::loadShaderCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Read the file from the end to get the file size */</span></span><br><span class="line">	<span class="function">std::ifstream <span class="title">file</span><span class="params">(std::string(SHADERS_DIR) + <span class="keyword">this</span>-&gt;shaderName, std::ios::ate | std::ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!file.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open shader file!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> fileSize = (<span class="type">size_t</span>)file.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Apply for buffer */</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;code.<span class="built_in">resize</span>(fileSize);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read file contents */</span></span><br><span class="line">	file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">	file.<span class="built_in">read</span>(<span class="keyword">this</span>-&gt;code.<span class="built_in">data</span>(), fileSize);</span><br><span class="line"></span><br><span class="line">	file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="着色器模型"><a href="#着色器模型" class="headerlink" title="着色器模型"></a>着色器模型</h1><p>在类中添加 <code>VkShaderModule</code> 类型的变量来储存着色器模型：</p>
<p>&#96;通过类 &#96;&#96; 来实现着色器字节码的加载和着色器模型的创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkShaderModule <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createShaderModule</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置着色器模型"><a href="#配置着色器模型" class="headerlink" title="配置着色器模型"></a>配置着色器模型</h2><p>通过结构体 <code>VkShaderModuleCreateInfo </code> 来描述一个着色模型的信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkShaderModuleCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType              sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                  pNext;</span><br><span class="line">    VkShaderModuleCreateFlags    flags;</span><br><span class="line">    <span class="type">size_t</span>                       codeSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*              pCode;</span><br><span class="line">&#125; VkShaderModuleCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</code>，以表明这是一个着色器模块创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定着色器模块创建时的附加标志</td>
<td>目前没有任何标志定义，应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>codeSize</td>
<td>着色器代码的字节大小</td>
<td>指明 SPIR-V 字节码的大小。</td>
</tr>
<tr>
<td>pCode</td>
<td>指向着色器代码的指针</td>
<td>SPIR-V 编译后的字节码数组。这个字节码是用来描述着色器程序的，在加载时，Vulkan 会把这个字节码编译成 GPU 可执行的程序。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::createShaderModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkShaderModuleCreateInfo createInfo&#123;&#125;;</span><br><span class="line">	createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;</span><br><span class="line">	createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	createInfo.flags = <span class="number">0</span>;</span><br><span class="line">	createInfo.codeSize = <span class="keyword">this</span>-&gt;code.<span class="built_in">size</span>();</span><br><span class="line">	createInfo.pCode = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint32_t</span>*&gt;(code.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建着色器模型"><a href="#创建着色器模型" class="headerlink" title="创建着色器模型"></a>创建着色器模型</h2><p>通过函数 <code>vkCreateShaderModule</code>来创建着色器模块，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateShaderModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkShaderModuleCreateInfo*             pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkShaderModule*                             pShaderModule)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>创建着色器模块的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td><code>VkShaderModuleCreateInfo</code> 结构体的指针</td>
<td>结构体包含着色器模块的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>内存分配器回调指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pShaderModule</td>
<td>着色器模块句柄</td>
<td>接收创建的 <code>VkShaderModule</code> 对象的句柄。如果创建成功，将返回一个有效的 <code>VkShaderModule</code> 句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>返回函数执行的结果</td>
<td>如果创建成功，将返回 <code>VK_SUCCESS</code>，如果失败，将返回一个表示错误的代码。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::createShaderModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateShaderModule</span>(pContentManager-&gt;device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;<span class="keyword">module</span>) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create shader module!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;code.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 函数中创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">loadShaderCode</span>();</span><br><span class="line">	<span class="built_in">createShaderModule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理着色器模型"><a href="#清理着色器模型" class="headerlink" title="清理着色器模型"></a>清理着色器模型</h2><p>在着色器模型使用完毕之后，需要使用 <code>vkDestroyShaderModule</code>销毁着色器模块，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyShaderModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkShaderModule                              shaderModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>需要销毁着色器模块的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>shaderModule</td>
<td>着色器模块句柄</td>
<td>需要销毁的着色器模块句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>内存分配器回调指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建着色器模块时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>注意：SPIR-V 字节码的编译和链接到机器代码（供 GPU 执行）直到图形管线创建时才发生。这意味着，在图形管线创建完成之后，就可以销毁着色器模块。</p>
<p>在 <code>clear</code> 函数中清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shader_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyShaderModule</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;<span class="keyword">module</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>顶点着色器对于输入的每个顶点进行处理，其输入的是每个顶点的属性，包括<strong>坐标</strong>、<strong>颜色</strong>、<strong>法向量</strong>、<strong>纹理坐标</strong>。顶点着色器对于顶点的属性进行处理，并将处理之后的结果传递给片段着色器进行进一步的处理。在顶点着色器中的一个重要的处理是对于顶点<strong>坐标</strong>的<strong>归一化</strong>，并生成齐次坐标。一个例子如下：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">    <span class="type">mat4</span> proj;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> inTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">    fragTexCoord = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>由顶点着色器中的位置形成的三角形会在屏幕上填充一个区域，生成多个片段。片段着色器会对这些片段进行处理，为帧缓冲区（或多个帧缓冲区）产生颜色和深度。一个例子如下：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> texSampler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() </span><br><span class="line">&#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, fragTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>纹理</title>
    <url>/2025/03/20/Vulkan/10.%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>使用类 <code>TextureManager</code> 来进行纹理的管理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextureManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TextureManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">TextureManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; commandManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;TextureManager&gt; TextureManagerSPtr;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;texture_manager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TextureManager::<span class="built_in">TextureManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pCommandManager = pCommandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="纹理图像"><a href="#纹理图像" class="headerlink" title="纹理图像"></a>纹理图像</h1><p>通过函数 <code>createTexture</code> 来实现纹理的创建，由于一个场景的纹理图像可能不止一个，此处的图像资源对象使用数组管理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextureManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createTexture</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;VkImage&gt; images;</span><br><span class="line">	std::vector&lt;VkDeviceMemory&gt; imageMemories;</span><br><span class="line">	std::vector&lt;VkImageView&gt; imageViews;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建纹理图像"><a href="#创建纹理图像" class="headerlink" title="创建纹理图像"></a>创建纹理图像</h2><p>创建纹理图像和图像视图只需要利用图像管理器中的辅助函数，注意设置布局为 <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::createTexture</span><span class="params">(<span class="type">const</span> std::string&amp; imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkImage image;</span><br><span class="line">	VkDeviceMemory imageMemory;</span><br><span class="line">	VkImageView imageView;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">loadImage</span>(imagePath, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, image, imageMemory);</span><br><span class="line">	imageView = <span class="built_in">createView</span>(image, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;images.<span class="built_in">push_back</span>(image);</span><br><span class="line">	<span class="keyword">this</span>-&gt;imageMemories.<span class="built_in">push_back</span>(imageMemory);</span><br><span class="line">	<span class="keyword">this</span>-&gt;imageViews.<span class="built_in">push_back</span>(imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理纹理图像"><a href="#清理纹理图像" class="headerlink" title="清理纹理图像"></a>清理纹理图像</h2><p>在 <code>clear</code> 函数中清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; imageView : <span class="keyword">this</span>-&gt;imageViews)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vkDestroyImageView</span>(pContentManager-&gt;device, imageView, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; image : <span class="keyword">this</span>-&gt;images)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vkDestroyImage</span>(pContentManager-&gt;device, image, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; imageMemory : <span class="keyword">this</span>-&gt;imageMemories)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vkFreeMemory</span>(pContentManager-&gt;device, imageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="图像采样器"><a href="#图像采样器" class="headerlink" title="图像采样器"></a>图像采样器</h1><p>添加一个函数来完成图像采样器的创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextureManager</span> : <span class="keyword">public</span> ImageManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createSampler</span><span class="params">()</span></span>;</span><br><span class="line">	VkSampler sampler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置图像采样器"><a href="#配置图像采样器" class="headerlink" title="配置图像采样器"></a>配置图像采样器</h2><p>着色器可以直接从图像中读取纹素，但当图像用作纹理时，这种方式并不常见。纹理通常通过采样器（sampler）访问，来解决过采样和欠采样的问题。通过结构体 <code>VkSamplerCreateInfo</code> 来配置一个采样器，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSamplerCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkSamplerCreateFlags    flags;</span><br><span class="line">    VkFilter                magFilter;</span><br><span class="line">    VkFilter                minFilter;</span><br><span class="line">    VkSamplerMipmapMode     mipmapMode;</span><br><span class="line">    VkSamplerAddressMode    addressModeU;</span><br><span class="line">    VkSamplerAddressMode    addressModeV;</span><br><span class="line">    VkSamplerAddressMode    addressModeW;</span><br><span class="line">    <span class="type">float</span>                   mipLodBias;</span><br><span class="line">    VkBool32                anisotropyEnable;</span><br><span class="line">    <span class="type">float</span>                   maxAnisotropy;</span><br><span class="line">    VkBool32                compareEnable;</span><br><span class="line">    VkCompareOp             compareOp;</span><br><span class="line">    <span class="type">float</span>                   minLod;</span><br><span class="line">    <span class="type">float</span>                   maxLod;</span><br><span class="line">    VkBorderColor           borderColor;</span><br><span class="line">    VkBool32                unnormalizedCoordinates;</span><br><span class="line">&#125; VkSamplerCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</code>，以表明这是一个采样器创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>创建采样器的附加标志</td>
<td>通常设置为 <code>0</code>，可选值包括：<br /><code>VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT</code>：指定采样器用于子采样（subsampled）图像。需要设备支持 <code>VK_EXT_fragment_density_map</code> 扩展。<br /><code>VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT</code>：指定采样器用于子采样图像的粗重建（coarse reconstruction）。该标志与 <code>VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT</code> 一起使用，用于优化子采样图像的重建过程。需要设备支持 <code>VK_EXT_fragment_density_map</code> 扩展。<br /><code>VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT</code>：指定采样器支持描述符缓冲区的捕获和回放（capture and replay）。需要设备支持 <code>VK_EXT_descriptor_buffer</code> 扩展。<br /><code>VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT</code>：指定立方体贴图（cube map）采样时不使用无缝过滤（non-seamless filtering）。需要设备支持 <code>VK_EXT_non_seamless_cube_map</code> 扩展。<br /><code>VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM</code>：该标志用于高通（Qualcomm）设备的图像处理功能。需要设备支持 <code>VK_QCOM_image_processing</code> 扩展。</td>
</tr>
<tr>
<td>magFilter</td>
<td>放大过滤模式</td>
<td>指定放大过滤模式，即当纹理被放大时如何插值纹素。可选值包括：<br /><code>VK_FILTER_NEAREST</code>: 使用最近邻插值。<br /><code>VK_FILTER_LINEAR</code>: 使用线性插值。<br /><code>VK_FILTER_CUBIC_EXT</code>：使用双三次插值，需要  <code>VK_EXT_filter_cubic</code> 扩展。<br /><code>VK_FILTER_CUBIC_IMG</code>：使用双三次插值，需要 <code>VK_IMG_filter_cubic</code> 扩展（旧扩展别名）。</td>
</tr>
<tr>
<td>minFilter</td>
<td>缩小过滤模式</td>
<td>指定缩小过滤模式，即当纹理被缩小时如何插值纹素。可选值同 <code>magFilter</code>。</td>
</tr>
<tr>
<td>mipmapMode</td>
<td>多级渐远纹理过滤模式</td>
<td>指定多级渐远纹理（mipmap）的过滤模式，可选值包括：<br /><code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code>: 使用最接近的 mipmap 层级。<br /><code>VK_SAMPLER_MIPMAP_MODE_LINEAR</code>: 在 mipmap 层级之间进行线性插值。</td>
</tr>
<tr>
<td>addressModeU</td>
<td>U 轴寻址模式</td>
<td>指定 U 轴（纹理坐标的 X 轴）的寻址模式，通常用于平铺纹理（例如地板，墙壁），可选值包括：<br /><code>VK_SAMPLER_ADDRESS_MODE_REPEAT</code>: 重复纹理。<br /><code>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT</code>: 镜像重复纹理。<br /><code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code>: 使用边缘颜色。<br /><code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code>: 使用指定的边框颜色。<br /><code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code>: 镜像并使用边缘颜色。<br /><code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR</code>：<code>KHR</code> 兼容性别名与 <code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code> 相同。</td>
</tr>
<tr>
<td>addressModeV</td>
<td>V 轴寻址模式</td>
<td>指定 V 轴（纹理坐标的 Y 轴）的寻址模式，可选值同 <code>addressModeU</code>。</td>
</tr>
<tr>
<td>addressModeW</td>
<td>W 轴寻址模式</td>
<td>指定 W 轴（纹理坐标的 Z 轴）的寻址模式，可选值同 <code>addressModeU</code>。</td>
</tr>
<tr>
<td>mipLodBias</td>
<td>mipmap 层级偏移量</td>
<td>指定 mipmap 层级偏移量（LOD bias），用于调整 mipmap 层级的选择。</td>
</tr>
<tr>
<td>anisotropyEnable</td>
<td>是否启用各向异性过滤</td>
<td>各向异性过滤可以提高纹理在倾斜角度下的质量。</td>
</tr>
<tr>
<td>maxAnisotropy</td>
<td>各向异性过滤最大采样数</td>
<td>指定各向异性过滤的最大采样数。该值通常从物理设备属性中获取：<code>VkPhysicalDeviceProperties::limits.maxSamplerAnisotropy</code></td>
</tr>
<tr>
<td>compareEnable</td>
<td>是否启用比较操作</td>
<td>指定是否启用比较操作，如果启用，采样器将使用比较操作来过滤纹素，主要用于阴影映射的百分比接近过滤（percentage-closer filtering）。</td>
</tr>
<tr>
<td>compareOp</td>
<td>比较操作的类型</td>
<td>指定比较操作的类型，仅在 <code>compareEnable</code> 为 <code>VK_TRUE</code> 时有效，可选值包括：<br /><code>VK_COMPARE_OP_NEVER</code>：永远失败。<br/><code>VK_COMPARE_OP_LESS</code>：片段深度小于当前深度时通过。<br/><code>VK_COMPARE_OP_EQUAL</code>：片段深度等于当前深度时通过。<br/><code>VK_COMPARE_OP_LESS_OR_EQUAL</code>：片段深度小于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER</code>：片段深度大于当前深度时通过。<br/><code>VK_COMPARE_OP_NOT_EQUAL</code>：片段深度不等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER_OR_EQUAL</code>：片段深度大于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_ALWAYS</code>：永远通过。<br/></td>
</tr>
<tr>
<td>minLod</td>
<td>最小 mipmap 层级</td>
<td>指定最小 mipmap 层级（LOD）。</td>
</tr>
<tr>
<td>maxLod</td>
<td>最大 mipmap 层级</td>
<td>指定最大 mipmap 层级（LOD）。</td>
</tr>
<tr>
<td>borderColor</td>
<td>边框颜色</td>
<td>指定边框颜色，当寻址模式为 <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code> 时启用，可能的值包括：<br /><code>VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK</code>: 透明黑色（浮点格式）。<br /><code>VK_BORDER_COLOR_INT_TRANSPARENT_BLACK</code>: 透明黑色（整数格式）。<br /><code>VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK</code>: 不透明黑色（浮点格式）。<br /><code>VK_BORDER_COLOR_INT_OPAQUE_BLACK</code>: 不透明黑色（整数格式）。<br /><code>VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE</code>: 不透明白色（浮点格式）。<br /><code>VK_BORDER_COLOR_INT_OPAQUE_WHITE</code>: 不透明白色（整数格式）。<br /><code>VK_BORDER_COLOR_FLOAT_CUSTOM_EXT</code>：自定义边框颜色（浮点格式），需要 <code>VK_EXT_custom_border_color</code> 扩展，颜色通过  <code>VkSamplerCustomBorderColorCreateInfoEXT</code> 设置。<br /><code>VK_BORDER_COLOR_INT_CUSTOM_EXT</code>：自定义边框颜色（整数格式），需要 <code>VK_EXT_custom_border_color</code> 扩展，颜色通过  <code>VkSamplerCustomBorderColorCreateInfoEXT</code> 设置。</td>
</tr>
<tr>
<td>unnormalizedCoordinates</td>
<td>是否使用非归一化纹理坐标</td>
<td>指定是否使用非归一化纹理坐标，如果为 <code>VK_TRUE</code>，则纹理坐标范围为 <code>[0, texWidth)</code> 和 <code>[0, texHeight)</code>；如果为 <code>VK_FALSE</code>，则范围为 <code>[0, 1)</code>。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// texture_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::createSampler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkPhysicalDeviceProperties properties&#123;&#125;;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceProperties</span>(pContentManager-&gt;physicalDevice, &amp;properties);</span><br><span class="line"></span><br><span class="line">	VkSamplerCreateInfo samplerInfo&#123;&#125;;</span><br><span class="line">	samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;</span><br><span class="line">	samplerInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	samplerInfo.flags = <span class="number">0</span>;</span><br><span class="line">	samplerInfo.magFilter = VK_FILTER_LINEAR;</span><br><span class="line">	samplerInfo.minFilter = VK_FILTER_LINEAR;</span><br><span class="line">	samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;</span><br><span class="line">	samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">	samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">	samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">	samplerInfo.mipLodBias = <span class="number">0.0f</span>;</span><br><span class="line">	samplerInfo.anisotropyEnable = VK_TRUE;</span><br><span class="line">	samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;</span><br><span class="line">	samplerInfo.compareEnable = VK_FALSE;</span><br><span class="line">	samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;</span><br><span class="line">	samplerInfo.minLod = <span class="number">0.0f</span>;</span><br><span class="line">	samplerInfo.maxLod = <span class="number">0.0f</span>;</span><br><span class="line">	samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;</span><br><span class="line">	samplerInfo.unnormalizedCoordinates = VK_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：各向异性是一个可选的设备特性，需要检查当前的物理设备是否支持，这里扩展 <code>ContentManager::isDeviceSuitable</code> 函数：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ContentManager::isDeviceSuitable</span><span class="params">(VkPhysicalDevice physicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	VkPhysicalDeviceFeatures supportedFeatures;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceFeatures</span>(physicalDevice, &amp;supportedFeatures);</span><br><span class="line">	<span class="keyword">if</span> (!supportedFeatures.samplerAnisotropy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>同时，在创建逻辑设备时，请求这个设备特性：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentManager::createLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	VkPhysicalDeviceFeatures deviceFeatures&#123;&#125;;</span><br><span class="line">	deviceFeatures.samplerAnisotropy = VK_TRUE;</span><br><span class="line"></span><br><span class="line">	VkDeviceCreateInfo createInfo&#123;&#125;;</span><br><span class="line">	...</span><br><span class="line">	createInfo.pEnabledFeatures = &amp;deviceFeatures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建图像采样器"><a href="#创建图像采样器" class="headerlink" title="创建图像采样器"></a>创建图像采样器</h2><p>然后调用函数 <code>vkCreateSampler</code> 来创建采样器，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSampler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSamplerCreateInfo*                  pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSampler*                                  pSampler)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建采样器的逻辑设备，采样器与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>xxxxxxxxxx #version 450​layout(location &#x3D; 0) in vec3 fragColor;layout(location &#x3D; 1) in vec2 fragTexCoord;​layout(location &#x3D; 0) out vec4 outColor;​layout(binding &#x3D; 1) uniform sampler2D texSampler;​void main() {    outColor &#x3D; texture(texSampler, fragTexCoord);}glsl</td>
<td>采样器创建信息指针</td>
<td><code>VkSamplerCreateInfo</code> 结构体的指针，包含采样器的配置信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSampler</td>
<td>采样器句柄指针</td>
<td>指向 <code>VkSampler</code> 变量的指针，存储创建的采样器句柄。函数执行成功后，该变量将持有新创建的采样器对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示采样器是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示采样器创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::createSampler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateSampler</span>(pContentManager-&gt;device, &amp;samplerInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;sampler) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create texture sampler!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：采样器不会在任何地方引用 <code>VkImage</code>。采样器是一个独立的对象，它提供了一个从纹理中提取颜色的接口。它可以应用于任何图像，无论是 1D、2D 还是 3D。</p>
</blockquote>
<p>在 <code>init</code> 函数中执行创建：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">createSampler</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理图像采样器"><a href="#清理图像采样器" class="headerlink" title="清理图像采样器"></a>清理图像采样器</h2><p>在采样器使用完毕之后需要通过函数 <code>vkDestroySampler</code> 进行销毁以释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroySampler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSampler                                   sampler,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁采样器的 Vulkan 设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>sampler</td>
<td>图像句柄</td>
<td>指定需要销毁的采样器对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>一个可选的自定义内存分配器回调结构指针</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建采样器时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 函数中执行清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TextureManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroySampler</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;sampler, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="使用纹理图像"><a href="#使用纹理图像" class="headerlink" title="使用纹理图像"></a>使用纹理图像</h1><h2 id="组合图像采样器"><a href="#组合图像采样器" class="headerlink" title="组合图像采样器"></a>组合图像采样器</h2><p>在 Vulkan 中，着色器通过 <strong>组合图像采样器描述符</strong> 来使得着色器能够通过采样器对象访问图像资源。</p>
<p>首先，通过结构体 <code>VkDescriptorSetLayoutBinding</code> 来描述一个描述符集布局绑定信息，设置其描述符类型<code>descriptorType</code> 为 <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> 来表明其是组合图像采样器，同时将 <code>stageFlags</code> 设置为 <code>VK_SHADER_STAGE_FRAGMENT_BIT</code> 来指明在片段着色器中使用纹理采样：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorSetLayoutBinding samplerLayoutBinding&#123;&#125;;</span><br><span class="line">samplerLayoutBinding.binding = <span class="number">1</span>;</span><br><span class="line">samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">samplerLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;</span><br><span class="line">samplerLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></div>

<p>然后，添加一个类型 <code>type</code> 为<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> 的 <code>VkDescriptorPoolSize</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorPoolSize samplerPoolSize&#123;&#125;;</span><br><span class="line">samplerPoolSize.type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">samplerPoolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;descriptorManagers[index].poolSizes.<span class="built_in">push_back</span>(samplerPoolSize);</span><br></pre></td></tr></table></figure></div>

<p>然后，将实际的纹理图像和采样器绑定到描述符集中的描述符，通过结构体 <code>VkDescriptorImageInfo</code> 来进行描述，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorImageInfo</span> &#123;</span><br><span class="line">    VkSampler        sampler;</span><br><span class="line">    VkImageView      imageView;</span><br><span class="line">    VkImageLayout    imageLayout;</span><br><span class="line">&#125; VkDescriptorImageInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sampler</td>
<td>采样器句柄</td>
<td>指定与图像资源关联的采样器对象。</td>
</tr>
<tr>
<td>imageView</td>
<td>图像视图句柄</td>
<td>指定与图像资源关联的图像视图。</td>
</tr>
<tr>
<td>imageLayout</td>
<td>图像布局句柄</td>
<td>指定图像资源的布局。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorImageInfo imageInfo&#123;&#125;;</span><br><span class="line">imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;</span><br><span class="line">imageInfo.imageView = textureManager.imageViews[<span class="number">0</span>];</span><br><span class="line">imageInfo.sampler = textureManager.sampler;</span><br></pre></td></tr></table></figure></div>

<p>最后，将其绑定到 <code>VkWriteDescriptorSet</code>对象中，并通过函数 <code>vkUpdateDescriptorSets</code> 更新描述符，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkWriteDescriptorSet imageWrite&#123;&#125;;</span><br><span class="line">imageWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">imageWrite.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">imageWrite.dstSet = <span class="keyword">this</span>-&gt;descriptorManagers[index].set;</span><br><span class="line">imageWrite.dstBinding = <span class="number">1</span>;</span><br><span class="line">imageWrite.dstArrayElement = <span class="number">0</span>;</span><br><span class="line">imageWrite.descriptorCount = <span class="number">1</span>;</span><br><span class="line">imageWrite.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">imageWrite.pBufferInfo = <span class="literal">nullptr</span>;</span><br><span class="line">imageWrite.pImageInfo = &amp;imageInfo;</span><br><span class="line">imageWrite.pTexelBufferView = <span class="literal">nullptr</span>;</span><br><span class="line">descriptorWrites.<span class="built_in">push_back</span>(imageWrite);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="number">1</span>, &amp;imageWrite, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>在顶点着色器中，传递纹理坐标给片段着色器：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> inTexCoord;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> main() </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    fragTexCoord = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>同时，在片段着色器中引用着色器对象：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> texSampler;</span><br></pre></td></tr></table></figure></div>

<p>并采用 <code>GLSL</code> 内置的 <code>texture</code> 函数进行采样：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main() </span><br><span class="line">&#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, fragTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>顶点缓冲区</title>
    <url>/2025/03/20/Vulkan/11.%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="顶点输入描述"><a href="#顶点输入描述" class="headerlink" title="顶点输入描述"></a>顶点输入描述</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>在顶点着色器中需要定义<strong>顶点属性</strong>的输入，通常包括<strong>位置</strong>和<strong>颜色</strong>，其中位置属性可以为二维 <code>vec2</code> 、三维 <code>vec3</code> 或者齐次坐标 <code>vec4</code>。同时向片段着色器输出片段颜色，并向内建变量 <code>gl_Position</code> 输出齐次坐标形式的顶点位置，一个简单的示例如下：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>layout(location = x)</code> 说明了变量的索引，这些索引将在主程序中被使用。</p>
<blockquote>
<p>注意：对于 64 位向量例如 <code>dvec3</code>，索引值增量通常为 <code>2</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout(location = 0) in dvec3 inPosition;</span><br><span class="line">layout(location = 2) in vec3 inColor;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h2><p>通过一个结构体将顶点的位置和颜色封装为一个对象，这里使用 <code>GLM</code> 作为线性代数库：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> </span><br><span class="line">&#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后，可以使用 <code>Vertex</code> 来声明顶点数据数组，这样的结构被称为交错（interleaving ）顶点属性：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">0.0f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="绑定描述"><a href="#绑定描述" class="headerlink" title="绑定描述"></a>绑定描述</h2><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputBindingDescription.html"><code>VkVertexInputBindingDescription</code></a> 来填充绑定描述的相关信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputBindingDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>             binding;</span><br><span class="line">    <span class="type">uint32_t</span>             stride;</span><br><span class="line">    VkVertexInputRate    inputRate;</span><br><span class="line">&#125; VkVertexInputBindingDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>binding</td>
<td>绑定索引</td>
<td>绑定索引，用于指定这个绑定在 <code>VkVertexInputBindingDescription</code> 数组中的位置。每个绑定描述符都有一个唯一的索引，可以为不同的数据类型（例如位置、颜色等）指定不同的绑定。</td>
</tr>
<tr>
<td>stride</td>
<td>指定从一个顶点的数据到下一个顶点数据的字节数</td>
<td>对于一个顶点缓冲区，这个值通常是顶点结构体的大小，或者是其中各个属性占用内存的总和。如果每个顶点只包含一个数据（例如一个位置向量），那么 <code>stride</code> 就是这个数据的大小。</td>
</tr>
<tr>
<td>inputRate</td>
<td>指定在绘制时如何加载数据</td>
<td>可能的值包括：<br /><code>VK_VERTEX_INPUT_RATE_VERTEX</code>：在每个顶点之后移动到下一个数据条目。在每个顶点后加载数据，通常用于大多数情况（例如位置、颜色等每顶点属性）。<br /><code>VK_VERTEX_INPUT_RATE_INSTANCE</code>：在每个实例之后移动到下一个数据条目。在每个实例后加载数据，通常用于实例化渲染，其中相同的顶点数据会被多次重复使用，每次绘制一个实例时会加载不同的数据。<br /><code>VK_VERTEX_INPUT_RATE_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription&#123;&#125;;</span><br><span class="line">        bindingDescription.binding = <span class="number">0</span>;</span><br><span class="line">        bindingDescription.stride = <span class="built_in">sizeof</span>(Vertex);</span><br><span class="line">        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="属性描述"><a href="#属性描述" class="headerlink" title="属性描述"></a>属性描述</h2><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a> 来填充属性描述的相关信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputAttributeDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    location;</span><br><span class="line">    <span class="type">uint32_t</span>    binding;</span><br><span class="line">    VkFormat    format;</span><br><span class="line">    <span class="type">uint32_t</span>    offset;</span><br><span class="line">&#125; VkVertexInputAttributeDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>location</td>
<td>指定着色器输入变量的位置索引</td>
<td><code>location</code> 用于将输入属性与着色器中的输入变量相对应。<br />每个顶点属性（如位置、颜色、法线等）在顶点着色器中都有一个唯一的 <code>location</code> 值，用于标识顶点着色器的输入。<br />例如 <code>location = 0</code> 对应顶点着色器中声明为 <code>layout(location = 0)</code> 的变量。</td>
</tr>
<tr>
<td>binding</td>
<td>指定该属性所在的绑定点索引</td>
<td>表示数据从哪个绑定中获取。每个绑定（<code>VkVertexInputBindingDescription</code>）包含顶点数据的内存布局，例如位置、颜色等。<br />对应于 <code>VkVertexInputBindingDescription</code> 中的 <code>binding</code> 参数。</td>
</tr>
<tr>
<td>format</td>
<td>描述属性的数据格式</td>
<td>指定每个属性在内存中的数据类型，例如：<br /><br /><code>VK_FORMAT_R32_SFLOAT</code>：用于 <code>float</code><br /><code>VK_FORMAT_R32G32_SFLOAT</code>：用于 <code>vec2</code>（包含两个 32 位浮点数）。<br /><code>VK_FORMAT_R32G32B32_SFLOAT</code>：用于 <code>vec3</code>（包含三个 32 位浮点数）。<br /><code>VK_FORMAT_R32G32B32A32_SFLOAT</code>：用于 <code>vec4</code>（包含四个 32 位浮点数）。</td>
</tr>
<tr>
<td>offset</td>
<td>指定顶点属性在顶点数据结构中的偏移量</td>
<td>以字节为单位，表示从顶点数据起始位置到属性数据的偏移。<br />通常通过 <code>offsetof</code> 宏来计算的。例如，<code>offsetof(Vertex, pos)</code> 返回 <code>pos</code> 在结构体 <code>Vertex</code> 中的字节偏移量。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions&#123;&#125;;</span><br><span class="line"></span><br><span class="line">		attributeDescriptions[<span class="number">0</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].location = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].offset = <span class="built_in">offsetof</span>(Vertex, pos);</span><br><span class="line"></span><br><span class="line">		attributeDescriptions[<span class="number">1</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].location = <span class="number">1</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].offset = <span class="built_in">offsetof</span>(Vertex, color);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="图形管线中的顶点输入"><a href="#图形管线中的顶点输入" class="headerlink" title="图形管线中的顶点输入"></a>图形管线中的顶点输入</h2><p>在图形管线创建流程中，需要将绑定描述和属性描述填入图形管线顶点输入状态创建信息中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bindingDescription = Vertex::<span class="built_in">getBindingDescription</span>();</span><br><span class="line"><span class="keyword">auto</span> attributeDescriptions = Vertex::<span class="built_in">getAttributeDescriptions</span>();</span><br><span class="line"></span><br><span class="line">VkPipelineVertexInputStateCreateInfo vertexInputInfo&#123;&#125;;</span><br><span class="line">vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;</span><br><span class="line">vertexInputInfo.vertexBindingDescriptionCount = <span class="number">1</span>;</span><br><span class="line">vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;</span><br><span class="line">vertexInputInfo.vertexAttributeDescriptionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(attributeDescriptions.<span class="built_in">size</span>());</span><br><span class="line">vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure></div>

<h1 id="顶点缓冲区"><a href="#顶点缓冲区" class="headerlink" title="顶点缓冲区"></a>顶点缓冲区</h1><h2 id="填充顶点缓冲区"><a href="#填充顶点缓冲区" class="headerlink" title="填充顶点缓冲区"></a>填充顶点缓冲区</h2><p>填充顶点缓冲区的过程是将顶点数据复制到顶点缓冲区的过程。</p>
<h2 id="绑定顶点缓冲区"><a href="#绑定顶点缓冲区" class="headerlink" title="绑定顶点缓冲区"></a>绑定顶点缓冲区</h2><p>在渲染循环中，需要将顶点缓冲区绑定到命令缓冲区中，通过函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a> 来完成，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindVertexBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstBinding,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bindingCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBuffer*                             pBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDeviceSize*                         pOffsets)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定要记录此命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstBinding</td>
<td>第一个绑定点索引</td>
<td>指定要绑定的第一个绑定点索引，与 <code>VkVertexInputBindingDescription::binding</code> 对应。</td>
</tr>
<tr>
<td>输入参数</td>
<td>bindingCount</td>
<td>绑定的顶点缓冲区数量</td>
<td>要绑定的顶点缓冲区数量，从 <code>firstBinding</code> 开始。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pBuffers</td>
<td>缓冲区数组</td>
<td>指向包含 <code>bindingCount</code> 个 <code>VkBuffer</code> 句柄的数组，每个缓冲区用于存储顶点数据。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pOffsets</td>
<td>偏移数组</td>
<td>指向包含 <code>bindingCount</code> 个 <code>VkDeviceSize</code> 值的数组，指定 <code>pBuffers</code> 数组中每个缓冲区的起始偏移量（以字节为单位）。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;</span><br><span class="line">VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="number">0</span>, <span class="number">1</span>, vertexBuffers, offsets);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffer, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(vertices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="使用传输队列"><a href="#使用传输队列" class="headerlink" title="使用传输队列"></a>使用传输队列</h2><p>可以尝试使用一个<strong>专门用于传输操作的队列族</strong>，而不是复用图形队列。这需要对程序进行如下修改：</p>
<ol>
<li><strong>修改 <code>QueueFamilyIndices</code> 和 <code>findQueueFamilies</code></strong><ul>
<li>显式查找<strong>仅包含</strong> <code>VK_QUEUE_TRANSFER_BIT</code> <strong>但不包含</strong> <code>VK_QUEUE_GRAPHICS_BIT</code> <strong>的队列族</strong>。</li>
</ul>
</li>
<li><strong>修改 <code>createLogicalDevice</code></strong><ul>
<li>在创建逻辑设备时，申请一个<strong>传输队列的句柄</strong>。</li>
</ul>
</li>
<li><strong>创建第二个命令池（Command Pool）</strong><ul>
<li>该命令池用于提交<strong>专门的传输命令缓冲区</strong>，并且基于传输队列族。</li>
<li>你可能需要为这些<strong>短生命周期的命令缓冲区</strong>创建一个<strong>单独的命令池</strong>，因为这样可以让 Vulkan <strong>更好地优化内存分配</strong>。在创建命令池时，可以使用 <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code> 标志。</li>
</ul>
</li>
<li><strong>修改资源的 <code>sharingMode</code></strong><ul>
<li>设置资源的 <code>sharingMode</code> 为 <code>VK_SHARING_MODE_CONCURRENT</code>，并指定<strong>图形队列族</strong>和<strong>传输队列族</strong>都可以访问该资源。</li>
</ul>
</li>
<li><strong>使用传输队列提交拷贝命令</strong><ul>
<li>例如，本章将使用 <code>vkCmdCopyBuffer</code> 来拷贝缓冲区数据，你需要确保它被提交到<strong>传输队列</strong>而不是<strong>图形队列</strong>。</li>
</ul>
</li>
</ol>
<h1 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h1><p>在实际的三角网格中，多个三角形通常会共享顶点，这会导致顶点数据的重复和冗余。为了解决这个问题，需要使用<strong>索引缓冲区（Index Buffer）</strong>。索引缓冲区本质上是一个存储索引的数组，这些索引用于指向顶点缓冲区中的数据。这样可以：重新排列顶点数据，使其更紧凑。同时避免重复存储顶点，多个三角形可以共享同一个顶点数据。</p>
<p>例如，在矩形的情况下，如果顶点缓冲区只存储四个唯一的顶点，索引缓冲区可以存储如下索引数据：</p>
<ol>
<li>前三个索引定义<strong>右上角三角形</strong>。</li>
<li>后三个索引定义<strong>左下角三角形</strong>。</li>
</ol>
<h2 id="创建顶点缓冲区"><a href="#创建顶点缓冲区" class="headerlink" title="创建顶点缓冲区"></a>创建顶点缓冲区</h2><p>和使用暂存缓冲区创建顶点缓冲区类似，首先创建一个临时的暂存缓冲区，并设置其标志为 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>。同时设置内存类型为主机一致性 <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> 和主机可见性 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> 使得可以将索引数据拷贝到缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(indices[<span class="number">0</span>]) * indices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                 VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">                 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                 stagingBuffer,</span><br><span class="line">                 stagingBufferMemory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>在这之后，将索引数据拷贝到暂存缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, indices.<span class="built_in">data</span>(), (<span class="type">size_t</span>)bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，创建索引缓冲区，设置其标志为 <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>，同时设置缓冲区类型为索引缓冲区 <code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> 使得 Vulkan 能够进行优化，同时设置内存类型为设备本地 <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> 以获得最佳性能。并执行从暂存缓冲区到索引缓冲区的拷贝：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                 VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,</span><br><span class="line">                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span><br><span class="line">                 indexBuffer,</span><br><span class="line">                 indexBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后，释放暂存缓冲区：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在索引缓冲区使用完毕之后，需要调用函数 <code>vkDestroyBuffer</code> 和 <code>vkFreeMemory</code> 来释放资源，完整的示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(indices[<span class="number">0</span>]) * indices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                 VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">                 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                 stagingBuffer,</span><br><span class="line">                 stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, indices.<span class="built_in">data</span>(), (<span class="type">size_t</span>)bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                 VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,</span><br><span class="line">                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span><br><span class="line">                 indexBuffer,</span><br><span class="line">                 indexBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="built_in">vkDestroyBuffer</span>(device, indexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkFreeMemory</span>(device, indexBufferMemory, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="使用顶点缓冲区"><a href="#使用顶点缓冲区" class="headerlink" title="使用顶点缓冲区"></a>使用顶点缓冲区</h2><p>和顶点缓冲区类似，需要通过在渲染循环中绑定索引缓冲区来使用。通过函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindIndexBuffer.html"><code>vkCmdBindIndexBuffer</code></a> 来完成绑定命令的录制，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindIndexBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkIndexType                                 indexType)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定要记录此命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>buffer</td>
<td>索引缓冲区句柄</td>
<td>存储索引数据的 <code>VkBuffer</code> 句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>offset</td>
<td>索引缓冲区的字节偏移量</td>
<td>用于指定从缓冲区的哪个位置开始读取索引数据。<br/>该值必须符合索引类型的对齐要求：<br/><code>VK_INDEX_TYPE_UINT16</code> 需要 2 字节对齐。<br/><code>VK_INDEX_TYPE_UINT32</code> 需要 4 字节对齐。</td>
</tr>
<tr>
<td>输入参数</td>
<td>indexType</td>
<td>索引的数据类型</td>
<td>指定索引缓冲区中索引值的格式，可能的值包括：<br /><code>VK_INDEX_TYPE_UINT16</code>：索引数据是 16 位无符号整数。<br /><code>VK_INDEX_TYPE_UINT32</code>：索引数据是 32 位无符号整数。<br /><code>VK_INDEX_TYPE_NONE_KHR</code>：<code>VK_KHR_dynamic_rendering</code> 扩展，用于动态渲染模式下，表示不使用索引缓冲区。通常用于 <code>vkCmdBindIndexBuffer2KHR</code>。<br /><code>VK_INDEX_TYPE_NONE_NV</code>：<code>VK_NVX_mesh_shader</code> 扩展别名，与上一个标志含义相同。<br /><code>VK_INDEX_TYPE_UINT8_KHR</code>：索引数据是 8 位无符号整数索引。<code>VK_INDEX_TYPE_UINT8_EXT</code>：<code>VK_EXT_index_type_uint8</code> 扩展别名，与上一个标志含义相同。<br /><code>VK_INDEX_TYPE_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<blockquote>
<p>Vulkan 目前只能绑定一个索引缓冲区。</p>
<p>Vulkan 目前不支持对不同的顶点属性使用不同的索引，因此如果仅有一个属性不同，仍然需要完整地复制顶点数据。</p>
</blockquote>
<p>然后，将绘制函数由  <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a> 替换为 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    indexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span>                                     vertexOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定要记录此命令的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>indexCount</td>
<td>要绘制的索引数量</td>
<td>表示顶点的数量，由索引缓冲区提供。</td>
</tr>
<tr>
<td>输入参数</td>
<td>instanceCount</td>
<td>实例数量</td>
<td>用于实例化渲染，通常为 <code>1</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstIndex</td>
<td>索引缓冲区中的起始索引</td>
<td>指定从哪个索引开始读取，通常为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>vertexOffset</td>
<td>顶点缓冲区的偏移量</td>
<td>索引值加上此偏移量得到顶点索引，通常为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstInstance</td>
<td>实例化渲染的起始实例 ID</td>
<td>用于 <code>gl_InstanceIndex</code>，通常为 <code>0</code>。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindIndexBuffer</span>(commandBuffer, indexBuffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT16);</span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffer, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>驱动程序开发人员建议将多个缓冲区（例如顶点缓冲区和索引缓冲区）存储在同一个 <code>VkBuffer</code> 中，并在调用 <code>vkCmdBindVertexBuffers</code> 等命令时使用偏移量来访问数据。这么做的好处是：数据在内存中更接近，提高了缓存命中率，从而提升性能。</p>
<p>如果多个资源不会在同一个渲染操作中使用，并且它们的数据在使用前会被刷新，那么甚至可以复用相同的内存块来存储多个资源。这种技术被称为 <strong>别名（Aliasing）</strong>，Vulkan 提供了一些特定的 API 和标志（Flags），允许显式指定要进行别名操作。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>统一缓冲区和描述符</title>
    <url>/2025/03/20/Vulkan/9.%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="统一缓冲区"><a href="#统一缓冲区" class="headerlink" title="统一缓冲区"></a>统一缓冲区</h1><p>通过类 <code>UniformBufferManager</code> 来实现统一缓冲区的管理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 model;</span><br><span class="line">	<span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 view;</span><br><span class="line">	<span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 project;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniformBufferManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UniformBufferManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">UniformBufferManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager, <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line">UniformBufferManager::<span class="built_in">UniformBufferManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager,</span><br><span class="line">										   <span class="type">const</span> CommandManagerSPtr&amp; pCommandManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pCommandManager = pCommandManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建统一缓冲区"><a href="#创建统一缓冲区" class="headerlink" title="创建统一缓冲区"></a>创建统一缓冲区</h2><p>由于模型、视图和投影矩阵几乎在每一帧中都会变化，因此在此处不应该使用暂存缓冲区，以避免额外的性能开销。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniformBufferManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VkBuffer uniformBuffer;</span><br><span class="line">	VkDeviceMemory uniformBuffersMemory;</span><br><span class="line">	<span class="type">void</span>* uniformBuffersMapped;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在这之后，为缓冲区进行内存申请，并设置其标志为 <code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code>。同时设置内存类型为主机一致性 <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> 和主机可见性 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> 使得 CPU 可以将数据拷贝到缓冲区中。</p>
<p>同时使用 <code>vkMapMemory</code> 进行持久映射（Persistent Mapping），使得缓冲区可以在整个程序运行过程中保持映射，不需要每帧手动 <code>vkMapMemory</code> 和 <code>vkUnmapMemory</code>，提高性能。</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UniformBufferManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">				 VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,</span><br><span class="line">				 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">				 <span class="keyword">this</span>-&gt;uniformBuffer,</span><br><span class="line">				 <span class="keyword">this</span>-&gt;uniformBuffersMemory);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vkMapMemory</span>(pContentManager-&gt;device, </span><br><span class="line">                <span class="keyword">this</span>-&gt;uniformBuffersMemory, </span><br><span class="line">                <span class="number">0</span>, </span><br><span class="line">                bufferSize, </span><br><span class="line">                <span class="number">0</span>, </span><br><span class="line">                &amp;<span class="keyword">this</span>-&gt;uniformBuffersMapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="清理统一缓冲区"><a href="#清理统一缓冲区" class="headerlink" title="清理统一缓冲区"></a>清理统一缓冲区</h2><p>最后，在完成统一缓冲区的使用之后，销毁缓冲区以释放资源：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UniformBufferManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyBuffer</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;uniformBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">vkFreeMemory</span>(pContentManager-&gt;device, <span class="keyword">this</span>-&gt;uniformBuffersMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="更新统一缓冲区"><a href="#更新统一缓冲区" class="headerlink" title="更新统一缓冲区"></a>更新统一缓冲区</h2><p>利用持久化映射指针，将数据拷贝到缓冲区中：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniformBufferManager</span> : <span class="keyword">public</span> BufferManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> UniformBufferObject&amp; ubo)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UniformBufferManager::update</span><span class="params">(<span class="type">const</span> UniformBufferObject&amp; ubo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;uniformBuffersMapped, &amp;ubo, <span class="built_in">sizeof</span>(ubo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Vulkan-对齐规则"><a href="#Vulkan-对齐规则" class="headerlink" title="Vulkan 对齐规则"></a>Vulkan 对齐规则</h2><p>Vulkan 规定 UBO 结构体中的数据必须按照特定的对齐方式存储，以下是一些关键规则：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>4 字节（N）</td>
</tr>
<tr>
<td><code>vec2</code></td>
<td>8 字节（2N）</td>
</tr>
<tr>
<td><code>vec3</code></td>
<td>16 字节（4N）</td>
</tr>
<tr>
<td><code>vec4</code></td>
<td>16 字节（4N）</td>
</tr>
<tr>
<td><code>mat4</code></td>
<td>16 字节（4N）</td>
</tr>
<tr>
<td>嵌套结构体</td>
<td>对齐到 16 字节的整数倍</td>
</tr>
</tbody></table>
<blockquote>
<p>注意： <code>mat4</code> 被存储为 4 个 <code>vec4</code>，因此 它的对齐要求与 <code>vec4</code> 相同，即 16 字节。</p>
</blockquote>
<p>一个错误的使用示例如下，其中 <code>model</code>、<code>view</code>、<code>project</code> 的偏移应为 <code>16</code> 的整数倍：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> &#123;</span><br><span class="line">    glm::vec2 foo;		<span class="comment">// offset = 0</span></span><br><span class="line">    glm::mat4 model;	<span class="comment">// offset = 8</span></span><br><span class="line">    glm::mat4 view;		<span class="comment">// offset = 72</span></span><br><span class="line">    glm::mat4 project;	<span class="comment">// offset = 136</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以使用 C++11 的 <code>alignas</code> 关键字，手动指定对齐方式：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> &#123;</span><br><span class="line">    glm::vec2 foo; 					<span class="comment">// offset = 0</span></span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 model;	<span class="comment">// offset = 16</span></span><br><span class="line">    glm::mat4 view;					<span class="comment">// offset = 80</span></span><br><span class="line">    glm::mat4 proj;					<span class="comment">// offset = 144</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>或者可以在 包含 GLM 头文件之前 定义 <code>GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_DEFAULT_ALIGNED_GENTYPES</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：</strong> 如果 UBO 包含嵌套结构体，GLM 自动对齐可能会失效。</p>
</blockquote>
<p>最佳实践：始终显式指定对齐方式：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 model;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 view;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) glm::mat4 proj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h1 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h1><p>通过类 <code>DescriptorManager</code> 来管理描述符：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DescriptorManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DescriptorManager</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">DescriptorManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ContentManagerSPtr pContentManager;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line">DescriptorManager::<span class="built_in">DescriptorManager</span>(<span class="type">const</span> ContentManagerSPtr&amp; pContentManager)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pContentManager = pContentManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="顶点着色器与主程序"><a href="#顶点着色器与主程序" class="headerlink" title="顶点着色器与主程序"></a>顶点着色器与主程序</h2><p>在 3D 渲染中，最重要的三个变换矩阵：模型、视图、投影将通过 <strong>描述符</strong> 从主程序传递到顶点着色器中。</p>
<p>在顶点着色器中，使用 <code>uniform</code> 关键字来标记一个变量为 <strong>一致变量</strong>，并通过前缀 <code>layout(binding = x)</code> 来指明变量所绑定的缓冲区。以模型、视图和投影矩阵为例：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">    <span class="type">mat4</span> project;</span><br><span class="line">&#125; ubo;</span><br></pre></td></tr></table></figure></div>

<h2 id="描述符组布局"><a href="#描述符组布局" class="headerlink" title="描述符组布局"></a>描述符组布局</h2><p>使用函数来创建描述符组布局，由于每个应用程序使用的描述符集布局不同，使用 <code>std::vector&lt;VkDescriptorSetLayoutBinding&gt;</code> 来接收不同应用程序的绑定信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DescriptorManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	std::vector&lt;VkDescriptorSetLayoutBinding&gt; bindings&#123;&#125;;</span><br><span class="line">	VkDescriptorSetLayout layout;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置描述符集布局"><a href="#配置描述符集布局" class="headerlink" title="配置描述符集布局"></a>配置描述符集布局</h3><p>通过结构体 <code>VkDescriptorSetLayoutBinding</code>来定义一个描述符绑定信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutBinding</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>              binding;</span><br><span class="line">    VkDescriptorType      descriptorType;</span><br><span class="line">    <span class="type">uint32_t</span>              descriptorCount;</span><br><span class="line">    VkShaderStageFlags    stageFlags;</span><br><span class="line">    <span class="type">const</span> VkSampler*      pImmutableSamplers;</span><br><span class="line">&#125; VkDescriptorSetLayoutBinding;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>binding</td>
<td>描述符的绑定索引</td>
<td>与着色器 <code>layout(binding = x)</code> 指定的索引匹配。例如，如果着色器定义 <code>layout(binding = 0) uniform UniformBufferObject &#123; ... &#125;;</code>，那么这里应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>descriptorType</td>
<td>描述符的类型</td>
<td>决定绑定的资源类型，例如 UBO、SSBO、采样器等。常见值包括：<br/><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>：UBO，统一缓冲区。<br/><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>：SSBO，存储缓冲区。<br/><code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>：采样器和图像。</td>
</tr>
<tr>
<td>descriptorCount</td>
<td>描述符的数量</td>
<td>通常为 <code>1</code>，但可以用于数组。例如，骨骼动画中每个骨骼对应一个 UBO，可以使用 <code>descriptorCount = N</code> 指定多个 UBO。</td>
</tr>
<tr>
<td>stageFlags</td>
<td>描述符适用的着色器阶段</td>
<td>指定此描述符在哪些着色器中可用，常用的值包括：<br /><code>VK_SHADER_STAGE_VERTEX_BIT</code>：顶点着色器。<br/><code>VK_SHADER_STAGE_FRAGMENT_BIT</code>：片段着色器。<br/><code>VK_SHADER_STAGE_ALL_GRAPHICS</code>：所有图形管线阶段。</td>
</tr>
<tr>
<td>pImmutableSamplers</td>
<td>指向不可变采样器数组</td>
<td>用于图像采样，描述符类型为 <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> 或 <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> 。<br />若为 <code>nullptr</code>，则可以动态绑定不同的 <code>VkSampler</code>。若提供了一个 <code>VkSampler</code> 数组，则绑定后无法更改。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorSetLayoutBinding uboLayoutBinding&#123;&#125;;</span><br><span class="line">uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></div>

<p>然后，将所有的描述符绑定信息封装在 <code>VkDescriptorSetLayoutCreateInfo</code> 结构体中，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                            pNext;</span><br><span class="line">    VkDescriptorSetLayoutCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                               bindingCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayoutBinding*    pBindings;</span><br><span class="line">&#125; VkDescriptorSetLayoutCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</code>，以表明这是一个描述符集布局创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定描述符集布局创建时的附加标志。</td>
<td>通常为 <code>0</code>，其他常见值包括：<br /><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR</code>：启用推送描述符，无需预先分配描述符集。<br /><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT</code>：允许在绑定后更新，适用于动态更新的资源。<br /><code>VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT</code>：指定描述符集仅适用于 主机可见 资源。</td>
</tr>
<tr>
<td>bindingCount</td>
<td>描述符数组数量</td>
<td>绑定的描述符数量，即 <code>pBindings</code> 数组中的元素个数。</td>
</tr>
<tr>
<td>pBindings</td>
<td>描述符数组指针</td>
<td>指向 <code>VkDescriptorSetLayoutBinding</code> 数组，定义描述符的绑定点、类型、着色器可见性等信息。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorSetLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkDescriptorSetLayoutCreateInfo layoutInfo&#123;&#125;;</span><br><span class="line">	layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">	layoutInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	layoutInfo.flags = <span class="number">0</span>;</span><br><span class="line">	layoutInfo.bindingCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="keyword">this</span>-&gt;bindings.<span class="built_in">size</span>());</span><br><span class="line">	layoutInfo.pBindings = <span class="keyword">this</span>-&gt;bindings.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建描述符集布局"><a href="#创建描述符集布局" class="headerlink" title="创建描述符集布局"></a>创建描述符集布局</h3><p>在这之后，调用函数 <code>vkCreateDescriptorSetLayout</code> 来创建描述符集布局，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorSetLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSetLayout*                      pSetLayout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建描述符集布局的逻辑设备，描述符集布局与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>描述符集布局创建信息指针</td>
<td><code>VkDescriptorSetLayoutCreateInfo</code> 结构体的指针，包含描述符的绑定点、类型和可见性。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSetLayout</td>
<td>描述符集布局指针</td>
<td>指向 <code>VkDescriptorSetLayout</code> 变量的指针，存储创建的描述符集布局句柄。函数执行成功后，该变量将持有新创建的描述符集布局对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示描述符集布局是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示描述符集布局创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorSetLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(pContentManager-&gt;device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;layout) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 函数中调用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">createDescriptorSetLayout</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="清理描述符集布局"><a href="#清理描述符集布局" class="headerlink" title="清理描述符集布局"></a>清理描述符集布局</h3><p>最后在完成描述符集布局的使用之后，需要调用函数 <code>vkDestroyDescriptorSetLayout</code> 来释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyDescriptorSetLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSetLayout                       descriptorSetLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁描述符集布局的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>descriptorSetLayout</td>
<td>描述符集布局句柄</td>
<td>指定要销毁描述符集布局的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建描述符集布局时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 中清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyDescriptorPool</span>(pContentManager-&gt;device, pool, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="描述符池"><a href="#描述符池" class="headerlink" title="描述符池"></a>描述符池</h2><p>描述符池负责管理描述符集的分配和释放，类似于内存池的作用，同样接收应用程序传入的 <code>std::vector&lt;VkDescriptorPoolSize&gt;</code>：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DescriptorManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;VkDescriptorPoolSize&gt; poolSizes&#123;&#125;;</span><br><span class="line">	VkDescriptorPool pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置描述符池"><a href="#配置描述符池" class="headerlink" title="配置描述符池"></a>配置描述符池</h3><p>如同命令缓冲区和命令池，描述符集不能被直接创建，其必须通过描述符池来创建。</p>
<p><code>VkDescriptorPoolSize</code>定义描述符池中每种 <strong>描述符类型</strong> 的数量，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolSize</span> &#123;</span><br><span class="line">    VkDescriptorType    type;</span><br><span class="line">    <span class="type">uint32_t</span>            descriptorCount;</span><br><span class="line">&#125; VkDescriptorPoolSize;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>描述符的类型</td>
<td>指定描述符的类型，可能的值包括：<br /><code>VK_DESCRIPTOR_TYPE_SAMPLER</code>：独立的采样器（Sampler），用于采样纹理，但不绑定图像数据。<br/><code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>：采样器 + 纹理 绑定，既包含采样器也包含图像数据，适用于常见的纹理采样。<br/><code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>：只包含已采样的图像（纹理），但需要单独的 VkSampler 采样器。<br/><code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>：存储图像，支持读写访问，通常用于计算着色器或延迟渲染。<br/><code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>：统一纹理缓冲区，用作只读的纹理数据，可以在着色器中像采样纹理一样访问。<br/><code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>：存储纹理缓冲区，支持读写，可用于存储计算结果或处理像素数据。<br/><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>：统一缓冲区（UBO），用于存储着色器的常量数据（如变换矩阵）。<br/><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>：存储缓冲区（SSBO），支持读写，适用于大规模数据处理（如计算着色器）。<br/><code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>：动态 UBO，可以偏移访问不同部分，提高内存利用率。<br/><code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>：动态 SSBO，类似 <code>UNIFORM_BUFFER_DYNAMIC</code>，但用于存储缓冲区。<br/><code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>：输入附件，在片段着色器中用于访问前一渲染阶段的渲染目标。<br/><code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>：内联 UBO，直接嵌入描述符集中，而不是单独的缓冲区。<br/><code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>：加速结构（Ray Tracing），用于 Vulkan 光线追踪（RTX）。<br/><code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV</code>：NVIDIA 专用加速结构（早期的光线追踪实现）。<br/><code>VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM</code>：Qualcomm 扩展，用于图像滤波和采样权重计算。<br/><code>VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM</code>：Qualcomm 扩展，用于图像块匹配（比如视频编解码）。<br/><code>VK_DESCRIPTOR_TYPE_MUTABLE_EXT</code>：可变描述符，允许动态改变描述符类型。<br/><code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT</code>：等同于 <code>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</code>（别名）。<br/><code>VK_DESCRIPTOR_TYPE_MUTABLE_VALVE</code>：等同于 <code>VK_DESCRIPTOR_TYPE_MUTABLE_EXT</code>（别名）。<br/><code>VK_DESCRIPTOR_TYPE_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>descriptorCount</td>
<td>描述符的数量</td>
<td>该类型<strong>描述符</strong>的最大数量。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorPoolSize uboPoolSize&#123;&#125;;</span><br><span class="line">uboPoolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">uboPoolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

<p>通过结构体 <code>VkDescriptorPoolCreateInfo</code> 来说明描述符池的创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    VkDescriptorPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                       maxSets;</span><br><span class="line">    <span class="type">uint32_t</span>                       poolSizeCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorPoolSize*    pPoolSizes;</span><br><span class="line">&#125; VkDescriptorPoolCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</code>，以表明这是一个描述符池创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定描述符池创建时的附加标志</td>
<td>控制描述符池的行为，可能的值包括：<br /><code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>：允许释放单个描述符集，否则 vkFreeDescriptorSets 无效，所有描述符集必须一起释放。<br/><code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code>：支持 “绑定后更新”（Update After Bind），允许在绑定到管线后仍然修改描述符的内容。<br/><code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT</code>：仅支持 CPU（Host-Only）管理描述符集，通常用于调试或特殊扩展。<br/><code>VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV</code>：允许分配超过池限制的描述符集（NVIDIA 扩展），可能会影响性能。<br/><code>VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV</code>：允许描述符池本身超额分配，适用于动态场景，但可能会浪费内存。<br/><code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT</code>：等同于 <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code>（扩展别名）。<br/><code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE</code>：等同于 <code>VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT</code>（扩展别名）。<br/><code>VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>maxSets</td>
<td>最大描述符集数量</td>
<td>指定描述符池中允许分配的最大<strong>描述符集</strong>数量。</td>
</tr>
<tr>
<td>poolSizeCount</td>
<td>描述符类型数量数组大小</td>
<td>指定 <code>pPoolSizes</code> 数组中描述符类型的数量。</td>
</tr>
<tr>
<td>pPoolSizes</td>
<td>描述符类型数量数组指针</td>
<td>指向一个 <code>VkDescriptorPoolSize</code> 结构体数组，定义池中每种描述符类型的数量。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkDescriptorPoolCreateInfo poolInfo&#123;&#125;;</span><br><span class="line">	poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">	poolInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	poolInfo.flags = <span class="number">0</span>;</span><br><span class="line">	poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="number">1</span>);</span><br><span class="line">	poolInfo.poolSizeCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(poolSizes.<span class="built_in">size</span>());</span><br><span class="line">	poolInfo.pPoolSizes = poolSizes.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建描述符池"><a href="#创建描述符池" class="headerlink" title="创建描述符池"></a>创建描述符池</h3><p>然后通过函数 <code>vkCreateDescriptorPool</code> 来完成描述符池的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorPool*                           pDescriptorPool)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建描述符池的逻辑设备，描述符池与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>描述符池创建信息指针</td>
<td>指向 <code>VkDescriptorPoolCreateInfo</code> 结构体的指针，定义了描述符池的详细信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pDescriptorPool</td>
<td>描述符池指针</td>
<td>指向<code>VkDescriptorPool</code>的指针，存储创建的描述符池句柄。函数执行成功后，该变量将持有新创建的描述符池对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示描述符池是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示描述符池创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(pContentManager-&gt;device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;<span class="keyword">this</span>-&gt;pool) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create descriptor pool!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>init</code> 函数中调用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">createDescriptorPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="清理描述符池"><a href="#清理描述符池" class="headerlink" title="清理描述符池"></a>清理描述符池</h3><p>在完成描述符池的使用之后，需要调用函数 <code>vkDestroyDescriptorPool</code> 来销毁描述符池以释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> VKAPI_CALL <span class="title">vkDestroyDescriptorPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorPool                            descriptorPool,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁描述符池的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>descriptorPool</td>
<td>描述符池句柄</td>
<td>指定要销毁描述符池的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建描述符池时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>在 <code>clear</code> 中清理：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vkDestroyDescriptorPool</span>(pContentManager-&gt;device, pool, <span class="literal">nullptr</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="描述符集"><a href="#描述符集" class="headerlink" title="描述符集"></a>描述符集</h2><p>通过函数 <code>createDescriptorSet</code> 来进行描述符集的分配：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DescriptorManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	VkDescriptorSet set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置描述符集"><a href="#配置描述符集" class="headerlink" title="配置描述符集"></a>配置描述符集</h3><p>通过结构体 <code>VkDescriptorSetAllocateInfo</code> 来定义从描述符池中如何分配描述符集，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkDescriptorPool                descriptorPool;</span><br><span class="line">    <span class="type">uint32_t</span>                        descriptorSetCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">&#125; VkDescriptorSetAllocateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</code>，以表明这是一个描述符集分配信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>descriptorPool</td>
<td>描述符池句柄</td>
<td>指定用于分配描述符集的描述符池。</td>
</tr>
<tr>
<td>descriptorSetCount</td>
<td>描述符集数量</td>
<td>需要分配的描述符集数量。</td>
</tr>
<tr>
<td>pSetLayouts</td>
<td>描述符集布局数组</td>
<td>指定每个描述符使用的布局，即 <code>VkDescriptorSetLayout</code> 句柄的数组，大小等于 <code>descriptorSetCount</code>。</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VkDescriptorSetAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">	allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;</span><br><span class="line">	allocInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	allocInfo.descriptorPool = <span class="keyword">this</span>-&gt;pool;</span><br><span class="line">	allocInfo.descriptorSetCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="number">1</span>);</span><br><span class="line">	allocInfo.pSetLayouts = &amp;<span class="keyword">this</span>-&gt;layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="分配描述符集"><a href="#分配描述符集" class="headerlink" title="分配描述符集"></a>分配描述符集</h3><p>然后调用函数 <code>vkAllocateDescriptorSets</code>来完成描述符集的分配，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSet*                            pDescriptorSets)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定分配描述符集的逻辑设备，描述符集与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocateInfo</td>
<td>描述符集分配信息指针</td>
<td>指向 <code>VkDescriptorSetAllocateInfo</code> 结构体的指针，定义了描述符集的分配信息。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pDescriptorSets</td>
<td>描述符集指针</td>
<td>指向<code>VkDescriptorSet</code>的指针，存储分配的描述符集句柄。函数执行成功后，该变量将持有新创建的描述符集对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示描述符集是否分配成功</td>
<td><code>VK_SUCCESS</code>：表示描述符集分配成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::createDescriptorSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">vkAllocateDescriptorSets</span>(pContentManager-&gt;device, &amp;allocInfo, &amp;<span class="keyword">this</span>-&gt;set) != VK_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate descriptor sets!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：描述符集会随着描述符池的释放而自动释放，因此不需要显示地释放描述符集。</p>
</blockquote>
<p>在 <code>init</code> 函数中调用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// descriptor_manager.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DescriptorManager::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">createDescriptorSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="绑定描述符集缓冲区"><a href="#绑定描述符集缓冲区" class="headerlink" title="绑定描述符集缓冲区"></a>绑定描述符集缓冲区</h2><h3 id="配置描述符缓冲区"><a href="#配置描述符缓冲区" class="headerlink" title="配置描述符缓冲区"></a>配置描述符缓冲区</h3><p>在完成描述符集的配置之后，需要对描述符集进行缓冲区绑定。首先通过结构体 <code>VkDescriptorBufferInfo</code> 配置描述符的缓冲区，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorBufferInfo</span> &#123;</span><br><span class="line">    VkBuffer        buffer;</span><br><span class="line">    VkDeviceSize    offset;</span><br><span class="line">    VkDeviceSize    range;</span><br><span class="line">&#125; VkDescriptorBufferInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>buffer</td>
<td>缓冲区句柄</td>
<td>要绑定的 <code>VkBuffer</code> 句柄，通常是 UBO（Uniform Buffer）或 SSBO（Shader Storage Buffer）。</td>
</tr>
<tr>
<td>offset</td>
<td>缓冲区偏移量</td>
<td>表示从 <code>buffer</code> 的哪个位置开始绑定。必须满足 <code>minUniformBufferOffsetAlignment</code> 对齐要求。单位为字节。</td>
</tr>
<tr>
<td>range</td>
<td>绑定的缓冲区范围</td>
<td>表示从 <code>offset</code> 开始，绑定多少字节的数据给着色器使用。如果设置为 <code>VK_WHOLE_SIZE</code>，则使用 <code>buffer</code> 从 <code>offset</code> 处的全部剩余大小。单位为字节。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkWriteDescriptorSet&gt; descriptorWrites&#123;&#125;;</span><br><span class="line">VkDescriptorBufferInfo bufferInfo&#123;&#125;;</span><br><span class="line">bufferInfo.buffer = uniformBuffer;</span><br><span class="line">bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">bufferInfo.range = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br></pre></td></tr></table></figure></div>

<p>然后，通过结构体 <code>VkWriteDescriptorSet</code>来配置描述符集的更新，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkWriteDescriptorSet</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkDescriptorSet                  dstSet;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstBinding;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstArrayElement;</span><br><span class="line">    <span class="type">uint32_t</span>                         descriptorCount;</span><br><span class="line">    VkDescriptorType                 descriptorType;</span><br><span class="line">    <span class="type">const</span> VkDescriptorImageInfo*     pImageInfo;</span><br><span class="line">    <span class="type">const</span> VkDescriptorBufferInfo*    pBufferInfo;</span><br><span class="line">    <span class="type">const</span> VkBufferView*              pTexelBufferView;</span><br><span class="line">&#125; VkWriteDescriptorSet;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</code>，以表明这是一个描述符集更新信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>dstSet</td>
<td>描述符集句柄</td>
<td>表示要更新的 <code>VkDescriptorSet</code> 句柄。</td>
</tr>
<tr>
<td>dstBinding</td>
<td>目标绑定点</td>
<td>对应 <code>VkDescriptorSetLayoutBinding.binding</code>，表示该资源应该绑定到哪个 <code>binding</code>，着色器中的 <code>layout(binding = x)</code>。</td>
</tr>
<tr>
<td>dstArrayElement</td>
<td>描述符数组起始索引</td>
<td>当描述符是数组时，指定从哪个索引开始更新，通常设为 <code>0</code>。</td>
</tr>
<tr>
<td>descriptorCount</td>
<td>描述数量</td>
<td>要更新的描述符个数，通常为 <code>1</code>，如果 <code>dstBinding</code> 是数组，可以更新多个。</td>
</tr>
<tr>
<td>descriptorType</td>
<td>描述符的类型</td>
<td>必须匹配 <code>dstBinding</code> 指定的 <code>VkDescriptorSetLayoutBinding.descriptorType</code>。</td>
</tr>
<tr>
<td>pImageInfo</td>
<td>描述符图像信息指针</td>
<td>指向 <code>VkDescriptorImageInfo</code> 的指针，用于图像（如采样器、纹理）描述符，当 <code>descriptorType</code> 为 <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>、<code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> 或 <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> 时使用。</td>
</tr>
<tr>
<td>pBufferInfo</td>
<td>描述符缓冲区信息指针</td>
<td>指向 <code>VkDescriptorBufferInfo</code> 的指针，用于缓冲区（如 UBO、SSBO）描述符，当 <code>descriptorType</code> 为 <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> 或 <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> 时使用。</td>
</tr>
<tr>
<td>pTexelBufferView</td>
<td>缓冲区视图指针</td>
<td>指向 <code>VkBufferView</code> 的指针，用于纹理缓冲描述符。，当 <code>descriptorType</code> 为 <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> 或 <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> 时使用。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkWriteDescriptorSet bufferWrite;</span><br><span class="line">bufferWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">bufferWrite.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">bufferWrite.dstSet = set;</span><br><span class="line">bufferWrite.dstBinding = <span class="number">0</span>;</span><br><span class="line">bufferWrite.dstArrayElement = <span class="number">0</span>;</span><br><span class="line">bufferWrite.descriptorCount = <span class="number">1</span>;</span><br><span class="line">bufferWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">bufferWrite.pBufferInfo = &amp;bufferInfo;</span><br><span class="line">bufferWrite.pImageInfo = <span class="literal">nullptr</span>;</span><br><span class="line">bufferWrite.pTexelBufferView = <span class="literal">nullptr</span>;</span><br><span class="line">descriptorWrites.<span class="built_in">push_back</span>(bufferWrite);</span><br></pre></td></tr></table></figure></div>

<h3 id="执行描述符绑定"><a href="#执行描述符绑定" class="headerlink" title="执行描述符绑定"></a>执行描述符绑定</h3><p>最后，调用函数  <code>vkUpdateDescriptorSets</code>来完成描述符集的更新，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkUpdateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorWriteCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorCopyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCopyDescriptorSet*                  pDescriptorCopies)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定更新描述符集的逻辑设备，描述符集与该设备绑定，并只能在该设备的队列上使用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>descriptorWriteCount</td>
<td>描述符集写入数量</td>
<td>要执行的 <code>VkWriteDescriptorSet</code>结构体数量，即绑定资源的个数。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pDescriptorWrites</td>
<td>描述符集写入信息指针</td>
<td>指向 <code>VkWriteDescriptorSet</code> 数组的指针，包含要写入（更新）的描述符信息，如 UBO、纹理、采样器等。</td>
</tr>
<tr>
<td>输入参数</td>
<td>descriptorCopyCount</td>
<td>描述符集拷贝数量</td>
<td>要执行的 <code>VkCopyDescriptorSet</code> 结构体数量，用于从一个 <code>VkDescriptorSet</code> 复制到另一个。如果不需要复制应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pDescriptorCopies</td>
<td>描述符集拷贝信息指针</td>
<td>指向 <code>VkCopyDescriptorSet</code> 数组的指针，用于复制描述符集内容。通常设为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="number">1</span>, &amp;bufferWrite, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="描述符集的使用"><a href="#描述符集的使用" class="headerlink" title="描述符集的使用"></a>描述符集的使用</h2><p>通过函数 <code>vkCmdBindDescriptorSets</code> 来将描述符集绑定到命令缓冲区中，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            layout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorSetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSet*                      pDescriptorSets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    dynamicOffsetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint32_t</span>*                             pDynamicOffsets)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>绑定描述符集的命令缓冲区，必须处于记录状态（recording）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipelineBindPoint</td>
<td>绑定的图形管线</td>
<td>指定绑定到 图形管线（<code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>）或 计算管线（<code>VK_PIPELINE_BIND_POINT_COMPUTE</code>）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>layout</td>
<td>使用的管线布局</td>
<td>管线布局必须与 <code>VkDescriptorSetLayout</code> 相匹配。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstSet</td>
<td>开始索引</td>
<td>从 哪个 <code>set</code> 索引 开始绑定（一般是 0）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>descriptorSetCount</td>
<td>描述符集数量</td>
<td>绑定的描述符集个数。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pDescriptorSets</td>
<td>描述符集数组</td>
<td>需要绑定的描述符集数组。</td>
</tr>
<tr>
<td>输入参数</td>
<td>dynamicOffsetCount</td>
<td>动态偏移数量</td>
<td>如果没有动态 UBO，设为 <code>0</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pDynamicOffsets</td>
<td>动态偏移数组</td>
<td>用于偏移 <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> 或 <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> 类型的描述符。如果没有，设为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindDescriptorSets</span>(commandBuffer,</span><br><span class="line">                        VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">                        pipelineLayout,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        &amp;descriptorSets[currentFrame],</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：描述符集的绑定应当在绘制命令 <code>vkCmdDrawIndexed</code> 之前。</p>
</blockquote>
<h2 id="多重描述符集"><a href="#多重描述符集" class="headerlink" title="多重描述符集"></a>多重描述符集</h2><p>Vulkan 支持同时绑定多个描述符集。要做到这一点，需要在创建管线布局时，为每个描述符集指定对应的描述符布局。并在着色器代码中使用 <code>set</code> 关键字来引用特定的描述符集，例如：</p>
<div class="code-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(set = <span class="number">0</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject &#123; ... &#125;</span><br></pre></td></tr></table></figure></div>

<p>使用多个描述符集的主要优势在于：</p>
<ol>
<li>减少不必要的重绑定：可以将每个物体的变量和多个物体共享的变量分别存储到不同的描述符集中。这样，在绘制多个物体时，只需更改每个物体特有的描述符集，而共享的描述符集可以保持不变。这样做可以 减少 <code>vkCmdBindDescriptorSets</code> 调用的次数，提高渲染效率。</li>
<li>更灵活的资源管理：例如，可以将 材质 和 光照 信息放在一个全局描述符集中，而模型变换 和骨骼动画信息放在每个物体的描述符集中。这样，在切换物体时，只需更新该物体相关的描述符集，而无需重新绑定全局资源。</li>
</ol>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>图形管线</title>
    <url>/2025/03/20/Vulkan/12.%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="固定功能"><a href="#固定功能" class="headerlink" title="固定功能"></a>固定功能</h1><p>在 Vulkan 中，需要对于图形管线中的每个部分显示地进行配置。</p>
<h2 id="动态状态"><a href="#动态状态" class="headerlink" title="动态状态"></a>动态状态</h2><p>大部分管线状态都需要预设，但部分管线状态可以在绘制时进行改变而无需重新创建管线，例如视口大小。对于需要动态使用的状态，需要使用 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a> 来显示指定，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                      sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                          pNext;</span><br><span class="line">    VkPipelineDynamicStateCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                             dynamicStateCount;</span><br><span class="line">    <span class="type">const</span> VkDynamicState*                pDynamicStates;</span><br><span class="line">&#125; VkPipelineDynamicStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</code>，以表明这是一个着色器管线动态状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>dynamicStateCount</td>
<td>动态状态的数量</td>
<td><code>pDynamicStates</code> 数组中的状态数。</td>
</tr>
<tr>
<td>pDynamicStates</td>
<td>动态状态枚举值的数组</td>
<td>常见的枚举值包括：<br/><code>VK_DYNAMIC_STATE_VIEWPORT</code>：视口（viewport）状态<br/><code>VK_DYNAMIC_STATE_SCISSOR</code>：裁剪区域（scissor）状态<br/><code>VK_DYNAMIC_STATE_LINE_WIDTH</code>：线条宽度（line width）<br/><code>VK_DYNAMIC_STATE_DEPTH_BIAS</code>：深度偏移（depth bias）<br/><code>VK_DYNAMIC_STATE_BLEND_CONSTANTS</code>：混合常量（blend constants）<br/><code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code>：深度范围（depth bounds）<br/><code>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</code>：模板比较掩码（stencil compare mask）<br/><code>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</code>：模板写掩码（stencil write mask）<br/><code>VK_DYNAMIC_STATE_STENCIL_REFERENCE</code>：模板参考值（stencil reference）</td>
</tr>
</tbody></table>
<p>调用示例：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR&#125;;</span><br><span class="line"></span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;</span><br><span class="line">dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">dynamicState.flags = <span class="number">0</span>;</span><br><span class="line">dynamicState.dynamicStateCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dynamicStates.<span class="built_in">size</span>());</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a> 完成着色器管线<strong>顶点输入</strong>状态的创建，其描述了传递给顶点着色器的数据格式，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                 pNext;</span><br><span class="line">    VkPipelineVertexInputStateCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                                    vertexBindingDescriptionCount;</span><br><span class="line">    <span class="type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;</span><br><span class="line">    <span class="type">uint32_t</span>                                    vertexAttributeDescriptionCount;</span><br><span class="line">    <span class="type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;</span><br><span class="line">&#125; VkPipelineVertexInputStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</code>，以表明这是一个着色器管线顶点输入状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>vertexBindingDescriptionCount</td>
<td>顶点绑定描述符的数量</td>
<td><code>pVertexBindingDescriptions</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pVertexBindingDescriptions</td>
<td><code>VkVertexInputBindingDescription</code> 结构体数组</td>
<td>描述每个顶点绑定的详细信息。</td>
</tr>
<tr>
<td>vertexAttributeDescriptionCount</td>
<td>顶点属性描述符的数量</td>
<td><code>pVertexAttributeDescriptions</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pVertexAttributeDescriptions</td>
<td><code>VkVertexInputAttributeDescription</code> 结构体数组</td>
<td>描述每个顶点属性的详细信息。</td>
</tr>
</tbody></table>
<h3 id="顶点绑定"><a href="#顶点绑定" class="headerlink" title="顶点绑定"></a>顶点绑定</h3><p> 结构体 <code>vertexBindingDescriptionCount</code> 描述了<strong>顶点绑定</strong>的详细信息，描述了数据之间的间距，以及数据是按顶点（per-vertex）还是按实例（per-instance）传递的，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputBindingDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>             binding;</span><br><span class="line">    <span class="type">uint32_t</span>             stride;</span><br><span class="line">    VkVertexInputRate    inputRate;</span><br><span class="line">&#125; VkVertexInputBindingDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>binding</td>
<td>顶点绑定的索引</td>
<td></td>
</tr>
<tr>
<td>stride</td>
<td>每个顶点的数据间距</td>
<td>以字节计数。</td>
</tr>
<tr>
<td>inputRate</td>
<td>数据的步进方式</td>
<td><code>VK_VERTEX_INPUT_RATE_VERTEX</code>：按照定点步进<br/><code>VK_VERTEX_INPUT_RATE_INSTANCE</code>：按照实例步进<br/><code>VK_VERTEX_INPUT_RATE_MAX_ENUM</code>：保留字段</td>
</tr>
</tbody></table>
<h3 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h3><p>结构体 <code>VkVertexInputAttributeDescription</code> 描述了<strong>顶点属性</strong>的详细信息，描述了传递给顶点着色器的属性类型，指定数据应从哪个绑定（binding）加载，并指定数据的偏移量，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputAttributeDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    location;</span><br><span class="line">    <span class="type">uint32_t</span>    binding;</span><br><span class="line">    VkFormat    format;</span><br><span class="line">    <span class="type">uint32_t</span>    offset;</span><br><span class="line">&#125; VkVertexInputAttributeDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>location</td>
<td>属性的索引</td>
<td>通常与顶点着色器中的输入变量位置相对应。</td>
</tr>
<tr>
<td>binding</td>
<td>绑定到属性的索引</td>
<td>通常与 <code>VkVertexInputBindingDescription</code> 中的 <code>binding</code> 对应。</td>
</tr>
<tr>
<td>format</td>
<td>属性的格式</td>
<td>属性的格式，指定数据的类型，如 <code>VK_FORMAT_R32G32B32_SFLOAT</code>。</td>
</tr>
<tr>
<td>offset</td>
<td>数据在顶点缓冲区中的偏移量</td>
<td></td>
</tr>
</tbody></table>
<h2 id="输入装配"><a href="#输入装配" class="headerlink" title="输入装配"></a>输入装配</h2><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a> 来描述<strong>输入装配</strong>（Input Assembly）信息，描述了<strong>几何图形类型（Geometry Type）</strong> 以及<strong>是否启用原语重启（Primitive Restart）</strong>。其描述了从顶点生成的几何图形类型，是否允许在一些拓扑模式下通过指定特殊的索引值来重启图形原语，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                pNext;</span><br><span class="line">    VkPipelineInputAssemblyStateCreateFlags    flags;</span><br><span class="line">    VkPrimitiveTopology                        topology;</span><br><span class="line">    VkBool32                                   primitiveRestartEnable;</span><br><span class="line">&#125; VkPipelineInputAssemblyStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</code>，以表明这是一个着色器管线输入装配状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>topology</td>
<td>输入装配阶段所处理的几何图形类型</td>
<td><code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>: 每个顶点作为一个独立的点。<br/><code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>: 每两个顶点组成一条线（不重复使用顶点）。<br/><code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP</code>: 每条线的结束顶点作为下一条线的起始顶点。<br/><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>: 每三个顶点组成一个独立的三角形（不重复使用顶点）。<br/><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</code>: 每个三角形的第二个和第三个顶点作为下一个三角形的前两个顶点。</td>
</tr>
<tr>
<td>primitiveRestartEnable</td>
<td>是否启用原语重启功能</td>
<td>设置为 <code>VK_TRUE</code> 启用原语重启，设置为 <code>VK_FALSE</code> 则禁用。<br/>原语重启允许你在某些拓扑模式下通过特殊的索引值（例如 <code>0xFFFF</code> 或 <code>0xFFFFFFFF</code>）来断开当前图元，重新开始一个新的图元。</td>
</tr>
</tbody></table>
<h2 id="视口和裁剪矩形"><a href="#视口和裁剪矩形" class="headerlink" title="视口和裁剪矩形"></a>视口和裁剪矩形</h2><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口描述了帧缓冲区的大小，其通常从  <code>(0, 0)</code> 到 <code>(width, height)</code> （以像素为单位），其定义了从图像到帧缓冲区的映射。需要注意的是，视口的大小应该是交换链中图像的大小，而不是窗口的大小。通过结构体 <code>VkViewport</code> 可以定义视口的属性，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkViewport</span> &#123;</span><br><span class="line">    <span class="type">float</span>    x;</span><br><span class="line">    <span class="type">float</span>    y;</span><br><span class="line">    <span class="type">float</span>    width;</span><br><span class="line">    <span class="type">float</span>    height;</span><br><span class="line">    <span class="type">float</span>    minDepth;</span><br><span class="line">    <span class="type">float</span>    maxDepth;</span><br><span class="line">&#125; VkViewport;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>视口的左上角的 X 坐标</td>
<td>该值定义了视口在帧缓冲区中的水平位置。</td>
</tr>
<tr>
<td>y</td>
<td>视口的左上角的 Y 坐标</td>
<td>该值定义了视口在帧缓冲区中的垂直位置。</td>
</tr>
<tr>
<td>width</td>
<td>视口的宽度</td>
<td>该值指定视口的水平尺寸，通常是输出图像的宽度，一般取交换链的图像宽度。</td>
</tr>
<tr>
<td>height</td>
<td>视口的高度</td>
<td>该值指定视口的垂直尺寸，通常是输出图像的高度，一般取交换链的图像高度。</td>
</tr>
<tr>
<td>minDepth</td>
<td>深度值的最小值</td>
<td>该值指定了视口的深度范围的下界，通常是 <code>0.0f</code>，但在某些情况下也可以更改。</td>
</tr>
<tr>
<td>maxDepth</td>
<td>深度值的最大值</td>
<td>该值指定了视口的深度范围的上界，通常是 <code>1.0f</code>，但在某些情况下也可以更改。</td>
</tr>
</tbody></table>
<p>注意：根据需求，最小值可以大于最大值。一个声明示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkViewport viewport&#123;&#125;;</span><br><span class="line">viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">viewport.width = (<span class="type">float</span>) swapChainExtent.width;</span><br><span class="line">viewport.height = (<span class="type">float</span>) swapChainExtent.height;</span><br><span class="line">viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">viewport.maxDepth = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="裁剪矩形"><a href="#裁剪矩形" class="headerlink" title="裁剪矩形"></a>裁剪矩形</h3><p><strong>剪裁矩形</strong>（Scissor Rectangles）定义了哪些区域的像素会实际存储。任何位于剪裁矩形之外的像素都会被光栅化器丢弃。裁剪区域由结构体 <code>VkRect2D</code> 定义，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRect2D</span> &#123;</span><br><span class="line">    VkOffset2D    offset;</span><br><span class="line">    VkExtent2D    extent;</span><br><span class="line">&#125; VkRect2D;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>offset</td>
<td>裁剪矩形的左上角位置</td>
<td><code>x</code>: 矩形左上角的水平偏移量（相对于帧缓冲区的原点）。<br /><code>y</code>: 矩形左上角的垂直偏移量（相对于帧缓冲区的原点）。</td>
</tr>
<tr>
<td>extent</td>
<td>裁剪矩形的宽度和高度</td>
<td><code>width</code>: 矩形的宽度。<br /><code>height</code>: 矩形的高度。</td>
</tr>
</tbody></table>
<p>一个声明示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkRect2D scissor&#123;&#125;;</span><br><span class="line">scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">scissor.extent = swapChainExtent;</span><br></pre></td></tr></table></figure></div>

<h3 id="视口创建"><a href="#视口创建" class="headerlink" title="视口创建"></a>视口创建</h3><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a> 完成管线<strong>视口</strong>信息的描述，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineViewportStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                       sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                           pNext;</span><br><span class="line">    VkPipelineViewportStateCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                              viewportCount;</span><br><span class="line">    <span class="type">const</span> VkViewport*                     pViewports;</span><br><span class="line">    <span class="type">uint32_t</span>                              scissorCount;</span><br><span class="line">    <span class="type">const</span> VkRect2D*                       pScissors;</span><br><span class="line">&#125; VkPipelineViewportStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</code>，以表明这是一个着色器管线视口状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>viewportCount</td>
<td>视口数量</td>
<td>描述管线中视口的数量。如果支持多视口渲染，则此值大于 1。</td>
</tr>
<tr>
<td>pViewports</td>
<td>视口数组</td>
<td>视口数组指针，其中的每个元素定义了一个视口。</td>
</tr>
<tr>
<td>scissorCount</td>
<td>剪裁矩形数量</td>
<td>剪裁矩形用于限制渲染的区域。多个剪裁矩形用于多视口渲染，通常与视口数量相匹配。</td>
</tr>
<tr>
<td>pScissors</td>
<td>裁剪矩形数组</td>
<td>裁剪矩形数组指针，其中的每个元素定义了一个裁剪矩形。</td>
</tr>
</tbody></table>
<p>在渲染管线创建时，视口和裁剪矩形能够以<strong>静态</strong>或者<strong>动态</strong>的方式指明，通常采取动态的方式。在动态方式下，需要在动态状态中指明视口 <code>VK_DYNAMIC_STATE_VIEWPORT</code> 和裁剪矩形 <code>VK_DYNAMIC_STATE_SCISSOR</code>，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;</span><br><span class="line">    VK_DYNAMIC_STATE_VIEWPORT,</span><br><span class="line">    VK_DYNAMIC_STATE_SCISSOR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;</span><br><span class="line">dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.dynamicStateCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dynamicStates.<span class="built_in">size</span>());</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;</span><br><span class="line">viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">viewportState.flags = <span class="number">0</span>;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果使用静态方式，则需要向 <code>VkPipelineViewportStateCreateInfo</code> 中传递视口和裁剪矩形数组，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;</span><br><span class="line">viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pViewports = &amp;viewport;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pScissors = &amp;scissor;</span><br></pre></td></tr></table></figure></div>

<h2 id="光栅化器"><a href="#光栅化器" class="headerlink" title="光栅化器"></a>光栅化器</h2><p><strong>光栅化器</strong>（Rasterizer）将由顶点着色器生成的几何体转换为片段（Fragments），以供片段着色器使用。在光栅化阶段，光栅化器还会执行<strong>深度测试</strong>、<strong>剔除</strong>、<strong>裁剪测试</strong>。通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a> 可以定义一个光栅化器，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                pNext;</span><br><span class="line">    VkPipelineRasterizationStateCreateFlags    flags;</span><br><span class="line">    VkBool32                                   depthClampEnable;</span><br><span class="line">    VkBool32                                   rasterizerDiscardEnable;</span><br><span class="line">    VkPolygonMode                              polygonMode;</span><br><span class="line">    VkCullModeFlags                            cullMode;</span><br><span class="line">    VkFrontFace                                frontFace;</span><br><span class="line">    VkBool32                                   depthBiasEnable;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasConstantFactor;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasClamp;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasSlopeFactor;</span><br><span class="line">    <span class="type">float</span>                                      lineWidth;</span><br><span class="line">&#125; VkPipelineRasterizationStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</code>，以表明这是一个着色器管线光栅化器状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>depthClampEnable</td>
<td>启用或禁用深度裁剪</td>
<td>默认值 <code>VK_FALSE</code>，如果设置为 <code>VK_TRUE</code>，深度值超出近平面和远平面范围的片段会被限制在这两个平面之间，而不是被丢弃。对于阴影贴图等操作，这个选项非常有用。启用此选项需要支持 <code>depthClamp</code> GPU 特性。</td>
</tr>
<tr>
<td>rasterizerDiscardEnable</td>
<td>启用或禁用跳过光栅化</td>
<td>默认值 <code>VK_FALSE</code>，如果设置为 <code>VK_TRUE</code>，几何体将跳过光栅化阶段，几何体不会被传递到片段着色器。这意味着没有片段会被生成，输出也不会写入帧缓冲区。通常用于不需要绘制的几何体，例如用于某些剔除或优化操作。</td>
</tr>
<tr>
<td>polygonMode</td>
<td>几何片段的生成模式</td>
<td>指定如何生成几何体的片段。它决定了几何体如何在屏幕上被渲染。可用的选项包括：<br/><code>VK_POLYGON_MODE_FILL</code>：填充多边形区域。<br/><code>VK_POLYGON_MODE_LINE</code>：绘制多边形的边缘作为线条（线框渲染）。<br/><code>VK_POLYGON_MODE_POINT</code>：绘制多边形的顶点作为点。<br /><code>VK_POLYGON_MODE_FILL_RECTANGLE_NV</code>：直接填充矩形区域，属于 <strong>NVIDIA</strong> 的专有扩展 <code>VK_NV_fill_rectangle</code>。<br /><code>VK_POLYGON_MODE_MAX_ENUM</code> ：保留值。<br />使用除 <code>VK_POLYGON_MODE_FILL</code> 之外的任何模式都需要启用 GPU 特性。</td>
</tr>
<tr>
<td>cullMode</td>
<td>面剔除方式</td>
<td>指定哪些面需要被剔除。可选值包括：<br/><code>VK_CULL_MODE_NONE</code>：不进行面剔除。<br/><code>VK_CULL_MODE_FRONT_BIT</code>：剔除前面。<br/><code>VK_CULL_MODE_BACK_BIT</code>：剔除背面。<br/><code>VK_CULL_MODE_FRONT_AND_BACK_BIT</code>：剔除前面和背面。<br /><code>VK_CULL_MODE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>frontFace</td>
<td>面剔除的正面的顶点顺序</td>
<td>指定正面面（front-facing）的顶点顺序，这会影响哪些面被认为是正面，哪些被认为是背面，可选值包括：<br /><code>VK_FRONT_FACE_CLOCKWISE</code>：顺时针。<br /><code>VK_FRONT_FACE_COUNTER_CLOCKWISE</code>：逆时针。<br /><code>VK_FRONT_FACE_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>depthBiasEnable</td>
<td>启用或禁用深度偏移</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用深度偏移。深度偏移用于调整片段的深度值，通常用于避免深度冲突（如阴影贴图中的“Z-fighting”）。在这种情况下，可以通过 <code>depthBiasConstantFactor</code> 和 <code>depthBiasSlopeFactor</code> 来指定偏移量。没有此需求时，应该设置为 <code>VK_FALSE</code>。</td>
</tr>
<tr>
<td>depthBiasConstantFactor</td>
<td>常数深度偏移量</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定常数深度偏移量。它通常用于在深度测试中调整深度值。</td>
</tr>
<tr>
<td>depthBiasClamp</td>
<td>深度偏移的最大值</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定深度偏移的最大值。</td>
</tr>
<tr>
<td>depthBiasSlopeFactor</td>
<td>斜率深度偏移量</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定与片段的斜率相关的深度偏移量。它用于在深度计算中根据片段的斜率来偏移深度值。</td>
</tr>
<tr>
<td>lineWidth</td>
<td>线条的宽度</td>
<td>值表示线条的厚度，以片段为单位。大于 <code>1.0f</code> 的线宽要求启用 GPU 特性 <code>wideLines</code>。线宽过大时可能需要更多的资源来渲染。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;</span><br><span class="line">rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;</span><br><span class="line">rasterizer.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">rasterizer.flags = <span class="number">0</span>;</span><br><span class="line">rasterizer.depthClampEnable = VK_FALSE;</span><br><span class="line">rasterizer.rasterizerDiscardEnable = VK_FALSE;</span><br><span class="line">rasterizer.polygonMode = VK_POLYGON_MODE_FILL;</span><br><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;</span><br><span class="line">rasterizer.depthBiasEnable = VK_FALSE;</span><br><span class="line">rasterizer.depthBiasConstantFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasClamp = <span class="number">0.0f</span>;          <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasSlopeFactor = <span class="number">0.0f</span>;    <span class="comment">// Optional</span></span><br><span class="line">rasterizer.lineWidth = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h2><p>多重采样（Multisample）是实现抗锯齿的一种方式，其通过将多个多边形的片段着色器结果组合在一起，来减少锯齿现象。多重采样主要在边缘区域工作，因为这些区域通常是最容易出现锯齿伪影的地方。通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a> 来配置多重采样，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                              pNext;</span><br><span class="line">    VkPipelineMultisampleStateCreateFlags    flags;</span><br><span class="line">    VkSampleCountFlagBits                    rasterizationSamples;</span><br><span class="line">    VkBool32                                 sampleShadingEnable;</span><br><span class="line">    <span class="type">float</span>                                    minSampleShading;</span><br><span class="line">    <span class="type">const</span> VkSampleMask*                      pSampleMask;</span><br><span class="line">    VkBool32                                 alphaToCoverageEnable;</span><br><span class="line">    VkBool32                                 alphaToOneEnable;</span><br><span class="line">&#125; VkPipelineMultisampleStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</code>，以表明这是一个着色器管线多重采样状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>rasterizationSamples</td>
<td>多重采样的样本数</td>
<td>该值决定了每个像素所采集的样本数，通常用于控制抗锯齿的效果与性能之间的权衡，可用的值包括：<br /><code>VK_SAMPLE_COUNT_1_BIT</code>：不使用多重采样。<br /><code>VK_SAMPLE_COUNT_2_BIT </code>：每像素 <code>2</code> 重采样。<br /><code>VK_SAMPLE_COUNT_4_BIT </code>：每像素 <code>4</code> 重采样。<br /><code>VK_SAMPLE_COUNT_8_BIT </code>：每像素 <code>8</code> 重采样。<br /><code>VK_SAMPLE_COUNT_16_BIT </code>：每像素 <code>16</code> 重采样。<br /><code>VK_SAMPLE_COUNT_32_BIT </code>：每像素 <code>32</code> 重采样。<br /><code>VK_SAMPLE_COUNT_64_BIT </code>：每像素 <code>64</code> 重采样。<br /><code>VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>sampleShadingEnable</td>
<td>启用或禁用样本着色</td>
<td>如果设置为 <code>VK_TRUE</code>，启用样本着色（sample shading），即对每个采样点单独进行着色计算。<br />如果设置为 <code>VK_FALSE</code>，则每个像素的所有样本使用相同的片段着色器计算结果。开启 <code>sampleShadingEnable</code> 需要设置 <code>minSampleShading</code>。</td>
</tr>
<tr>
<td>minSampleShading</td>
<td>最小采样比例</td>
<td>当 <code>sampleShadingEnable</code> 为 <code>VK_TRUE</code> 时，指定片段着色器在多重采样过程中进行采样的最小比例。<br />该值表示最小的样本着色比率，范围 <code>[0,1]</code>。如果设置为 <code>1.0</code>，表示所有的样本都必须独立着色；如果设置为较小的值，则可能使用合并样本的方式进行优化，适用于不需要完全独立着色的情况。</td>
</tr>
<tr>
<td>pSampleMask</td>
<td>每个采样点的掩码</td>
<td>一个可选的位掩码，用于指定每个采样点的掩码。每个位的值对应一个样本，如果该位为 1，则该样本被启用，否则该样本会被禁用。通常用于实现自定义的多重采样。</td>
</tr>
<tr>
<td>alphaToCoverageEnable</td>
<td>启用或禁用透明通道覆盖</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用 Alpha-to-Coverage。这个功能使用 alpha 通道来影响样本的覆盖情况，常用于抗锯齿处理，尤其是在多重采样抗锯齿（MSAA）中。</td>
</tr>
<tr>
<td>alphaToOneEnable</td>
<td>启用或禁用忽略透明通道</td>
<td>如果设置为 <code>VK_TRUE</code>，则将所有的 alpha 通道值设置为 1.0f，忽略原始 alpha 值。这个选项主要在启用了 <code>alphaToCoverageEnable</code> 时使用。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;</span><br><span class="line">multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;</span><br><span class="line">multisampling.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">multisampling.flags = <span class="number">0</span>;</span><br><span class="line">multisampling.sampleShadingEnable = VK_FALSE;</span><br><span class="line">multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">multisampling.minSampleShading = <span class="number">1.0f</span>;          </span><br><span class="line">multisampling.pSampleMask = <span class="literal">nullptr</span>;            </span><br><span class="line">multisampling.alphaToCoverageEnable = VK_FALSE; </span><br><span class="line">multisampling.alphaToOneEnable = VK_FALSE; </span><br></pre></td></tr></table></figure></div>

<h2 id="深度和模版测试"><a href="#深度和模版测试" class="headerlink" title="深度和模版测试"></a>深度和模版测试</h2><h3 id="模版测试"><a href="#模版测试" class="headerlink" title="模版测试"></a>模版测试</h3><p>通过结构体 <code>VkStencilOpState</code> 完成对于模版测试的配置，其定义了如何在模板测试阶段对模板缓冲区进行处理，包括模板比较、模板操作等，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkStencilOpState</span> &#123;</span><br><span class="line">    VkStencilOp    failOp;</span><br><span class="line">    VkStencilOp    passOp;</span><br><span class="line">    VkStencilOp    depthFailOp;</span><br><span class="line">    VkCompareOp    compareOp;</span><br><span class="line">    <span class="type">uint32_t</span>       compareMask;</span><br><span class="line">    <span class="type">uint32_t</span>       writeMask;</span><br><span class="line">    <span class="type">uint32_t</span>       reference;</span><br><span class="line">&#125; VkStencilOpState;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>failOp</td>
<td>模板测试失败时执行的操作</td>
<td>模板比较失败后如何处理模板值。常见操作包括：<br /><code>VK_STENCIL_OP_KEEP</code>：保持当前模板值。<br/><code>VK_STENCIL_OP_ZERO</code>：将模板值设为 0。<br/><code>VK_STENCIL_OP_REPLACE</code>：将模板值替换为参考值。<br/><code>VK_STENCIL_OP_INCREMENT_AND_CLAMP</code>：递增模板值，并且将其限制在最大值。<br/><code>VK_STENCIL_OP_DECREMENT_AND_CLAMP</code>：递减模板值，并且将其限制在最小值。<br/><code>VK_STENCIL_OP_INVERT</code>：反转模板值。<br/><code>VK_STENCIL_OP_INCREMENT_AND_WRAP</code>：递增模版值，并在模板值达到最大值时回绕回最小值。<br/><code>VK_STENCIL_OP_DECREMENT_AND_WRAP</code>：递减模板值，并在模板值达到最小值时回绕回最大值。<br/><code>VK_STENCIL_OP_MAX_ENUM</code>：保留值</td>
</tr>
<tr>
<td>passOp</td>
<td>模板测试通过时执行的操作</td>
<td>模板比较通过后如何处理模板值。常见操作与 <code>failOp</code> 类似，提供了对模板缓冲区的修改选项。</td>
</tr>
<tr>
<td>depthFailOp</td>
<td>模板测试通过但深度测试失败时执行的操作</td>
<td>当模板测试成功，但片段的深度与深度缓冲区中的值进行比较时，如果深度测试失败，则执行此操作。常见操作同 <code>failOp</code> 和 <code>passOp</code>，用于在深度测试失败时处理模板值。</td>
</tr>
<tr>
<td>compareOp</td>
<td>模版比较操作</td>
<td>指定模板比较操作，决定如何比较模板参考值和模板缓冲区中的模板值。常见的比较操作包括：<br /><code>VK_COMPARE_OP_NEVER</code>：永远失败。<br/><code>VK_COMPARE_OP_LESS</code>：片段深度小于当前深度时通过。<br/><code>VK_COMPARE_OP_EQUAL</code>：片段深度等于当前深度时通过。<br/><code>VK_COMPARE_OP_LESS_OR_EQUAL</code>：片段深度小于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER</code>：片段深度大于当前深度时通过。<br/><code>VK_COMPARE_OP_NOT_EQUAL</code>：片段深度不等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER_OR_EQUAL</code>：片段深度大于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_ALWAYS</code>：永远通过。<br/><code>VK_COMPARE_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>compareMask</td>
<td>模板比较掩码</td>
<td>此掩码与模板值进行按位与操作后再进行比较，以控制哪些位参与比较。设置为 <code>0xFF</code> 时表示所有位都参与比较。</td>
</tr>
<tr>
<td>writeMask</td>
<td>模版写入掩码</td>
<td>指定哪些位可以写入模板缓冲区。如果某个位被掩码屏蔽，则该位的值不会被修改。通常设置为 <code>0xFF</code> 表示所有位都可以被修改。</td>
</tr>
<tr>
<td>reference</td>
<td>模板参考值</td>
<td>与模板缓冲区中的模板值进行比较时使用的参考值。该值通常由应用程序设置，并用于与模板缓冲区中的模板值进行比较，依据 <code>compareOp</code> 的值决定比较规则。</td>
</tr>
</tbody></table>
<h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>通过结构体<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a> 完成对于深度测试和模版测试的配置，控制如何进行深度比较、模板操作以及深度和模板的写入，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineDepthStencilStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                           sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                               pNext;</span><br><span class="line">    VkPipelineDepthStencilStateCreateFlags    flags;</span><br><span class="line">    VkBool32                                  depthTestEnable;</span><br><span class="line">    VkBool32                                  depthWriteEnable;</span><br><span class="line">    VkCompareOp                               depthCompareOp;</span><br><span class="line">    VkBool32                                  depthBoundsTestEnable;</span><br><span class="line">    VkBool32                                  stencilTestEnable;</span><br><span class="line">    VkStencilOpState                          front;</span><br><span class="line">    VkStencilOpState                          back;</span><br><span class="line">    <span class="type">float</span>                                     minDepthBounds;</span><br><span class="line">    <span class="type">float</span>                                     maxDepthBounds;</span><br><span class="line">&#125; VkPipelineDepthStencilStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</code>，以表明这是一个着色器管线深度和模版状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>depthTestEnable</td>
<td>启用或禁用深度测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用深度测试，片段的深度值将不会与深度缓冲区中的值进行比较。</td>
</tr>
<tr>
<td>depthWriteEnable</td>
<td>启用或禁用深度写入</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用深度写入，片段的深度值将不会写入深度缓冲区，但仍然可以进行深度比较。</td>
</tr>
<tr>
<td>depthCompareOp</td>
<td>深度比较操作</td>
<td>指定深度比较操作，控制如何对比片段的深度值和深度缓冲区中的现有深度值。常见的值包括：<br/><code>VK_COMPARE_OP_NEVER</code>：永远失败。<br/><code>VK_COMPARE_OP_LESS</code>：片段深度小于当前深度时通过（常用）。<br/><code>VK_COMPARE_OP_EQUAL</code>：片段深度等于当前深度时通过。<br/><code>VK_COMPARE_OP_LESS_OR_EQUAL</code>：片段深度小于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER</code>：片段深度大于当前深度时通过。<br/><code>VK_COMPARE_OP_NOT_EQUAL</code>：片段深度不等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER_OR_EQUAL</code>：片段深度大于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_ALWAYS</code>：永远通过。<br/><code>VK_COMPARE_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>depthBoundsTestEnable</td>
<td>启用或禁用深度边界测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果启用，片段的深度值将被检查是否在 <code>minDepthBounds</code> 和 <code>maxDepthBounds</code> 指定的深度范围内。</td>
</tr>
<tr>
<td>stencilTestEnable</td>
<td>启用或禁用模版测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用模板测试，模板缓冲区中的值将不会参与比较操作。</td>
</tr>
<tr>
<td>front</td>
<td>配置前面（顺时针）面的模板操作</td>
<td><code>VkStencilOpState</code> 定义的模版操作。</td>
</tr>
<tr>
<td>back</td>
<td>配置背面（逆时针）面的模板操作</td>
<td><code>VkStencilOpState</code> 定义的模版操作。</td>
</tr>
<tr>
<td>minDepthBounds</td>
<td>深度边界的最小值</td>
<td>仅在 <code>depthBoundsTestEnable</code> 为 <code>VK_TRUE</code> 时有效。</td>
</tr>
<tr>
<td>maxDepthBounds</td>
<td>深度边界的最大值</td>
<td>仅在 <code>depthBoundsTestEnable</code> 为 <code>VK_TRUE</code> 时有效。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">VkPipelineDepthStencilStateCreateInfo depthStencil&#123;&#125;;</span><br><span class="line">depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;</span><br><span class="line">depthStencil.pNext = nullptr;</span><br><span class="line">depthStencil.flags = 0;</span><br><span class="line">depthStencil.depthTestEnable = VK_TRUE;</span><br><span class="line">depthStencil.depthWriteEnable = VK_TRUE;</span><br><span class="line">depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;</span><br><span class="line">depthStencil.depthBoundsTestEnable = VK_FALSE;</span><br><span class="line">depthStencil.stencilTestEnable = VK_FALSE;</span><br><span class="line">depthStencil.front = &#123;&#125;;            </span><br><span class="line">depthStencil.back = &#123;&#125;;             </span><br><span class="line">depthStencil.minDepthBounds = 0.0f; </span><br><span class="line">depthStencil.maxDepthBounds = 1.0f; </span><br></pre></td></tr></table></figure></div>

<h2 id="颜色混合"><a href="#颜色混合" class="headerlink" title="颜色混合"></a>颜色混合</h2><p>在片段着色器返回颜色之后，它需要与已经存在于帧缓冲区中的颜色进行合成。这一转换过程称为颜色混合（Color Blending）。颜色混合有两种方式来实现：1.将旧的颜色值与新的颜色值混合，生成最终的颜色；2.使用位操作将旧的颜色值与新的颜色值组合。</p>
<p>在颜色混合中，可以通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a> 来配置每一个附加缓冲区的混合设置，也可以通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a> 来配置全局的混色设置。</p>
<p>结构体 <code>VkPipelineColorBlendAttachmentState</code> 的声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineColorBlendAttachmentState</span> &#123;</span><br><span class="line">    VkBool32                 blendEnable;</span><br><span class="line">    VkBlendFactor            srcColorBlendFactor;</span><br><span class="line">    VkBlendFactor            dstColorBlendFactor;</span><br><span class="line">    VkBlendOp                colorBlendOp;</span><br><span class="line">    VkBlendFactor            srcAlphaBlendFactor;</span><br><span class="line">    VkBlendFactor            dstAlphaBlendFactor;</span><br><span class="line">    VkBlendOp                alphaBlendOp;</span><br><span class="line">    VkColorComponentFlags    colorWriteMask;</span><br><span class="line">&#125; VkPipelineColorBlendAttachmentState;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>blendEnable</td>
<td>启用或禁用颜色混合操作</td>
<td><code>VK_FALSE</code>: 禁用颜色混合操作（即直接使用着色器的输出颜色）。<br/><code>VK_TRUE</code>: 启用颜色混合操作。</td>
</tr>
<tr>
<td>srcColorBlendFactor</td>
<td>源颜色混合因子</td>
<td>指定源颜色混合因子，即源颜色与目标颜色混合时的比例。可选值为<br /><code>VK_BLEND_FACTOR_ZERO </code>： 乘数为零。<br/><code>VK_BLEND_FACTOR_ONE </code>： 乘数为一。<br/><code>VK_BLEND_FACTOR_SRC_COLOR </code>： 使用源颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR </code>： 使用源颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_DST_COLOR </code>： 使用目标颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR </code>： 使用目标颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_SRC_ALPHA </code>： 使用源颜色的alpha通道值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA </code>： 使用源颜色的alpha通道补色作为乘数。<br/><code>VK_BLEND_FACTOR_DST_ALPHA </code>： 使用目标颜色的alpha通道值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA </code>： 使用目标颜色的alpha通道补色作为乘数。<br/><code>VK_BLEND_FACTOR_CONSTANT_COLOR </code>： 使用常量颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR </code>： 使用常量颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_CONSTANT_ALPHA </code>： 使用常量alpha值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA </code>： 使用常量alpha值的补色作为乘数。<br/><code>VK_BLEND_FACTOR_SRC_ALPHA_SATURATE </code>： 使用源alpha通道的饱和度（通常用于alpha混合和边缘处理）。<br/><code>VK_BLEND_FACTOR_SRC1_COLOR </code>： 使用第二个源颜色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR </code>： 使用第二个源颜色的补色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_SRC1_ALPHA </code>： 使用第二个源alpha值作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </code>： 使用第二个源alpha值的补色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>dstColorBlendFactor</td>
<td>目标颜色混合因子</td>
<td>指定目标颜色混合因子，即目标颜色与源颜色混合时的比例。可选值与 <code>srcColorBlendFactor</code> 相同。</td>
</tr>
<tr>
<td>colorBlendOp</td>
<td>颜色值的混合操作</td>
<td>决定了如何将源颜色（来自片段着色器）与目标颜色（来自帧缓冲区）混合。可选值：<br /><code>VK_BLEND_OP_ADD </code>： 源颜色和目标颜色相加（标准的颜色混合操作）。<br/><code>VK_BLEND_OP_SUBTRACT </code>： 源颜色减去目标颜色。<br/><code>VK_BLEND_OP_REVERSE_SUBTRACT </code>： 目标颜色减去源颜色。<br/><code>VK_BLEND_OP_MIN </code>： 选择源颜色和目标颜色中的最小值。<br/><code>VK_BLEND_OP_MAX </code>： 选择源颜色和目标颜色中的最大值。<br/><code>VK_BLEND_OP_ZERO_EXT </code>： 混合时使用零值。<br/><code>VK_BLEND_OP_SRC_EXT </code>： 使用源颜色作为混合结果。<br/><code>VK_BLEND_OP_DST_EXT </code>： 使用目标颜色作为混合结果。<br/><code>VK_BLEND_OP_SRC_OVER_EXT </code>： 源颜色覆盖目标颜色。<br/><code>VK_BLEND_OP_DST_OVER_EXT </code>： 目标颜色覆盖源颜色。<br/><code>VK_BLEND_OP_SRC_IN_EXT </code>： 仅源颜色与目标交集部分进行显示。<br/><code>VK_BLEND_OP_DST_IN_EXT </code>： 仅目标颜色与源交集部分进行显示。<br/><code>VK_BLEND_OP_SRC_OUT_EXT </code>： 显示源颜色，但排除与目标颜色重叠的部分。<br/><code>VK_BLEND_OP_DST_OUT_EXT </code>： 显示目标颜色，但排除与源颜色重叠的部分。<br/><code>VK_BLEND_OP_SRC_ATOP_EXT </code>： 将源颜色“放置”在目标颜色上，仅保留源的交集部分。<br/><code>VK_BLEND_OP_DST_ATOP_EXT </code>： 将目标颜色“放置”在源颜色上，仅保留目标的交集部分。<br/><code>VK_BLEND_OP_XOR_EXT </code>： 仅显示源和目标的非交集部分。<br/><code>VK_BLEND_OP_MULTIPLY_EXT </code>： 乘法模式，常用于阴影效果。<br/><code>VK_BLEND_OP_SCREEN_EXT </code>： 屏幕模式，通常用于高光效果。<br/><code>VK_BLEND_OP_OVERLAY_EXT </code>： 覆盖模式，结合了乘法和屏幕模式。<br/><code>VK_BLEND_OP_DARKEN_EXT </code>： 暗化模式，显示源和目标的较暗部分。<br/><code>VK_BLEND_OP_LIGHTEN_EXT </code>： 亮化模式，显示源和目标的较亮部分。<br/><code>VK_BLEND_OP_COLORDODGE_EXT </code>： 颜色闪避模式，通常用于增强高光效果。<br/><code>VK_BLEND_OP_COLORBURN_EXT </code>： 颜色加深模式，通常用于增加阴影效果。<br/><code>VK_BLEND_OP_HARDLIGHT_EXT </code>： 硬光模式，结合了亮化和暗化的效果。<br/><code>VK_BLEND_OP_SOFTLIGHT_EXT </code>： 柔光模式，通常用于对图像进行柔和的亮化和暗化处理。<br/><code>VK_BLEND_OP_DIFFERENCE_EXT </code>： 差异模式，显示源和目标的差异部分。<br/><code>VK_BLEND_OP_EXCLUSION_EXT </code>： 排除模式，类似于差异模式，但产生更柔和的效果。<br/><code>VK_BLEND_OP_INVERT_EXT </code>： 反转模式，反转目标颜色。<br/><code>VK_BLEND_OP_INVERT_RGB_EXT </code>： 反转RGB模式，反转目标颜色的RGB通道。<br/><code>VK_BLEND_OP_LINEARDODGE_EXT </code>： 线性闪避模式。<br/><code>VK_BLEND_OP_LINEARBURN_EXT </code>： 线性加深模式。<br/><code>VK_BLEND_OP_VIVIDLIGHT_EXT </code>： 鲜明光模式。<br/><code>VK_BLEND_OP_LINEARLIGHT_EXT </code>： 线性光模式。<br/><code>VK_BLEND_OP_PINLIGHT_EXT </code>： 刺光模式。<br/><code>VK_BLEND_OP_HARDMIX_EXT </code>： 硬混合模式。<br/><code>VK_BLEND_OP_HSL_HUE_EXT </code>： 色相模式。<br/><code>VK_BLEND_OP_HSL_SATURATION_EXT </code>： 饱和度模式。<br/><code>VK_BLEND_OP_HSL_COLOR_EXT </code>： 色彩模式。<br/><code>VK_BLEND_OP_HSL_LUMINOSITY_EXT </code>： 明度模式。<br/><code>VK_BLEND_OP_PLUS_EXT </code>： 加法模式。<br/><code>VK_BLEND_OP_PLUS_CLAMPED_EXT </code>： 有限加法模式。<br/><code>VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT </code>： 带alpha的加法模式。<br/><code>VK_BLEND_OP_PLUS_DARKER_EXT </code>： 加法黑暗模式。<br/><code>VK_BLEND_OP_MINUS_EXT </code>： 减法模式。<br/><code>VK_BLEND_OP_MINUS_CLAMPED_EXT </code>： 有限减法模式。<br/><code>VK_BLEND_OP_CONTRAST_EXT </code>： 对比模式。<br/><code>VK_BLEND_OP_INVERT_OVG_EXT </code>： 反转OVG模式。<br/><code>VK_BLEND_OP_RED_EXT </code>： 仅处理红色通道。<br/><code>VK_BLEND_OP_GREEN_EXT </code>： 仅处理绿色通道。<br/><code>VK_BLEND_OP_BLUE_EXT </code>： 仅处理蓝色通道。<br/><code>VK_BLEND_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>srcAlphaBlendFactor</td>
<td>源alpha混合因子</td>
<td>类似于 <code>srcColorBlendFactor</code>，但只影响alpha通道。</td>
</tr>
<tr>
<td>dstAlphaBlendFactor</td>
<td>目标alpha混合因子</td>
<td>类似于 <code>dstColorBlendFactor</code>，但仅影响alpha通道。</td>
</tr>
<tr>
<td>alphaBlendOp</td>
<td>alpha通道的混合操作</td>
<td>与 <code>colorBlendOp</code> 类似，但仅应用于alpha值（透明度）。</td>
</tr>
<tr>
<td>colorWriteMask</td>
<td>参与混合的颜色分量掩码</td>
<td>这个掩码决定了哪些颜色通道的值将会被写入到帧缓冲区，可以通过按位或 &#96;</td>
</tr>
</tbody></table>
<p>一种常用的颜色混合方式为 alpha 混合，在这种情况下，新颜色根据其透明度与旧颜色混合，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;</span><br><span class="line">colorBlendAttachment.blendEnable = VK_TRUE;</span><br><span class="line">colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</span><br><span class="line">colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;</span><br><span class="line">colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;</span><br></pre></td></tr></table></figure></div>

<p>结构体 <code>VkPipelineColorBlendStateCreateInfo</code> 的声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                               sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                   pNext;</span><br><span class="line">    VkPipelineColorBlendStateCreateFlags          flags;</span><br><span class="line">    VkBool32                                      logicOpEnable;</span><br><span class="line">    VkLogicOp                                     logicOp;</span><br><span class="line">    <span class="type">uint32_t</span>                                      attachmentCount;</span><br><span class="line">    <span class="type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;</span><br><span class="line">    <span class="type">float</span>                                         blendConstants[<span class="number">4</span>];</span><br><span class="line">&#125; VkPipelineColorBlendStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</code>，以表明这是一个着色器管线颜色混合创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>logicOpEnable</td>
<td>启用或禁用逻辑操作</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用按位操作模式，<code>logicOp</code> 字段将指定使用的逻辑操作。如果设置为 <code>VK_FALSE</code>，则使用标准的颜色混合。</td>
</tr>
<tr>
<td>logicOp</td>
<td></td>
<td><code>VK_LOGIC_OP_CLEAR</code>：将结果清空，所有位都设置为 0。<br/><code>VK_LOGIC_OP_AND</code>：按位与操作，两个操作数的相应位都为 1 时，结果才为 1。<br/><code>VK_LOGIC_OP_AND_REVERSE</code>：按位与操作，源操作数与目标操作数按位与操作，但反转源操作数。即源的位与目标的位按位与，源的位要反转。<br/><code>VK_LOGIC_OP_COPY</code>：将源操作数直接拷贝到结果中，不做任何改变。<br/><code>VK_LOGIC_OP_AND_INVERTED </code>：按位与操作，目标操作数与源操作数按位与操作，但反转目标操作数。即源的位与目标的位按位与，目标的位要反转。<br/><code>VK_LOGIC_OP_NO_OP</code>：无操作，不做任何修改。结果等于源操作数。<br/><code>VK_LOGIC_OP_XOR</code>：按位异或操作，相同位的结果为 0，不同位的结果为 1。<br/><code>VK_LOGIC_OP_OR</code>：按位或操作，只要其中一个操作数的位为 1，结果就是 1。<br/><code>VK_LOGIC_OP_NOR</code>：按位或操作的反操作，即按位或的结果反转。只有在源和目标的位都为 0 时，结果为 1。<br/><code>VK_LOGIC_OP_EQUIVALENT</code>：按位等价操作。当两个操作数的位相同时，结果为 1；否则，结果为 0。<br/><code>VK_LOGIC_OP_INVERT</code>：将源操作数的所有位反转。<br/><code>VK_LOGIC_OP_OR_REVERSE</code>：按位或操作，源操作数与目标操作数按位或，但反转源操作数。<br/><code>VK_LOGIC_OP_COPY_INVERTED</code>：将源操作数反转后拷贝到结果中。<br/><code>VK_LOGIC_OP_OR_INVERTED</code>：按位或操作，目标操作数与源操作数按位或，但反转目标操作数。<br/><code>VK_LOGIC_OP_NAND</code>：按位与的反操作，即源和目标的位按位与后结果取反。<br/><code>VK_LOGIC_OP_SET</code>：将结果设置为 1，所有位都设置为 1。<br/><code>VK_LOGIC_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>attachmentCount</td>
<td>颜色附件数组大小</td>
<td>通常设置为1，表示有一个附加的颜色附件。</td>
</tr>
<tr>
<td>pAttachments</td>
<td>颜色附件数组</td>
<td>数组中的每个元素配置了单个颜色附件的混合状态。数组的长度由 <code>attachmentCount</code> 确定，通常只有一个元素。</td>
</tr>
<tr>
<td>blendConstants</td>
<td>混合操作常量数组</td>
<td>在颜色混合操作中，<code>blendConstants</code> 提供了额外的参数，允许你在混合计算中使用常量值。通常，<code>blendConstants</code> 数组中的每个元素都可以用作 <code>colorBlendOp</code> 操作的参数之一。对于 alpha 混合，常常使用其中的 <code>blendConstants[0]</code> 和 <code>blendConstants[1]</code> 等值。</td>
</tr>
</tbody></table>
<p>注意：当 <code>logicOpEnable</code> 设置为 <code>VK_TRUE</code> 时，对于 <code>pAttachments</code> 中的每个元素，<code>blendEnable</code> 将默认为 <code>VK_FALSE</code>。一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;</span><br><span class="line">colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;</span><br><span class="line">colorBlending.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">colorBlending.flags = <span class="number">0</span>;</span><br><span class="line">colorBlending.logicOpEnable = VK_FALSE;</span><br><span class="line">colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.attachmentCount = <span class="number">1</span>;</span><br><span class="line">colorBlending.pAttachments = &amp;colorBlendAttachment;</span><br><span class="line">colorBlending.blendConstants[<span class="number">0</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">1</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">2</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">3</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure></div>

<h2 id="管线布局"><a href="#管线布局" class="headerlink" title="管线布局"></a>管线布局</h2><p>在着色器中，可以使用统一值（uniform values）来动态的决定着色器的行为，比如在顶点着色器中应用<strong>变换矩阵</strong>。在 Vulkan 中，对于统一值的管理需要在着色器创建时通过<strong>管线布局</strong>（Pipeline Layout）来管理。通过 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a> 结构体来描述管线布局信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkPipelineLayoutCreateFlags     flags;</span><br><span class="line">    <span class="type">uint32_t</span>                        setLayoutCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">    <span class="type">uint32_t</span>                        pushConstantRangeCount;</span><br><span class="line">    <span class="type">const</span> VkPushConstantRange*      pPushConstantRanges;</span><br><span class="line">&#125; VkPipelineLayoutCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</code>，以表明这是一个着色器管线布局创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>当设置 <code>VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT</code> 标志时，表示描述符集（Descriptor Sets）在管线布局中的绑定不受管线阶段的影响，即它们是独立的。换句话说，每个描述符集的绑定不会受到管线阶段的影响，从而允许更多的灵活性。其他情况应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>setLayoutCount</td>
<td>描述符集布局数量</td>
<td>管线布局中描述符集布局（descriptor set layout）的数量。可以是 0 或更大的值，指示管线使用了多少个描述符集布局。</td>
</tr>
<tr>
<td>pSetLayouts</td>
<td>描述符集布局数组</td>
<td>指向 <code>VkDescriptorSetLayout</code> 类型数组的指针，描述每个描述符集布局的设置。这个数组的大小由 <code>setLayoutCount</code> 指定。描述符集布局用于定义着色器程序中使用的资源，如纹理、缓冲区等。</td>
</tr>
<tr>
<td>pushConstantRangeCount</td>
<td>推送常量的数量</td>
<td>管线布局中推送常量的数量。推送常量用于在渲染过程中动态修改着色器程序中的某些常量值。</td>
</tr>
<tr>
<td>pPushConstantRanges</td>
<td>推送常量数组</td>
<td>指向 <code>VkPushConstantRange</code> 结构体数组的指针，描述每个推送常量的范围。每个推送常量范围指定了常量的大小、起始位置以及它可以用于哪些着色器阶段（如顶点着色器、片段着色器等）。</td>
</tr>
</tbody></table>
<p>在完成管线布局信息的描述之后，需要通过 <code>vkCreatePipelineLayout</code> 函数来完成管线布局的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreatePipelineLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkPipelineLayoutCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout*                           pPipelineLayout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要创建管线布局的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>创建信息指针</td>
<td>指向 <code>VkPipelineLayoutCreateInfo</code> 结构体的指针，用于描述管线布局的详细信息。该结构体包含了管线布局的创建信息，如描述符集布局、推送常量的范围等。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPipelineLayout</td>
<td>管线布局对象句柄</td>
<td>函数执行成功后，<code>pPipelineLayout</code> 将返回一个有效的管线布局对象句柄。这个句柄可以在后续创建管线时使用。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示窗口表面是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示窗口创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>在管线布局对象使用完毕后，需要通过函数 <code>vkDestroyPipelineLayout</code> 显式地摧毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyPipelineLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            pipelineLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要销毁管线布局的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipelineLayout</td>
<td>创建信息句斌</td>
<td>要销毁的管线布局对象句柄</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建管线布局对象时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pSetLayouts = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pushConstantRangeCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pPushConstantRanges = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create pipeline layout!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="着色器阶段"><a href="#着色器阶段" class="headerlink" title="着色器阶段"></a>着色器阶段</h2><p>通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineShaderStageCreateInfo.html"><code>VkPipelineShaderStageCreateInfo</code></a> 来描述一个着色器管线阶段创建信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineShaderStageCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                     sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                         pNext;</span><br><span class="line">    VkPipelineShaderStageCreateFlags    flags;</span><br><span class="line">    VkShaderStageFlagBits               stage;</span><br><span class="line">    VkShaderModule                      <span class="keyword">module</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*                         pName;</span><br><span class="line">    <span class="type">const</span> VkSpecializationInfo*         pSpecializationInfo;</span><br><span class="line">&#125; VkPipelineShaderStageCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</code>，以表明这是一个着色器管线阶段创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>用于控制着色器阶段的行为，通常设置为 <code>0</code>。某些特殊的标志可以由扩展或特定的管线需求使用。</td>
</tr>
<tr>
<td>stage</td>
<td>色器所在的管线阶段</td>
<td><code>VkShaderStageFlagBits</code> 是一个枚举类型，包含了所有可能的着色器阶段，常见的值包括：<br/><code>VK_SHADER_STAGE_VERTEX_BIT</code>：顶点着色器阶段<br/><code>VK_SHADER_STAGE_FRAGMENT_BIT</code>：片段着色器阶段<br/><code>VK_SHADER_STAGE_COMPUTE_BIT</code>：计算着色器阶段<br/><code>VK_SHADER_STAGE_GEOMETRY_BIT</code>：几何着色器阶段<br/><code>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</code>：细分控制着色器阶段<br/><code>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</code>：细分评估着色器阶段<br/><code>VK_SHADER_STAGE_ALL_GRAPHICS</code>：所有图形管线阶段<br/><code>VK_SHADER_STAGE_ALL</code>：所有着色器阶段</td>
</tr>
<tr>
<td>module</td>
<td>着色器模块句柄</td>
<td>指向一个已创建的着色器模块，其中包含了编译后的 SPIR-V 字节码。在创建管线时，Vulkan 将使用该着色器模块来编译并与管线其他阶段连接。</td>
</tr>
<tr>
<td>pName</td>
<td>入口点的名称</td>
<td>在着色器中定义的主函数名。大多数情况下，着色器的入口点是 <code>main</code>，但也可以根据需要指定其他入口点。</td>
</tr>
<tr>
<td>pSpecializationInfo</td>
<td>指向 <code>VkSpecializationInfo</code> 结构体的指针</td>
<td>包含了与着色器相关的常量值。通过设置此结构，您可以在管线创建时为着色器提供常量值。这是一个可选成员，如果不需要常量值，可以将其设置为 <code>nullptr</code>。</td>
</tr>
</tbody></table>
<h1 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h1><p>最后，将所有的管线状态创建信息组合起来就可以完成图形管线（Graphics Pipeline）的创建，通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a> 来完成图形管线信息的描述，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkGraphicsPipelineCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                      pNext;</span><br><span class="line">    VkPipelineCreateFlags                            flags;</span><br><span class="line">    <span class="type">uint32_t</span>                                         stageCount;</span><br><span class="line">    <span class="type">const</span> VkPipelineShaderStageCreateInfo*           pStages;</span><br><span class="line">    <span class="type">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;</span><br><span class="line">    <span class="type">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;</span><br><span class="line">    <span class="type">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;</span><br><span class="line">    <span class="type">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;</span><br><span class="line">    <span class="type">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;</span><br><span class="line">    <span class="type">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;</span><br><span class="line">    <span class="type">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;</span><br><span class="line">    <span class="type">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;</span><br><span class="line">    <span class="type">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;</span><br><span class="line">    VkPipelineLayout                                 layout;</span><br><span class="line">    VkRenderPass                                     renderPass;</span><br><span class="line">    <span class="type">uint32_t</span>                                         subpass;</span><br><span class="line">    VkPipeline                                       basePipelineHandle;</span><br><span class="line">    <span class="type">int32_t</span>                                          basePipelineIndex;</span><br><span class="line">&#125; VkGraphicsPipelineCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</code>，以表明这是一个图形管线创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于图形管线创建时的附加标志。</td>
<td>如果没有特殊需求，通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>stageCount</td>
<td>着色器阶段数量</td>
<td>图形管线中着色器阶段的数量。即 <code>pStages</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pStages</td>
<td>着色器阶段数组</td>
<td>指向一个数组，数组的元素类型是 <code>VkPipelineShaderStageCreateInfo</code>，每个元素描述一个着色器阶段的详细信息。每个阶段通常包括一个着色器模块（如顶点着色器、片段着色器等）及其相关设置。</td>
</tr>
<tr>
<td>pVertexInputState</td>
<td>顶点输入状态</td>
<td>指向一个 <code>VkPipelineVertexInputStateCreateInfo</code> 结构体，定义了顶点输入状态，即顶点数据如何组织和传递给管线。</td>
</tr>
<tr>
<td>pInputAssemblyState</td>
<td>输入组装状态</td>
<td>指向一个 <code>VkPipelineInputAssemblyStateCreateInfo</code> 结构体，定义了如何将顶点输入组装成图元（例如，点、线、三角形等）。</td>
</tr>
<tr>
<td>pTessellationState</td>
<td>细分状态</td>
<td>指向一个 <code>VkPipelineTessellationStateCreateInfo</code> 结构体的指针，定义了细分阶段的配置。</td>
</tr>
<tr>
<td>pViewportState</td>
<td>视口状态</td>
<td>指向一个 <code>VkPipelineViewportStateCreateInfo</code> 结构体，定义视口设置（包括视口数量和裁剪矩形的数量）。</td>
</tr>
<tr>
<td>pRasterizationState</td>
<td>光栅化状态</td>
<td>指向一个 <code>VkPipelineRasterizationStateCreateInfo</code> 结构体，定义光栅化阶段的状态，包括如何转换顶点数据为片段数据的设置。</td>
</tr>
<tr>
<td>pMultisampleState</td>
<td>多重采样状态</td>
<td>指向一个 <code>VkPipelineMultisampleStateCreateInfo</code> 结构体，定义多重采样状态，影响如何进行抗锯齿处理。</td>
</tr>
<tr>
<td>pDepthStencilState</td>
<td>深度和模板测试状态</td>
<td>指向一个 <code>VkPipelineDepthStencilStateCreateInfo</code> 结构体，定义深度和模板测试的状态，决定如何处理深度信息和模板缓冲区。</td>
</tr>
<tr>
<td>pColorBlendState</td>
<td>颜色混合状态</td>
<td>指向一个 <code>VkPipelineColorBlendStateCreateInfo</code> 结构体，定义颜色混合状态，描述如何将颜色值合并到目标图像中。</td>
</tr>
<tr>
<td>pDynamicState</td>
<td>动态状态</td>
<td>指向一个 <code>VkPipelineDynamicStateCreateInfo</code> 结构体，定义哪些管线状态将是动态的，可以在渲染期间更新，而不是在管线创建时设置。</td>
</tr>
<tr>
<td>layout</td>
<td>管线布局句柄</td>
<td>指定着色器阶段可以访问的统一变量和推送常量的布局。它决定了管线和着色器之间的接口。</td>
</tr>
<tr>
<td>renderPass</td>
<td>渲染通道句柄</td>
<td>渲染通道句柄，定义了图形管线的渲染过程所使用的附件以及它们的用途。</td>
</tr>
<tr>
<td>subpass</td>
<td>子通道索引</td>
<td>渲染通道中的子通道索引，指示此图形管线将在渲染通道中的哪个子通道中被使用。子通道是渲染过程中不同阶段的分割。</td>
</tr>
<tr>
<td>basePipelineHandle</td>
<td>基管线句柄</td>
<td>用于派生新管线的基管线句柄。如果创建的是派生管线，这个字段指定现有管线作为父管线。若不派生管线，设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
<tr>
<td>basePipelineIndex</td>
<td>基管线索引</td>
<td>用于派生新管线时，指定父管线在管线数组中的索引。如果没有派生管线，设置为 <code>-1</code>。</td>
</tr>
</tbody></table>
<p>在填写完成管线创建信息的结构体后，需要调用函数 <code>vkCreateGraphicsPipelines</code> 来完成图形管线的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateGraphicsPipelines</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineCache                             pipelineCache,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    createInfoCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkGraphicsPipelineCreateInfo*         pCreateInfos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipeline*                                 pPipelines)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要创建图形管线的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipelineCache</td>
<td>管线缓存对象</td>
<td>可选的管线缓存对象。它是用于加速多个管线创建过程的缓存，可以存储已经创建的管线信息，以供以后重用。可以传递 <code>VK_NULL_HANDLE</code> 表示不使用缓存。</td>
</tr>
<tr>
<td>输入参数</td>
<td>createInfoCount</td>
<td>创建的图形管线数量</td>
<td>要创建的图形管线数量。通常情况下，它的值为 1，但可以指定多个管线创建信息结构体数组。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfos</td>
<td>图形管线创建信息数组</td>
<td>一个指向 <code>VkGraphicsPipelineCreateInfo</code> 结构体数组的指针，包含了每个图形管线的配置信息。该结构体用于定义图形管线的各个阶段（如着色器、固定功能状态、管线布局、渲染通道等）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPipelines</td>
<td>图形管线对象的句柄数组</td>
<td>输出参数，指向一个数组，在函数成功执行时，返回创建的图形管线对象的句柄。数组的大小应为 <code>createInfoCount</code>，每个元素对应一个创建的图形管线。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>图形管线创建结果</td>
<td>返回值是一个 <code>VkResult</code> 类型，表示函数的执行结果。常见的返回值有：<br /><code>VK_SUCCESS</code>：表示管线成功创建。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足。</td>
</tr>
</tbody></table>
<p>在图形管线使用完成之后，需要调用函数 <code>vkDestroyPipeline</code> 来销毁图形管线并释放资源，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipeline                                  pipeline,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>表示要销毁图形管线的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipeline</td>
<td>图形管线句柄</td>
<td>要销毁的图形管线句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建图形管线时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;</span><br><span class="line">pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;</span><br><span class="line">pipelineInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">pipelineInfo.flags = <span class="number">0</span>;</span><br><span class="line">pipelineInfo.stageCount = <span class="number">2</span>;</span><br><span class="line">pipelineInfo.pStages = shaderStages;</span><br><span class="line">pipelineInfo.pVertexInputState = &amp;vertexInputInfo;</span><br><span class="line">pipelineInfo.pInputAssemblyState = &amp;inputAssembly;</span><br><span class="line">pipelineInfo.pTessellationState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.pViewportState = &amp;viewportState;</span><br><span class="line">pipelineInfo.pRasterizationState = &amp;rasterizer;</span><br><span class="line">pipelineInfo.pMultisampleState = &amp;multisampling;</span><br><span class="line">pipelineInfo.pDepthStencilState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.pColorBlendState = &amp;colorBlending;</span><br><span class="line">pipelineInfo.pDynamicState = &amp;dynamicState;</span><br><span class="line">pipelineInfo.layout = pipelineLayout;</span><br><span class="line">pipelineInfo.renderPass = renderPass;</span><br><span class="line">pipelineInfo.subpass = <span class="number">0</span>;</span><br><span class="line">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.basePipelineIndex = <span class="number">-1</span>;              <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="number">1</span>, &amp;pipelineInfo, <span class="literal">nullptr</span>, &amp;graphicsPipeline) !=</span><br><span class="line">    VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create graphics pipeline!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkDestroyPipeline</span>(device, graphicsPipeline, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染和呈现</title>
    <url>/2025/03/20/Vulkan/13.%E6%B8%B2%E6%9F%93%E5%92%8C%E5%91%88%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>Vulkan 的核心设计是<strong>显式同步</strong>，GPU 上的执行顺序需要由开发者通过各种同步原语（synchronization primitives）来定义，明确指示驱动程序按照我们指定的顺序执行操作。许多的 Vulkan API 调用时<strong>异步返回</strong>，而不会<strong>阻塞直到执行完成</strong>。</p>
<p>这意味着如果需要执行的操作有严格的先后顺序，即后一个操作需要等待前一个操作完成时，需要利用 Vulkan 提供的同步机制来确保执行顺序的正确。</p>
<p>以渲染图像为例：</p>
<ol>
<li>从交换链获取一张图像</li>
<li>执行绘制命令，将内容渲染到获取的图像上</li>
<li>将该图像呈现到屏幕上，并将其归还给交换链</li>
</ol>
<p>这些操作的 Vulkan API 调用都是异步执行的，但是这些操作是相互依赖的，因此需要同步机制来确保执行顺序的正确。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>信号量（Semaphores）</strong>用于在<strong>队列操作</strong>之间建立执行顺序，队列操作是所有提交到队列中的任务，例如命令缓冲区，<code>vkQueueSubmit</code> 调用等。常见的 Vulkan 队列包括 <strong>图形队列（graphics queue）</strong> 和 <strong>呈现队列（presentation queue）</strong>。</p>
<p>信号量不仅用于<strong>同一队列内</strong>任务的排序，也用于<strong>不同队列间</strong>的任务同步。</p>
<h3 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h3><p>Vulkan 提供了两种类型的信号量：</p>
<ol>
<li><strong>二进制信号量（Binary Semaphore）</strong>：只能有两种状态：已触发（signaled）或未触发（unsignaled）。</li>
<li><strong>时间线信号量（Timeline Semaphore）</strong>：允许使用递增的计数值进行更精确的同步。</li>
</ol>
<h3 id="信号量的工作过程"><a href="#信号量的工作过程" class="headerlink" title="信号量的工作过程"></a>信号量的工作过程</h3><p>信号量的初始状态为 <strong>未触发（unsignaled）</strong>。我们可以使用它在两个队列操作（A 和 B）之间 <strong>建立执行顺序</strong>。</p>
<ol>
<li>队列操作 A 执行时，设置信号量 S 为触发状态（signaled）</li>
<li>队列操作 B 在执行前，需要等待信号量 S 变为触发状态（signaled）</li>
<li>当 B 开始执行时，信号量 S 会自动重置为未触发状态（unsignaled），以便后续复用</li>
</ol>
<p>伪代码描述如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkCommandBuffer A, B = ... <span class="comment">// 记录命令缓冲区</span></span><br><span class="line">VkSemaphore S = ... <span class="comment">// 创建信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 A 任务，并在执行完毕后触发 S</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, signal: S, wait: None)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 B 任务，并等待 S 被触发后才开始执行</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: B, signal: None, wait: S)</span><br></pre></td></tr></table></figure></div>

<p>注意：即使添加了信号量，两次 <code>vkQueueSubmit</code> 调用仍然是非阻塞的，Vulkan 仅在 GPU 上等待信号量触发，而不会阻塞 CPU 的执行。</p>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p><strong>栅栏（Fence）</strong> 的作用与 <strong>信号量（Semaphore）</strong> 类似，其都用于同步操作的执行，但与信号量不同的是，栅栏用于 <strong>CPU和GPU之间</strong> 的同步。</p>
<p>简单来说：如果 GPU 任务需要在另一个 GPU 任务之后执行，使用信号量；如果 CPU 需要等待 GPU 任务完成后再继续执行，我们使用 栅栏。</p>
<h3 id="栅栏的工作过程"><a href="#栅栏的工作过程" class="headerlink" title="栅栏的工作过程"></a>栅栏的工作过程</h3><p>栅栏有两种状态：</p>
<ol>
<li><strong>未触发（unsignaled）</strong>：初始状态。</li>
<li><strong>已触发（signaled）</strong>：当 GPU 任务完成后，栅栏变为 <strong>已触发</strong>，表示 CPU 可以继续执行后续任务。</li>
</ol>
<p>在提交 GPU 任务时，我们可以附加一个 <strong>栅栏（Fence）</strong>，当任务完成时，该栅栏会被 Vulkan <strong>设为已触发状态</strong>。然后，我们可以让 CPU 等待栅栏变为 <strong>已触发</strong>，以确保 GPU 任务完成后，CPU 才继续执行。</p>
<p>例如：假设我们要从 <strong>GPU 传输图像到 CPU</strong>，然后将数据保存到文件。</p>
<ol>
<li>使用命令缓冲区 A 进行图像传输。</li>
<li>创建栅栏 F，并在 GPU 任务完成后触发它。</li>
<li>CPU 等待栅栏 F 触发，然后再将数据保存到文件。</li>
</ol>
<p>伪代码描述如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkCommandBuffer A = ... <span class="comment">// 记录命令缓冲区 A（用于图像传输）</span></span><br><span class="line">VkFence F = ... <span class="comment">// 创建栅栏 F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 A 任务，开始执行，任务完成后触发 F</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, fence: F)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU 等待栅栏 F 触发，确保 GPU 任务完成</span></span><br><span class="line"><span class="built_in">vkWaitForFence</span>(F) <span class="comment">// 阻塞 CPU，直到 A 完成执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">save_screenshot_to_disk</span>() <span class="comment">// 只有在传输完成后才会执行</span></span><br></pre></td></tr></table></figure></div>

<p>注意：栅栏会阻塞 CPU 的执行。</p>
<h2 id="信号量与栅栏的选择"><a href="#信号量与栅栏的选择" class="headerlink" title="信号量与栅栏的选择"></a>信号量与栅栏的选择</h2><p>在 Vulkan 渲染循环中，有两个主要的同步点：</p>
<ol>
<li><strong>交换链操作</strong>：发生在 <strong>GPU 内部</strong>，使用 <strong>信号量</strong> 来同步。</li>
<li><strong>等待上一帧完成</strong>：CPU 需要等待 GPU 任务完成，以避免修改 <strong>仍在使用中的命令缓冲区</strong>，因此使用 <strong>栅栏</strong>。</li>
</ol>
<h2 id="创建同步对象"><a href="#创建同步对象" class="headerlink" title="创建同步对象"></a>创建同步对象</h2><h3 id="信号量的创建与销毁"><a href="#信号量的创建与销毁" class="headerlink" title="信号量的创建与销毁"></a>信号量的创建与销毁</h3><p>信号量的创建需要首先填充 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a> 结构体，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSemaphoreCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType           sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*               pNext;</span><br><span class="line">    VkSemaphoreCreateFlags    flags;</span><br><span class="line">&#125; VkSemaphoreCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</code>，以表明这是一个信号量创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定信号量创建时的附加标志。</td>
<td>目前没有定义，应设置为 <code>0</code>。</td>
</tr>
</tbody></table>
<p>然后，调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a> 来创建信号量，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSemaphoreCreateInfo*                pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore*                                pSemaphore)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建信号量的逻辑设备，表示在哪个设备上创建信号量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>信号量创建信息指针</td>
<td><code>VkSemaphoreCreateInfo</code> 结构体的指针，包含信号量的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。<br />如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSemaphore</td>
<td>信号量指针</td>
<td>指向 <code>VkSemaphore</code> 句柄的指针，创建成功后，该变量存储信号量的句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示信号量是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示信号量创建成功。<br />其他错误码表示创建失败，例如：<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机（CPU）内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备（GPU）内存不足。</td>
</tr>
</tbody></table>
<p>在信号量使用完毕之后，需要调用函数 <code>vkDestroySemaphore</code> 进行销毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroySemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore                                 semaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁信号量的逻辑设备，表示在哪个设备上销毁信号量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>semaphore</td>
<td>信号量句柄</td>
<td>需要销毁的信号量对象的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建信号量时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h3 id="栅栏的创建与销毁"><a href="#栅栏的创建与销毁" class="headerlink" title="栅栏的创建与销毁"></a>栅栏的创建与销毁</h3><p>栅栏的创建需要首先填充  <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a> 结构体，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkFenceCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType       sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*           pNext;</span><br><span class="line">    VkFenceCreateFlags    flags;</span><br><span class="line">&#125; VkFenceCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</code>，以表明这是一个栅栏创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定栅栏创建时的附加标志</td>
<td>可能的值包括：<br /><code>VK_FENCE_CREATE_SIGNALED_BIT</code>：创建栅栏时设置为已触发状态。<br /><code>VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>然后，调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateFence.html"><code>vkCreateFence</code></a> 来创建栅栏，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateFence</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFenceCreateInfo*                    pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence*                                    pFence)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建栅栏的逻辑设备，表示在哪个设备上创建栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>栅栏创建信息指针</td>
<td><code>VkFenceCreateInfo</code> 结构体的指针，包含栅栏的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。<br />如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pFence</td>
<td>栅栏指针</td>
<td>指向 <code>VkFence</code> 句柄的指针，创建成功后，该变量存储栅栏的句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示栅栏是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示栅栏创建成功。<br />其他错误码表示创建失败，例如：<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机（CPU）内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备（GPU）内存不足。</td>
</tr>
</tbody></table>
<p>在栅栏使用完毕之后，需要调用函数 <code>vkDestroyFence</code> 进行销毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyFence</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁栅栏的逻辑设备，表示在哪个设备上销毁栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fence</td>
<td>栅栏句柄</td>
<td>需要销毁的栅栏对象的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建信号量时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><p>在一个简单的 Vulkan 渲染循环中，需要三个同步对象：</p>
<ol>
<li>一个 信号量来指示交换链中的图像已经准备好进行渲染。</li>
<li>一个 信号量来指示渲染已完成，可以进行显示。</li>
<li>一个 栅栏来确保同一时间只渲染一帧，防止 CPU 过早提交新的命令。</li>
</ol>
<p>一个创建和销毁示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;</span><br><span class="line">semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line">semaphoreInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">semaphoreInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VkFenceCreateInfo fenceInfo&#123;&#125;;</span><br><span class="line">fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">fenceInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||</span><br><span class="line">    <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS ||</span><br><span class="line">    <span class="built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create semaphores!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroyFence</span>(device, inFlightFence, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="渲染和呈现"><a href="#渲染和呈现" class="headerlink" title="渲染和呈现"></a>渲染和呈现</h1><p>在 Vulkan 中，渲染一帧图像通常包括以下的步骤：</p>
<ol>
<li>等待上一帧完成</li>
<li>从交换链获取一张图像</li>
<li>记录一个命令缓冲区，将场景绘制到该图像上</li>
<li>提交已记录的命令缓冲区</li>
<li>呈现交换链图像</li>
</ol>
<h3 id="等待上一帧完成"><a href="#等待上一帧完成" class="headerlink" title="等待上一帧完成"></a>等待上一帧完成</h3><p>在每一帧的开始，需要<strong>等待上一帧的渲染完成</strong>，确保<strong>命令缓冲区（Command Buffer）</strong> 和 <strong>信号量（Semaphore）</strong> 可用。为此，我们需要调用 <code>vkWaitForFences</code>，其接受一个栅栏数组，并在 CPU 端等待，直到其中 <strong>任意或所有</strong> 栅栏变为已触发状态后再返回，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkWaitForFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    fenceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFence*                              pFences,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBool32                                    waitAll,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span>                                    timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>等待栅栏所在的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fenceCount</td>
<td>栅栏数组大小</td>
<td>需要等待的栅栏数量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pFences</td>
<td>栅栏数组指针</td>
<td>指向栅栏数组的指针。</td>
</tr>
<tr>
<td>输入参数</td>
<td>waitAll</td>
<td>是否等待所有栅栏</td>
<td>是否等待所有栅栏：<br /><code>VK_TRUE</code>：等待所有。<br /><code>VK_FALSE</code> ：等待任意一个栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>timeout</td>
<td>超时时间</td>
<td>单位为纳秒。如果超时仍未触发，则返回 <code>VK_TIMEOUT</code>。若设为 <code>UINT64_MAX</code>，则无限等待</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示等待结果</td>
<td>常见值包括：<br /><code>VK_SUCCESS</code>：所有需要等待的栅栏都已触发。<br /><code>VK_TIMEOUT</code>：超时时间到达，仍然有栅栏未触发。<br /><code>VK_ERROR_DEVICE_LOST</code>：设备丢失（通常是 GPU 崩溃）。</td>
</tr>
</tbody></table>
<p>在等待完成后，需要调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkResetFences.html"><code>vkResetFences</code></a> 手动重置栅栏，将其恢复为未触发状态，以便下一帧使用，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkResetFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    fenceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFence*                              pFences)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>重置栅栏所在的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fenceCount</td>
<td>栅栏数组大小</td>
<td>需要重置的栅栏数量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pFences</td>
<td>栅栏数组指针</td>
<td>指向栅栏数组的指针。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示重置结果</td>
<td>常见值包括：<br /><code>VK_SUCCESS</code>：成功重置。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足，Fence 无法重置。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足，Fence 无法重置。</td>
</tr>
</tbody></table>
<p>注意：在绘制第一帧时，由于第一帧没有“上一帧”来触发它，<code>vkWaitForFences()</code> 会一直阻塞，导致程序卡死。</p>
<p>有许多方法能够解决这个问题，但最佳实践是：在创建栅栏时就让其处于已触发状态，这样第一帧 <code>vkWaitForFences()</code> 会立即返回，不会阻塞。</p>
<p>其做法是在栅栏创建信息中设置 <code>VK_FENCE_CREATE_SIGNALED_BIT</code> 标志：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br></pre></td></tr></table></figure></div>

<h3 id="从交换链获取图像"><a href="#从交换链获取图像" class="headerlink" title="从交换链获取图像"></a>从交换链获取图像</h3><p>通过调用函数 <code>vkAcquireNextImageKHR</code> 来从交换链中获取图像，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAcquireNextImageKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR                              swapchain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span>                                    timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore                                 semaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pImageIndex)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>进行 Vulkan 操作的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>swapchain</td>
<td>交换链句柄</td>
<td>获取图像的交换链对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>timeout</td>
<td>超时时间</td>
<td>单位为纳秒，如果设置为 <code>UINT64_MAX</code>，表示无限等待，直到图像可用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>semaphore</td>
<td>信号量句柄</td>
<td>可选信号量，用于同步。当图像可用时，会触发该信号量。<br />不使用时应设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fence</td>
<td>栅栏句柄</td>
<td>可选栅栏，用于同步 CPU 线程。当图像可用时，会触发该栅栏。<br />不使用时应设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pImageIndex</td>
<td>可用图像索引</td>
<td>返回交换链中可用图像的索引。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>获取图像结果</td>
<td>常见的值包括：<br /><code>VK_SUCCESS</code>：成功获取图像。<br /><code>VK_TIMEOUT</code>：超过超时时间，仍然没有可用图像。<br /><code>VK_NOT_READY</code>：没有可用的图像，但不会阻塞。<br /><code>VK_SUBOPTIMAL_KHR</code>：成功获取图像，但交换链的配置不再最优（需要重新创建交换链）。<br /><code>VK_ERROR_OUT_OF_DATE_KHR</code>：交换链已经过期（例如窗口大小发生变化），需要重建交换链。</td>
</tr>
</tbody></table>
<h3 id="记录命令缓冲区"><a href="#记录命令缓冲区" class="headerlink" title="记录命令缓冲区"></a>记录命令缓冲区</h3><p>在记录命令缓冲区之前，需要先调用 <code>vkResetCommandBuffer</code> 以确保命令缓冲区处于可记录状态，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkResetCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBufferResetFlags                   flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>需要重置的命令缓冲区。在重置后，该缓冲区将返回到初始状态，并可重新记录命令。</td>
</tr>
<tr>
<td>输入参数</td>
<td>flags</td>
<td>重置命令缓冲区的附加标志</td>
<td>控制如何重置命令缓冲区，可能的值包括：<br /><code>0</code>（默认）：不执行任何特殊操作。<br /><code>VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT</code>：表示在重置时释放命令缓冲区占用的所有资源。<br /><code>VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>命令缓冲区是否重置成功</td>
<td>可能的值包括：<br /><code>VK_SUCCESS</code>：成功重置命令缓冲区。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足，无法完成操作。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足，无法完成操作。</td>
</tr>
</tbody></table>
<p>注意：只有在 <code>VkCommandPool</code> 创建时未设置 <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> 时，<code>vkResetCommandBuffer</code> 才会返回错误。否则，可以随时重置命令缓冲区。在命令缓冲区处于 <code>VK_COMMAND_BUFFER_STATE_RECORDING</code> 或 <code>VK_COMMAND_BUFFER_STATE_PENDING</code> 状态时，调用 <code>vkResetCommandBuffer</code> 会导致未定义行为。</p>
<p>然后按照 <code>命令缓冲区</code> 中的操作对于命令缓冲区进行记录。</p>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line">VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h3><p>绘制一帧的最后一步是将渲染结果提交回交换链，呈现通过结构体 <code>VkPresentInfoKHR</code> 来进行配置，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPresentInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                 waitSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*       pWaitSemaphores;</span><br><span class="line">    <span class="type">uint32_t</span>                 swapchainCount;</span><br><span class="line">    <span class="type">const</span> VkSwapchainKHR*    pSwapchains;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pImageIndices;</span><br><span class="line">    VkResult*                pResults;</span><br><span class="line">&#125; VkPresentInfoKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</code>，以表明这是一个呈现信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>waitSemaphoreCount</td>
<td>信号量数组大小</td>
<td>指定 <code>pWaitSemaphores</code> 数组中的信号量数量。</td>
</tr>
<tr>
<td>pWaitSemaphores</td>
<td>信号量数组指针</td>
<td>指定一个信号量数组，在展示前需要等待这些信号量被触发（用于确保渲染完成后再进行展示）。</td>
</tr>
<tr>
<td>swapchainCount</td>
<td>交换链数组大小</td>
<td>交换链的数量，通常为 1。</td>
</tr>
<tr>
<td>pSwapchains</td>
<td>交换链数组指针</td>
<td>指向 <code>VkSwapchainKHR</code> 交换链的指针数组，指定要呈现的交换链。</td>
</tr>
<tr>
<td>pImageIndices</td>
<td>图像索引</td>
<td>指向 <code>uint32_t</code> 数组，每个元素表示 <code>pSwapchains</code> 对应交换链中的图像索引，指定要呈现的图像。</td>
</tr>
<tr>
<td>pResults</td>
<td>呈现结果</td>
<td>可选的 <code>VkResult</code> 数组，用于存储每个交换链的呈现结果，通常为 <code>nullptr</code>。如果多个交换链存在，可以用它来检查每个交换链的单独返回状态。</td>
</tr>
</tbody></table>
<p>然后调用函数 <code>vkQueuePresentKHR</code> 来呈现绘制结果，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkQueuePresentKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue                                     queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkPresentInfoKHR*                     pPresentInfo)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>queue</td>
<td>队列句柄</td>
<td>负责图像呈现的队列，通常是 <code>presentQueue</code>（必须支持 <code>VK_QUEUE_PRESENT_BIT</code>）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pPresentInfo</td>
<td>呈现信息指针</td>
<td>指向 <code>VkPresentInfoKHR</code> 结构体，包含交换链信息和同步对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>呈现执行结果</td>
<td>可能的值包括：<br /><code>VK_SUCCESS</code>：呈现成功。<br /><code>VK_SUBOPTIMAL_KHR</code>：呈现成功，但交换链不理想（例如窗口大小发生变化，但仍然可用）。<br /><code>VK_ERROR_OUT_OF_DATE_KHR</code>：交换链已过期（例如窗口大小改变，需要重建交换链）。<br /><code>VK_ERROR_SURFACE_LOST_KHR</code>：表面丢失（可能由于窗口销毁或最小化）。<br /><code>VK_ERROR_DEVICE_LOST</code>：设备丢失，通常是 GPU 崩溃或驱动错误。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足。</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>本节的示例函数如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkWaitForFences</span>(device, <span class="number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取交换链图像 */</span></span><br><span class="line">    <span class="type">uint32_t</span> imageIndex;</span><br><span class="line">    <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录命令缓冲区 */</span></span><br><span class="line">    <span class="built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提交命令缓冲区 */</span></span><br><span class="line">    VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line">    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">    submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">    submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">    submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkPresentInfoKHR presentInfo&#123;&#125;;</span><br><span class="line">    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</span><br><span class="line">    presentInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    presentInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pWaitSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;</span><br><span class="line">    presentInfo.swapchainCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pSwapchains = swapChains;</span><br><span class="line">    presentInfo.pImageIndices = &amp;imageIndex;</span><br><span class="line">    presentInfo.pResults = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan 与 RT Core</title>
    <url>/2025/03/25/Vulkan/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>在本章中的代码将通过类 <code>VulkanPathTracingRenderRTCore</code> 来进行管理和组织，通过函数 <code>init</code> 来初始化资源，通过函数 <code>clear</code> 来释放资源：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VulkanPathTracingRenderRTCore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VulkanPathTracingRenderRTCore</span>();</span><br><span class="line">	~<span class="built_in">VulkanPathTracingRenderRTCore</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;renderer_rt_core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VulkanPathTracingRenderRTCore::<span class="built_in">VulkanPathTracingRenderRTCore</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VulkanPathTracingRenderRTCore::~<span class="built_in">VulkanPathTracingRenderRTCore</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanPathTracingRenderRTCore::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanPathTracingRenderRTCore::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="设备扩展与特性"><a href="#设备扩展与特性" class="headerlink" title="设备扩展与特性"></a>设备扩展与特性</h1><p>在 Vulkan 中使用 RT Core  进行渲染需要利用 Vulkan 的光线追踪扩展，并且需要硬件和驱动程序的支持。</p>
<h2 id="设备扩展"><a href="#设备扩展" class="headerlink" title="设备扩展"></a>设备扩展</h2><h3 id="核心上下文管理器"><a href="#核心上下文管理器" class="headerlink" title="核心上下文管理器"></a>核心上下文管理器</h3><p>首先，需要扩展 <strong>核心上下文管理器</strong> 中的 <strong>获取设备扩展函数</strong>，使得在创建 <strong>逻辑设备</strong> 时包含以下扩展：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME</code></td>
<td><code>VK_KHR_ray_tracing_pipeline</code></td>
<td>扩展提供了 Vulkan 对光线追踪管线的支持，使得开发者可以在 Vulkan 中使用类似于光线追踪着色器的阶段。</td>
</tr>
<tr>
<td><code>VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME</code></td>
<td><code>VK_KHR_acceleration_structure</code></td>
<td>扩展提供了加速结构的管理功能，允许 Vulkan 应用程序在 GPU 上构建、更新和使用加速结构，以支持光线追踪和光线查询操作。</td>
</tr>
<tr>
<td><code>VK_KHR_RAY_QUERY_EXTENSION_NAME</code></td>
<td><code>VK_KHR_ray_query</code></td>
<td>扩展提供了在传统光栅化管线或计算着色器中进行光线查询的能力，而不需要完整的 光线追踪管线。</td>
</tr>
<tr>
<td><code>VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME</code></td>
<td><code>VK_KHR_deferred_host_operations</code></td>
<td>扩展提供了异步执行主机端操作的方法，允许应用程序在多个 CPU 线程上并行执行 Vulkan 操作，而无需等待 GPU 处理完成。这对于 光线追踪和加速结构构建等高计算开销的任务特别重要。</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//content_manager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="type">bool</span> enableRayTracing&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//content_manager.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">ContentManager::getRequiredDeviceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; deviceExtensions&#123;&#125;;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;enableRayTracing)</span><br><span class="line">	&#123;</span><br><span class="line">		deviceExtensions.<span class="built_in">push_back</span>(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME);</span><br><span class="line">		deviceExtensions.<span class="built_in">push_back</span>(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME);</span><br><span class="line">		deviceExtensions.<span class="built_in">push_back</span>(VK_KHR_RAY_QUERY_EXTENSION_NAME);</span><br><span class="line">		deviceExtensions.<span class="built_in">push_back</span>(VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> deviceExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="核心上下文管理器初始化"><a href="#核心上下文管理器初始化" class="headerlink" title="核心上下文管理器初始化"></a>核心上下文管理器初始化</h3><p>在应用程序中调用：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VulkanPathTracingRenderRTCore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ContentManager contentManager&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanPathTracingRenderRTCore::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;contentManager.enableRayTracing = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;contentManager.<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">auto</span> pContentManager = std::<span class="built_in">make_shared</span>&lt;ContentManager&gt;(<span class="keyword">this</span>-&gt;contentManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="设备属性"><a href="#设备属性" class="headerlink" title="设备属性"></a>设备属性</h2><h3 id="设备属性存储结构"><a href="#设备属性存储结构" class="headerlink" title="设备属性存储结构"></a>设备属性存储结构</h3><p>在 Vulkan 中通过结构体 <code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> 来描述一个设备的光线追踪管线属性信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceRayTracingPipelinePropertiesKHR</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">void</span>*              pNext;</span><br><span class="line">    <span class="type">uint32_t</span>           shaderGroupHandleSize;</span><br><span class="line">    <span class="type">uint32_t</span>           maxRayRecursionDepth;</span><br><span class="line">    <span class="type">uint32_t</span>           maxShaderGroupStride;</span><br><span class="line">    <span class="type">uint32_t</span>           shaderGroupBaseAlignment;</span><br><span class="line">    <span class="type">uint32_t</span>           shaderGroupHandleCaptureReplaySize;</span><br><span class="line">    <span class="type">uint32_t</span>           maxRayDispatchInvocationCount;</span><br><span class="line">    <span class="type">uint32_t</span>           shaderGroupHandleAlignment;</span><br><span class="line">    <span class="type">uint32_t</span>           maxRayHitAttributeSize;</span><br><span class="line">&#125; VkPhysicalDeviceRayTracingPipelinePropertiesKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR</code>，以表明这是一个 <strong>物理设备光线追踪管线属性信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展链中的下一个结构体，通常为 <code>nullptr</code> 或用于查询其他扩展属性。</td>
</tr>
<tr>
<td>shaderGroupHandleSize</td>
<td>着色器组句柄字节大小</td>
<td>典型值：NVIDIA RTX 32 字节。<br />用于计算着色器绑定表（SBT）的偏移和对齐。</td>
</tr>
<tr>
<td>maxRayRecursionDepth</td>
<td>光线追踪管线支持的最大递归深度</td>
<td>典型值：NVIDIA RTX 20&#x2F;30 系列通常为 31，AMD RDNA2 为 64。<br />在创建管线时，<code>VkRayTracingPipelineCreateInfoKHR.maxPipelineRayRecursionDepth</code> 不能超过此值。</td>
</tr>
<tr>
<td>maxShaderGroupStride</td>
<td>着色器绑定表中每组记录的最大步长</td>
<td>典型值：4096 字节。<br />在创建管线时，<code>VkStridedDeviceAddressRegionKHR.stride</code> 不能超过此值。</td>
</tr>
<tr>
<td>shaderGroupBaseAlignment</td>
<td>着色器绑定表的基地址对齐要求</td>
<td>典型值：64 字节。<br />创建 SBT 缓冲区时需满足此对齐要求，类似 <code>VkBuffer</code> 的内存对齐约束。</td>
</tr>
<tr>
<td>shaderGroupHandleCaptureReplaySize</td>
<td>捕获&#x2F;重放着色器组句柄数据字节大小</td>
<td>典型值：NVIDIA RTX 32 字节。<br />用于捕获&#x2F;重放的着色器组句柄数据的字节大小。<br />仅在启用 <code>VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR</code> 时相关。</td>
</tr>
<tr>
<td>maxRayDispatchInvocationCount</td>
<td>单次调用的最大光线数量</td>
<td>典型值：<code>2^32 - 1</code>（无实际限制）。<br />单次 <code>vkCmdTraceRaysKHR</code> 调用允许的最大光线数量。<br />用于限制 <code>width × height × depth</code> 的乘积上限。</td>
</tr>
<tr>
<td>shaderGroupHandleAlignment</td>
<td>着色器组句柄内存对齐要求</td>
<td>典型值：32 字节。<br />在创建 SBT 时需保证每个句柄的地址对齐。</td>
</tr>
<tr>
<td>maxRayHitAttributeSize</td>
<td>命中着色器可读取的属性数据最大字节数</td>
<td>典型值：32 字节（足够存储 <code>vec2</code> 或 <code>vec3</code> 重心坐标）。<br />指定命中着色器（Hit Shader）可读取的属性数据（如重心坐标）的最大字节数。</td>
</tr>
</tbody></table>
<h3 id="设备属性查询"><a href="#设备属性查询" class="headerlink" title="设备属性查询"></a>设备属性查询</h3><p>通过 <code>VkPhysicalDeviceProperties2</code> 的 <code>pNext</code> 链进行查询：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VulkanPathTracingRenderRTCore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getFeatureProperty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VkPhysicalDeviceRayTracingPipelinePropertiesKHR property&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanPathTracingRenderRTCore::getFeatureProperty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;property.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;</span><br><span class="line">	VkPhysicalDeviceProperties2 deviceProperties&#123;&#125;;</span><br><span class="line">	deviceProperties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;</span><br><span class="line">	deviceProperties.pNext = &amp;<span class="keyword">this</span>-&gt;property;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceProperties2</span>(<span class="keyword">this</span>-&gt;contentManager.physicalDevice, &amp;deviceProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="设备特性"><a href="#设备特性" class="headerlink" title="设备特性"></a>设备特性</h2><h3 id="设备特性存储结构"><a href="#设备特性存储结构" class="headerlink" title="设备特性存储结构"></a>设备特性存储结构</h3><p>在 Vulkan 中通过结构体 <code>VkPhysicalDeviceRayTracingPipelineFeaturesKHR</code> 来描述一个设备的光线追踪管线特性信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceRayTracingPipelineFeaturesKHR</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">void</span>*              pNext;</span><br><span class="line">    VkBool32           rayTracingPipeline;</span><br><span class="line">    VkBool32           rayTracingPipelineShaderGroupHandleCaptureReplay;</span><br><span class="line">    VkBool32           rayTracingPipelineShaderGroupHandleCaptureReplayMixed;</span><br><span class="line">    VkBool32           rayTracingPipelineTraceRaysIndirect;</span><br><span class="line">    VkBool32           rayTraversalPrimitiveCulling;</span><br><span class="line">&#125; VkPhysicalDeviceRayTracingPipelineFeaturesKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>结构体类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR</code>，以表明这是一个 <strong>物理设备光线追踪管线特性信息</strong> 结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>扩展信息</td>
<td>指向扩展链中的下一个结构体，通常为 <code>nullptr</code> 或用于查询其他扩展属性。</td>
</tr>
<tr>
<td>rayTracingPipeline</td>
<td>是否支持光线追踪管线</td>
<td>必须为 <code>VK_TRUE</code> 才能使用 <code>VK_KHR_ray_tracing_pipeline</code> 扩展的功能（如 <code>vkCmdTraceRaysKHR</code>）。<br />若为 <code>VK_FALSE</code>，则设备不支持硬件光线追踪。</td>
</tr>
<tr>
<td>rayTracingPipeline<br />ShaderGroupHandleCaptureReplay</td>
<td>是否支持 着色器组句柄的捕获与重放</td>
<td>若为 <code>VK_TRUE</code>，可在创建管线时使用 <code>VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR</code>，允许记录和重放着色器组句柄（用于调试或确定性渲染）。</td>
</tr>
<tr>
<td>rayTracingPipeline<br />ShaderGroupHandleCaptureReplayMixed</td>
<td>是否支持 混合模式的着色器组句柄捕获与重放</td>
<td>若为 <code>VK_TRUE</code>，允许部分着色器组使用捕获重放，而其他组不使用。<br />需要 <code>rayTracingPipelineShaderGroupHandleCaptureReplay</code> 也为 <code>VK_TRUE</code>。</td>
</tr>
<tr>
<td>rayTracingPipelineTraceRaysIndirect</td>
<td>是否支持 间接光线追踪调度</td>
<td>若为 <code>VK_TRUE</code>，可使用 <code>vkCmdTraceRaysIndirectKHR</code> 命令，从 GPU 缓冲区读取光线数量（<code>width</code>&#x2F;<code>height</code>&#x2F;<code>depth</code>），适用于动态调度。</td>
</tr>
<tr>
<td>rayTraversalPrimitiveCulling</td>
<td>是否支持 光线遍历时的图元剔除</td>
<td>若为 <code>VK_TRUE</code>，加速结构可启用 <code>VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR</code>，避免重复调用 <code>anyHit</code> 着色器，提升性能。</td>
</tr>
</tbody></table>
<h3 id="设备特性查询"><a href="#设备特性查询" class="headerlink" title="设备特性查询"></a>设备特性查询</h3><p>通过 <code>VkPhysicalDeviceFeatures2</code> 的 <code>pNext</code> 链进行查询：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderer_rt_core.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VulkanPathTracingRenderRTCore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getFeatureProperty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VkPhysicalDeviceRayTracingPipelineFeaturesKHR feature&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanPathTracingRenderRTCore::getFeatureProperty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">this</span>-&gt;feature.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;</span><br><span class="line">	VkPhysicalDeviceFeatures2 deviceFeatures2&#123;&#125;;</span><br><span class="line">	deviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;</span><br><span class="line">	deviceFeatures2.pNext = &amp;<span class="keyword">this</span>-&gt;feature;</span><br><span class="line">	<span class="built_in">vkGetPhysicalDeviceFeatures2</span>(<span class="keyword">this</span>-&gt;contentManager.physicalDevice, &amp;deviceFeatures2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="加速结构创建"><a href="#加速结构创建" class="headerlink" title="加速结构创建"></a>加速结构创建</h1><p>RT Core 需要几何体的加速结构来进行高效的光线相交测试：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建底层加速结构 (BLAS) - 表示单个几何体</span><br><span class="line">VkAccelerationStructureCreateInfoKHR blasCreateInfo = &#123;&#125;;</span><br><span class="line">blasCreateInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;</span><br><span class="line">blasCreateInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;</span><br><span class="line">// 配置几何体信息...</span><br><span class="line"></span><br><span class="line">// 创建顶层加速结构 (TLAS) - 包含多个 BLAS 实例</span><br><span class="line">VkAccelerationStructureCreateInfoKHR tlasCreateInfo = &#123;&#125;;</span><br><span class="line">tlasCreateInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;</span><br><span class="line">tlasCreateInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;</span><br></pre></td></tr></table></figure></div>

<h1 id="创建光线追踪管线"><a href="#创建光线追踪管线" class="headerlink" title="创建光线追踪管线"></a>创建光线追踪管线</h1><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">VkRayTracingPipelineCreateInfoKHR pipelineInfo = &#123;&#125;;</span><br><span class="line">pipelineInfo.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;</span><br><span class="line">pipelineInfo.stageCount = ...; // 光线生成、相交、未命中等着色器</span><br><span class="line">pipelineInfo.pStages = ...;</span><br><span class="line">pipelineInfo.groupCount = ...; // 着色器组</span><br><span class="line">pipelineInfo.pGroups = ...;</span><br><span class="line">pipelineInfo.maxPipelineRayRecursionDepth = ...; // 光线递归深度</span><br><span class="line">pipelineInfo.layout = pipelineLayout;</span><br><span class="line"></span><br><span class="line">vkCreateRayTracingPipelinesKHR(device, VK_NULL_HANDLE, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;pipeline);</span><br></pre></td></tr></table></figure></div>

<h1 id="创建着色器绑定表-SBT"><a href="#创建着色器绑定表-SBT" class="headerlink" title="创建着色器绑定表 (SBT)"></a>创建着色器绑定表 (SBT)</h1><p>着色器绑定表是 RT Core 查找着色器的关键数据结构：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 为每种着色器类型分配内存</span><br><span class="line">VkBuffer rayGenBuffer;</span><br><span class="line">VkBuffer missBuffer;</span><br><span class="line">VkBuffer hitBuffer;</span><br><span class="line">VkBuffer callableBuffer;</span><br><span class="line"></span><br><span class="line">// 填充 SBT 数据...</span><br></pre></td></tr></table></figure></div>

<h1 id="调度光线追踪工作"><a href="#调度光线追踪工作" class="headerlink" title="调度光线追踪工作"></a>调度光线追踪工作</h1><p>在命令缓冲区中记录光线追踪命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vkCmdBindPipeline(cmdBuffer, VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline);</span><br><span class="line">vkCmdBindDescriptorSets(cmdBuffer, VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, layout, ...);</span><br><span class="line"></span><br><span class="line">vkCmdTraceRaysKHR(</span><br><span class="line">    cmdBuffer,</span><br><span class="line">    &amp;rayGenSbtEntry,   // 光线生成着色器 SBT 区域</span><br><span class="line">    &amp;missSbtEntry,     // 未命中着色器 SBT 区域</span><br><span class="line">    &amp;hitSbtEntry,      // 命中着色器 SBT 区域</span><br><span class="line">    &amp;callableSbtEntry, // 可调用着色器 SBT 区域</span><br><span class="line">    width, height, depth // 光线数量</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h1 id="访问渲染结果"><a href="#访问渲染结果" class="headerlink" title="访问渲染结果"></a>访问渲染结果</h1><p>光线追踪结果通常写入存储图像(storage image)，然后可以用于后续渲染或显示。</p>
]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan 与 光栅化</title>
    <url>/2025/03/26/Vulkan/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>在重新创建交换链之前需要先调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkDeviceWaitIdle.html"><code>vkDeviceWaitIdle</code></a> 来确保一个逻辑设备上的所有资源都不再被使用，该函数会阻塞当前线程直到指定的逻辑设备上的操作全部完成，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkDeviceWaitIdle</span><span class="params">(VkDevice device)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要等待空闲的逻辑设备。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示设备等待是否成功</td>
<td><code>VK_SUCCESS</code>：设备成功进入空闲状态。</td>
</tr>
</tbody></table>
<h2 id="交换链过时或次优"><a href="#交换链过时或次优" class="headerlink" title="交换链过时或次优"></a>交换链过时或次优</h2><p>Vulkan 通常会在 <strong>呈现</strong> 时通知我们交换链已不再适用。<br><code>vkAcquireNextImageKHR</code> 和 <code>vkQueuePresentKHR</code> 这两个函数可能返回以下特殊值，表示交换链的状态：</p>
<ul>
<li><code>VK_ERROR_OUT_OF_DATE_KHR</code>：交换链已与表面不兼容，无法继续用于渲染。通常发生在窗口大小调整后。在获取图像时发现交换链已经过时，则无法继续使用它进行呈现。因此，应该立即重新创建交换链，并在下一帧的调用中重试。</li>
<li><code>VK_SUBOPTIMAL_KHR</code>：交换链仍然可以正常用于呈现，但表面属性已经发生变化，不再完全匹配。一般情况下，<code>VK_SUBOPTIMAL_KHR</code> 只是一个<strong>警告</strong>，表示当前的交换链仍然可以使用，但可能不是最优的。针对于这一错误，典型的做法是：<ul>
<li>在获取图像时，通常可以忽略 ，继续渲染当前帧。</li>
<li>在呈现发生时，通常重新创建交换链，以确保最佳的显示效果。</li>
</ul>
</li>
</ul>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkResult result = <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to acquire swap chain image!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to present swap chain image!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="显式处理窗口大小调整"><a href="#显式处理窗口大小调整" class="headerlink" title="显式处理窗口大小调整"></a>显式处理窗口大小调整</h2><p>尽管许多驱动程序和平台在窗口大小调整后会自动触发 <code>VK_ERROR_OUT_OF_DATE_KHR</code>，但并不能保证这种情况一定会发生。因此，我们需要额外添加代码，以显式处理窗口大小调整事件。</p>
<p>一个实现方法是，设置一个标志来显式的指明窗口大小是否发生了调整，然后利用 GLFW 库中的 <code>glfwSetFramebufferSizeCallback</code> 为窗口大小调整操作设置一个回调函数，并在回调函数中将该标志设置为 <code>true</code> 。这样，当 GLFW 监听到窗口大小变动事件之后，便会调用该回调函数将该标志设置为 <code>true</code>，渲染循环就能够通过检测这个标志来决定是否进行交换链重建。</p>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> framebufferResized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line">    <span class="keyword">this</span>-&gt;window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, <span class="string">&quot;Vulkan&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(window, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebufferResizeCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">framebufferResizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pointer = <span class="built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    pointer-&gt;framebufferResized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...   </span><br><span class="line"> </span><br><span class="line">	result = <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized)</span><br><span class="line">    &#123;</span><br><span class="line">        framebufferResized = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to present swap chain image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="处理窗口最小化"><a href="#处理窗口最小化" class="headerlink" title="处理窗口最小化"></a>处理窗口最小化</h2><p>有一种情况可能会导致交换链过时，那就是<strong>窗口最小化</strong>。这种情况会导致帧缓冲区大小变为 <code>0</code>。</p>
<p>一个简单的解决方案是在窗口最小化时使程序暂停，在窗口恢复到前台时再继续运行。例如设置一个死循环，并通过调用 <code>glfwGetFramebufferSize</code> 函数来检查窗口大小，直到窗口大小不为 <code>0</code>。一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    <span class="keyword">while</span> (width == <span class="number">0</span> || height == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">        <span class="built_in">glfwWaitEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDeviceWaitIdle</span>(device);</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">createSwapChain</span>();</span><br><span class="line">    <span class="built_in">createImageViews</span>();</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="清除值"><a href="#清除值" class="headerlink" title="清除值"></a>清除值</h1><p>由于现在存在多个附件（颜色附件、深度附件），并且多个附件使用了 <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>所以还需要指定多个清除值，并修改渲染通道开始信息：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;VkClearValue, 2&gt; clearValues&#123;&#125;;</span><br><span class="line">clearValues[<span class="number">0</span>].color = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">clearValues[<span class="number">1</span>].depthStencil = &#123;<span class="number">1.0f</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line">renderPassInfo.renderPass = renderPass;</span><br><span class="line">renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];</span><br><span class="line">renderPassInfo.renderArea.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">renderPassInfo.renderArea.extent = swapChainExtent;</span><br><span class="line">VkClearValue clearColor = &#123;&#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;&#125;;</span><br><span class="line">renderPassInfo.clearValueCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(clearValues.<span class="built_in">size</span>());</span><br><span class="line">renderPassInfo.pClearValues = clearValues.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 Vulkan 中，深度缓冲区中的深度范围是 <code>0.0</code> 到 <code>1.0</code>，其中 <code>1.0</code> 位于远视平面，<code>0.0</code> 位于近视平面。深度缓冲区中每个点的初始值应该是可能的最远深度，即 <code>1.0</code>。<br>注意：<code>clearValues</code> 的顺序应与附件的顺序一致。</p>
</blockquote>
<h1 id="开始渲染通道"><a href="#开始渲染通道" class="headerlink" title="开始渲染通道"></a>开始渲染通道</h1><p>在 Vulkan 中，绘制的过程从开始渲染通道开始，其通过结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkRenderPassBeginInfo.html"><code>VkRenderPassBeginInfo</code></a> 进行配置，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRenderPassBeginInfo</span> &#123;</span><br><span class="line">    VkStructureType        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*            pNext;</span><br><span class="line">    VkRenderPass           renderPass;</span><br><span class="line">    VkFramebuffer          framebuffer;</span><br><span class="line">    VkRect2D               renderArea;</span><br><span class="line">    <span class="type">uint32_t</span>               clearValueCount;</span><br><span class="line">    <span class="type">const</span> VkClearValue*    pClearValues;</span><br><span class="line">&#125; VkRenderPassBeginInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO</code>，以表明这是一个渲染通道开始信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>renderPass</td>
<td>渲染通道句柄</td>
<td>指定要开始的渲染通道。这个渲染通道必须先前创建并在调用 <code>vkCmdBeginRenderPass</code> 时提供。</td>
</tr>
<tr>
<td>framebuffer</td>
<td>绑定的帧缓冲区句柄</td>
<td>指定与渲染通道相关的帧缓冲区。帧缓冲区包含图像视图（<code>VkImageView</code>），它们在渲染过程中用作附件。在这里，你需要传入为当前渲染操作选择的帧缓冲区（例如，当前交换链图像对应的帧缓冲区）。</td>
</tr>
<tr>
<td>renderArea</td>
<td>渲染区域</td>
<td>指定渲染操作将在帧缓冲区中的哪些区域进行。它是一个矩形，通常定义为窗口大小或某个指定的区域。在这个矩形区域外的像素具有未定义值，因此，最佳做法是确保该区域与帧缓冲区的大小匹配。</td>
</tr>
<tr>
<td>clearValueCount</td>
<td>清除值数量</td>
<td>如果在渲染过程中使用了 <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>（例如清空颜色附件或深度附件），则你需要提供清除值。在这种情况下，<code>clearValueCount</code> 是你需要的清除值的数量。</td>
</tr>
<tr>
<td>pClearValues</td>
<td>清除值数组</td>
<td>一个指向 <code>VkClearValue</code> 数组的指针，指定了每个附件的清除值。当 <code>clearValueCount</code> 大于 0 时，<code>pClearValues</code> 会提供每个附件的清除值（例如颜色、深度或模板）。如果不需要清除某个附件，可以将其设置为默认值。</td>
</tr>
</tbody></table>
<p>然后通过调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBeginRenderPass.html"><code>vkCmdBeginRenderPass</code></a> 来开始渲染通道，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBeginRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkRenderPassBeginInfo*                pRenderPassBegin,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSubpassContents                           contents)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定进行命令记录的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pRenderPassBegin</td>
<td>渲染通道开始信息指针</td>
<td>指向 <code>VkRenderPassBeginInfo</code> 结构体的指针，指定渲染通道的相关参数。</td>
</tr>
<tr>
<td>输入参数</td>
<td>contents</td>
<td>子通道内容</td>
<td>指定在当前 <code>Render Pass</code> 期间，子通道（Subpass）的指令是如何提交的，可能的值包括：<br /><code>VK_SUBPASS_CONTENTS_INLINE</code>：渲染通道的命令会直接嵌入在主命令缓冲区中。<br/><code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code>：染通道的命令会从次级命令缓冲区中执行<br/><code>VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR</code>：Khronos Group 扩展标志，表示渲染通道的命令可以同时来自内联命令和次级命令缓冲区。<br/><code>VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT</code>：兼容扩展标志，与 <code>VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR</code> 相同。<br/><code>VK_SUBPASS_CONTENTS_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line">renderPassInfo.renderPass = renderPass;</span><br><span class="line">renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];</span><br><span class="line">renderPassInfo.renderArea.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">renderPassInfo.renderArea.extent = swapChainExtent;</span><br><span class="line">VkClearValue clearColor = &#123;&#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;&#125;;</span><br><span class="line">renderPassInfo.clearValueCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pClearValues = &amp;clearColor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdBeginRenderPass</span>(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);</span><br></pre></td></tr></table></figure></div>

<h1 id="基本绘制命令"><a href="#基本绘制命令" class="headerlink" title="基本绘制命令"></a>基本绘制命令</h1><p>通过函数 <code>vkCmdBindPipeline</code> 将渲染管线绑定到命令缓冲区中，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipeline                                  pipeline)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定进行命令记录的命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipelineBindPoint</td>
<td>管线绑定点</td>
<td>表示将要绑定的管线类型，可能的值包括：<br/><code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>：绑定一个用于图形渲染的管线。<br/><code>VK_PIPELINE_BIND_POINT_COMPUTE</code>：绑定一个用于计算操作的管线。<br/><code>VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX</code>：<code>AMDX</code> 扩展，特定于 AMD 扩展的管线绑定点，主要用于 <code>AMD</code> 硬件。<br/><code>VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR</code>：Khronos Group 的标准扩展，用于光线追踪的管线绑定点。<br/><code>VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI</code>：特定于华为扩展的管线绑定点。<br/><code>VK_PIPELINE_BIND_POINT_RAY_TRACING_NV</code>：<code>NVIDIA</code> 兼容性扩展，提供的光线追踪管线绑定点，与 <code>VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR</code> 相同。<br/><code>VK_PIPELINE_BIND_POINT_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipeline</td>
<td>渲染管线句柄</td>
<td>绑定的管线对象，在之前创建的图形管线或计算管线对象。</td>
</tr>
</tbody></table>
<p>注意：在完成渲染管线的绑定之后，需要对于在管线创建时声明为动态类型的状态进行设置，以视口和剪裁状态为例，一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);</span><br><span class="line"></span><br><span class="line">VkViewport viewport&#123;&#125;;</span><br><span class="line">viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">viewport.width = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(swapChainExtent.width);</span><br><span class="line">viewport.height = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(swapChainExtent.height);</span><br><span class="line">viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">viewport.maxDepth = <span class="number">1.0f</span>;</span><br><span class="line"><span class="built_in">vkCmdSetViewport</span>(commandBuffer, <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</span><br><span class="line"></span><br><span class="line">VkRect2D scissor&#123;&#125;;</span><br><span class="line">scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">scissor.extent = swapChainExtent;</span><br><span class="line"><span class="built_in">vkCmdSetScissor</span>(commandBuffer, <span class="number">0</span>, <span class="number">1</span>, &amp;scissor);</span><br></pre></td></tr></table></figure></div>

<p>最后，调用函数 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a> 来进行绘制，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    vertexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstVertex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定要记录绘制命令的 命令缓冲区，所有绘制命令都会写入该命令缓冲区。该命令缓冲区必须是 主命令缓冲区，或者是 <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code> 继承自主命令缓冲区的 二级命令缓冲区。</td>
</tr>
<tr>
<td>输入参数</td>
<td>vertexCount</td>
<td>顶点数量</td>
<td>需要绘制的顶点数。即，在没有索引缓冲区（index buffer）的情况下，每次绘制调用（Draw Call）会绘制 <code>vertexCount</code> 个顶点。</td>
</tr>
<tr>
<td>输入参数</td>
<td>instanceCount</td>
<td>实例数</td>
<td>实例化绘制时的实例数（Instance Count）。如果不进行实例化渲染，通常设为 <code>1</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstVertex</td>
<td>顶点偏移量</td>
<td>表示第一个顶点的索引，表示 <code>gl_VertexIndex</code> 的最小值。通常设为 <code>0</code>，表示从顶点缓冲区的第一个顶点开始绘制。</td>
</tr>
<tr>
<td>输入参数</td>
<td>firstInstance</td>
<td>实例偏移量</td>
<td>实例偏移量，用于 实例化绘制，表示 <code>gl_InstanceIndex</code> 的最小值。通常设为 <code>0</code>，表示从第一个实例开始绘制。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffer, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="结束渲染通道"><a href="#结束渲染通道" class="headerlink" title="结束渲染通道"></a>结束渲染通道</h1><p>在完成渲染通道的命令记录后，通过调用函数 <code>vkCmdEndRenderPass</code> 来结束渲染通道，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdEndRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>指定结束渲染通道命令记录的命令缓冲区。</td>
</tr>
</tbody></table>
<p>同时为了避免正在渲染的帧读取 UBO 的同时，下一帧正在更新 UBO 数据，我们需要为每个正在处理的帧维护一个独立的 UBO 缓冲区：</p>
<h2 id="更新统一数据"><a href="#更新统一数据" class="headerlink" title="更新统一数据"></a>更新统一数据</h2><p>更新统一数据，只需要生成 MVP 变换矩阵，然后将其拷贝到预先留存的持久映射指针所指的内存区域中。</p>
<p>使用 <code>glm::rotate(m, angle, v)</code> 生成模型矩阵，其参数为 <code>(源矩阵，旋转角度，旋转轴)</code>，一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ubo.model = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), time * glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>glm::lookAt(eye, center, up)</code> 生成视图矩阵，其参数为 <code>(相机位置，相机朝向，向上方向)</code>，一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ubo.view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>glm::perspective(fov, aspect, near, far)</code> 生成透视投影矩阵，其参数为 <code>(垂直视角，宽高比，近裁剪面，远裁剪面)</code>，一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ubo.proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), swapChainExtent.width / (<span class="type">float</span>)swapChainExtent.height, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br></pre></td></tr></table></figure></div>

<p>同时，虽然 <code>glm</code> 和 <code>Vulkan</code> 都是右手系，但是两者的屏幕 <code>y</code> 轴方向不同，<code>glm</code> 的屏幕 <code>y</code> 轴向上，<code>Vulkan</code> 的屏幕 <code>y</code> 轴向下，因此，需要翻转投影矩阵的 <code>y</code> 轴分量：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ubo.proj[<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></div>

<p>最后，使用 <code>memcpy</code> 进行内存拷贝：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(uniformBuffersMapped[currentImage], &amp;ubo, <span class="built_in">sizeof</span>(ubo));</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>使用 <code>glm::rotate</code> 函数时，通常使用宏 <code>GLM_FORCE_RADIANS</code> 强制使用弧度制，防止误用角度：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<h1 id="多帧并行"><a href="#多帧并行" class="headerlink" title="多帧并行"></a>多帧并行</h1><p>在一个渲染循环中如果只使用一个命令缓冲区会存在一些问题，在开始渲染下一帧之前，必须等待前一帧完成，这会导致 CPU 在提交一个命令缓冲区之后需要等待 GPU 执行完成以获得下一个可用的命令缓冲区，同时 GPU 执行完成一帧的渲染命令之后，也需要等待 CPU 完成下一帧渲染命令的录制。</p>
<p>这个问题的解决方案是**允许多帧同时进行 (Frames in Flight)**，也就是说在渲染一帧的同时，可以开始录制下一帧的命令缓冲区，使得GPU 和 CPU 上的工作能够并发的进行。</p>
<p>通常来说，并发帧数选择 <code>2</code> ，其主要的原因是当并发帧数过多时会增加<strong>输入延迟</strong>。当帧并发数太多时，当前的输入被录制到命令缓冲区之后，可能需要等待多个帧之后才能被渲染到屏幕上。对于高帧率的应用，可以适当将并发帧数提高到 <code>3</code> 来提高 CPU 和 GPU 之间的数据吞吐量。</p>
<h2 id="多帧并行的实现"><a href="#多帧并行的实现" class="headerlink" title="多帧并行的实现"></a>多帧并行的实现</h2><p>为了能够实现多帧并行，所有在渲染过程中被访问和修改的资源都需要复制以避免数据冲突。因此，需要为每个帧维护一组独立的资源，包括：</p>
<ol>
<li><p>命令缓冲 (Command Buffer)</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDevice device; 								<span class="comment">// 逻辑设备</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="number">2</span>; 			<span class="comment">// 并发帧数</span></span><br><span class="line">std::vector&lt;VkCommandBuffer&gt; commandBuffers; 	<span class="comment">// 多个命令缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCommandBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commandBuffers.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line"></span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandBufferCount = (<span class="type">uint32_t</span>)commandBuffers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.<span class="built_in">data</span>()) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate command buffers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>同步量：信号量 (Semaphore) 和 栅栏 (Fence)</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">VkDevice device; 									<span class="comment">// 逻辑设备</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="number">2</span>; 				<span class="comment">// 并发帧数</span></span><br><span class="line">std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;	<span class="comment">// 图形可用信号量</span></span><br><span class="line">std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;	<span class="comment">// 渲染完成信号量</span></span><br><span class="line">std::vector&lt;VkFence&gt; inFlightFences;				<span class="comment">// 下一帧可用栅栏</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSyncObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    imageAvailableSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    renderFinishedSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    inFlightFences.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line"></span><br><span class="line">    VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;</span><br><span class="line">    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line">    semaphoreInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    semaphoreInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    VkFenceCreateInfo fenceInfo&#123;&#125;;</span><br><span class="line">    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">    fenceInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||</span><br><span class="line">            <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS ||</span><br><span class="line">            <span class="built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create synchronization objects for a frame!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkDestroyFence</span>(device, inFlightFences[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>对于多个资源，采用索引进行管理，并在每次提交命令缓冲区之后切换索引，从而实现渲染循环中交替使用这些资源，确保 GPU 和 CPU 能够最大程度地并行运行：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="number">2</span>; <span class="comment">// 并发帧数</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> currentFrame = <span class="number">0</span>;			<span class="comment">// 记录当前帧索引</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">currentFrame = (currentFrame + <span class="number">1</span>) % MAX_FRAMES_IN_FLIGHT;  <span class="comment">// 切换到另一组资源</span></span><br></pre></td></tr></table></figure></div>

<p>一个渲染循环示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> currentFrame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkWaitForFences</span>(device, <span class="number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);</span><br><span class="line">    <span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFences[currentFrame]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取交换链图像 */</span></span><br><span class="line">    <span class="type">uint32_t</span> imageIndex;</span><br><span class="line">    <span class="built_in">vkAcquireNextImageKHR</span>(</span><br><span class="line">        device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录命令缓冲区 */</span></span><br><span class="line">    <span class="built_in">vkResetCommandBuffer</span>(commandBuffers[currentFrame], <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">recordCommandBuffer</span>(commandBuffers[currentFrame], imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提交命令缓冲区 */</span></span><br><span class="line">    VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;</span><br><span class="line">    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">    submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">    submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];</span><br><span class="line">    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;</span><br><span class="line">    submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进行呈现 */</span></span><br><span class="line">    VkPresentInfoKHR presentInfo&#123;&#125;;</span><br><span class="line">    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</span><br><span class="line">    presentInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    presentInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pWaitSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;</span><br><span class="line">    presentInfo.swapchainCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pSwapchains = swapChains;</span><br><span class="line">    presentInfo.pImageIndices = &amp;imageIndex;</span><br><span class="line">    presentInfo.pResults = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line"></span><br><span class="line">	currentFrame = (currentFrame + <span class="number">1</span>) % MAX_FRAMES_IN_FLIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h1><p>使用 <a class="link"   href="https://github.com/tinyobjloader/tinyobjloader/blob/release/tiny_obj_loader.h" >tinyobjloader<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 作为 <code>obj</code> 加载器，并定义宏 <code>TINYOBJLOADER_IMPLEMENTATION</code> 以包括函数体：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TINYOBJLOADER_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tiny_obj_loader.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>通过函数 <code>tinyobj::LoadObj</code> 来加载 <code>obj</code> 模型，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoadObj</span><span class="params">(<span class="type">attrib_t</span>* attrib,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::vector&lt;<span class="type">shape_t</span>&gt;* shapes,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::vector&lt;<span class="type">material_t</span>&gt;* materials,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::string* warn,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::string* err,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">char</span>* filename,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">char</span>* mtl_basedir,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">bool</span> triangulate,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">bool</span> default_vcols_fallback)</span></span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输出参数</td>
<td>attrib</td>
<td>顶点属性指针</td>
<td>指向 <code>tinyobj::attrib_t</code> 结构体的指针，用于存储从 OBJ 文件中加载的顶点属性（如位置、法线、纹理坐标等）。该结构体包含以下成员：<br /><code>vertices</code>: 顶点位置数组（<code>float</code> 数组，每 3 个元素表示一个顶点的 X、Y、Z 坐标）。<br /><code>normals</code>: 法线数组（<code>float</code> 数组，每 3 个元素表示一个法线的 X、Y、Z 分量）。<br /><code>texcoords</code>: 纹理坐标数组（<code>float</code> 数组，每 2 个元素表示一个纹理坐标的 U、V 值）。</td>
</tr>
<tr>
<td>输出参数</td>
<td>shapes</td>
<td>几何形状数组指针</td>
<td>指向 <code>tinyobj::shape_t</code> 向量容器的指针，用于存储从 OBJ 文件中加载的几何形状（如网格）。每个 <code>shape_t</code> 结构体表示一个独立的几何形状，包含以下成员：<br /><code>name</code>: 形状的名称。<br /><code>mesh</code>: 包含顶点索引、材质索引等信息的网格数据。</td>
</tr>
<tr>
<td>输出参数</td>
<td>materials</td>
<td>材质数组指针</td>
<td>指向 <code>tinyobj::material_t</code> 向量容器的指针，用于存储从 OBJ 文件中加载的材质信息。 每个 <code>material_t</code> 结构体表示一个材质，包含以下成员：<br /><code>name</code>: 材质的名称。<br /><code>diffuse_texname</code>: 漫反射纹理的文件名。<br /><code>ambient</code>: 环境光颜色。<br /><code>diffuse</code>: 漫反射颜色。<br /><code>specular</code>: 镜面反射颜色。</td>
</tr>
<tr>
<td>输出参数</td>
<td>warn</td>
<td>警告信息指针</td>
<td>指向 <code>std::string</code> 的指针，用于存储加载过程中产生的警告信息。 <br />如果加载过程中出现非致命问题（如缺少材质定义），警告信息将存储在此字符串中。</td>
</tr>
<tr>
<td>输出参数</td>
<td>err</td>
<td>错误信息指针</td>
<td>指向 <code>std::string</code> 的指针，用于存储加载过程中产生的错误信息。<br />如果加载过程中出现致命错误（如文件不存在），错误信息将存储在此字符串中。</td>
</tr>
<tr>
<td>输入参数</td>
<td>filename</td>
<td>模型文件路径</td>
<td><code>obj</code> 模型文件的路径。</td>
</tr>
<tr>
<td>输入参数</td>
<td>mtl_basedir</td>
<td>材质文件基础目录</td>
<td>如果 OBJ 文件引用了外部材质文件（MTL），可以指定材质文件的搜索目录。如果为 <code>nullptr</code>，则默认使用 OBJ 文件所在目录。</td>
</tr>
<tr>
<td>输入参数</td>
<td>triangulate</td>
<td>是否将多边形面自动三角化</td>
<td>如果为 <code>true</code>，则将所有多边形面（如四边形）自动转换为三角形。默认值为 <code>true</code>。</td>
</tr>
<tr>
<td></td>
<td>default_vcols_fallback</td>
<td></td>
<td></td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>加载是否成功</td>
<td>返回 <code>true</code> 表示加载成功，返回 <code>false</code> 表示加载失败。</td>
</tr>
</tbody></table>
<p>一个示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadModel</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tinyobj::<span class="type">attrib_t</span> attrib;</span><br><span class="line">    std::vector&lt;tinyobj::<span class="type">shape_t</span>&gt; shapes;</span><br><span class="line">    std::vector&lt;tinyobj::<span class="type">material_t</span>&gt; materials;</span><br><span class="line">    std::string warn, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tinyobj::<span class="built_in">LoadObj</span>(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.<span class="built_in">c_str</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(warn + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，对于加载的数据进行整理，使其符合现有的数据结构：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadModel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; shape : shapes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; index : shape.mesh.indices)</span><br><span class="line">        &#123;</span><br><span class="line">            Vertex vertex&#123;&#125;;</span><br><span class="line"></span><br><span class="line">            vertex.pos = &#123;attrib.vertices[<span class="number">3</span> * index.vertex_index + <span class="number">0</span>],</span><br><span class="line">                          attrib.vertices[<span class="number">3</span> * index.vertex_index + <span class="number">1</span>],</span><br><span class="line">                          attrib.vertices[<span class="number">3</span> * index.vertex_index + <span class="number">2</span>]&#125;;</span><br><span class="line"></span><br><span class="line">            vertex.texCoord = &#123;attrib.texcoords[<span class="number">2</span> * index.texcoord_index + <span class="number">0</span>],</span><br><span class="line">                               attrib.texcoords[<span class="number">2</span> * index.texcoord_index + <span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">            vertex.color = &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">            vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">            indices.<span class="built_in">push_back</span>(indices.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：OBJ 格式假设一个坐标系，其中垂直坐标为 <code>0</code> 表示图像的底部，然而读取时以从上到下的方向将图像上传到 Vulkan，其中 <code>0</code> 表示图像的顶部。通过翻转纹理坐标的垂直分量来解决这个问题：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">vertex.texCoord = &#123;attrib.texcoords[<span class="number">2</span> * index.texcoord_index + <span class="number">0</span>],</span><br><span class="line">                               <span class="number">1.0f</span> - attrib.texcoords[<span class="number">2</span> * index.texcoord_index + <span class="number">1</span>]&#125;;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
</search>
