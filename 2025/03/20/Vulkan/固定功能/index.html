<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="王小龙">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/03/20/vulkan/固定功能/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="固定功能在 Vulkan 中，需要对于图形管线中的每个部分显示地进行配置。 动态状态大部分管线状态都需要预设，但部分管线状态可以在绘制时进行改变而无需重新创建管线，例如视口大小。对于需要动态使用的状态，需要使用 VkPipelineDynamicStateCreateInfo 来显示指定，其声明如下： 1234567typedef struct VkPipelineDynamicStateCrea">
<meta property="og:type" content="article">
<meta property="og:title" content="固定功能">
<meta property="og:url" content="http://example.com/2025/03/20/Vulkan/%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="固定功能在 Vulkan 中，需要对于图形管线中的每个部分显示地进行配置。 动态状态大部分管线状态都需要预设，但部分管线状态可以在绘制时进行改变而无需重新创建管线，例如视口大小。对于需要动态使用的状态，需要使用 VkPipelineDynamicStateCreateInfo 来显示指定，其声明如下： 1234567typedef struct VkPipelineDynamicStateCrea">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-20T06:52:08.863Z">
<meta property="article:modified_time" content="2025-03-20T07:37:42.745Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Vulkan">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            固定功能 | 小龙的笔记本
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"小龙的笔记本","subtitle":{"text":[],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                小龙的笔记本
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">2</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">23</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">固定功能</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/image/avatar.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">王小龙</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-03-20 14:52:08</span>
        <span class="mobile">2025-03-20 14:52:08</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-20 15:37:42</span>
            <span class="mobile">2025-03-20 15:37:42</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Vulkan/">Vulkan</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>8.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>31 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="固定功能"><a href="#固定功能" class="headerlink" title="固定功能"></a>固定功能</h1><p>在 Vulkan 中，需要对于图形管线中的每个部分显示地进行配置。</p>
<h2 id="动态状态"><a href="#动态状态" class="headerlink" title="动态状态"></a>动态状态</h2><p>大部分管线状态都需要预设，但部分管线状态可以在绘制时进行改变而无需重新创建管线，例如视口大小。对于需要动态使用的状态，需要使用 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDynamicStateCreateInfo.html"><code>VkPipelineDynamicStateCreateInfo</code></a> 来显示指定，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineDynamicStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                      sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                          pNext;</span><br><span class="line">    VkPipelineDynamicStateCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                             dynamicStateCount;</span><br><span class="line">    <span class="type">const</span> VkDynamicState*                pDynamicStates;</span><br><span class="line">&#125; VkPipelineDynamicStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</code>，以表明这是一个着色器管线动态状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>dynamicStateCount</td>
<td>动态状态的数量</td>
<td><code>pDynamicStates</code> 数组中的状态数。</td>
</tr>
<tr>
<td>pDynamicStates</td>
<td>动态状态枚举值的数组</td>
<td>常见的枚举值包括：<br/><code>VK_DYNAMIC_STATE_VIEWPORT</code>：视口（viewport）状态<br/><code>VK_DYNAMIC_STATE_SCISSOR</code>：裁剪区域（scissor）状态<br/><code>VK_DYNAMIC_STATE_LINE_WIDTH</code>：线条宽度（line width）<br/><code>VK_DYNAMIC_STATE_DEPTH_BIAS</code>：深度偏移（depth bias）<br/><code>VK_DYNAMIC_STATE_BLEND_CONSTANTS</code>：混合常量（blend constants）<br/><code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code>：深度范围（depth bounds）<br/><code>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</code>：模板比较掩码（stencil compare mask）<br/><code>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</code>：模板写掩码（stencil write mask）<br/><code>VK_DYNAMIC_STATE_STENCIL_REFERENCE</code>：模板参考值（stencil reference）</td>
</tr>
</tbody></table>
<p>调用示例：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR&#125;;</span><br><span class="line"></span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;</span><br><span class="line">dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">dynamicState.flags = <span class="number">0</span>;</span><br><span class="line">dynamicState.dynamicStateCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dynamicStates.<span class="built_in">size</span>());</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a> 完成着色器管线<strong>顶点输入</strong>状态的创建，其描述了传递给顶点着色器的数据格式，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineVertexInputStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                 pNext;</span><br><span class="line">    VkPipelineVertexInputStateCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                                    vertexBindingDescriptionCount;</span><br><span class="line">    <span class="type">const</span> VkVertexInputBindingDescription*      pVertexBindingDescriptions;</span><br><span class="line">    <span class="type">uint32_t</span>                                    vertexAttributeDescriptionCount;</span><br><span class="line">    <span class="type">const</span> VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;</span><br><span class="line">&#125; VkPipelineVertexInputStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</code>，以表明这是一个着色器管线顶点输入状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>vertexBindingDescriptionCount</td>
<td>顶点绑定描述符的数量</td>
<td><code>pVertexBindingDescriptions</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pVertexBindingDescriptions</td>
<td><code>VkVertexInputBindingDescription</code> 结构体数组</td>
<td>描述每个顶点绑定的详细信息。</td>
</tr>
<tr>
<td>vertexAttributeDescriptionCount</td>
<td>顶点属性描述符的数量</td>
<td><code>pVertexAttributeDescriptions</code> 数组中的元素数量。</td>
</tr>
<tr>
<td>pVertexAttributeDescriptions</td>
<td><code>VkVertexInputAttributeDescription</code> 结构体数组</td>
<td>描述每个顶点属性的详细信息。</td>
</tr>
</tbody></table>
<h3 id="顶点绑定"><a href="#顶点绑定" class="headerlink" title="顶点绑定"></a>顶点绑定</h3><p> 结构体 <code>vertexBindingDescriptionCount</code> 描述了<strong>顶点绑定</strong>的详细信息，描述了数据之间的间距，以及数据是按顶点（per-vertex）还是按实例（per-instance）传递的，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputBindingDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>             binding;</span><br><span class="line">    <span class="type">uint32_t</span>             stride;</span><br><span class="line">    VkVertexInputRate    inputRate;</span><br><span class="line">&#125; VkVertexInputBindingDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>binding</td>
<td>顶点绑定的索引</td>
<td></td>
</tr>
<tr>
<td>stride</td>
<td>每个顶点的数据间距</td>
<td>以字节计数。</td>
</tr>
<tr>
<td>inputRate</td>
<td>数据的步进方式</td>
<td><code>VK_VERTEX_INPUT_RATE_VERTEX</code>：按照定点步进<br/><code>VK_VERTEX_INPUT_RATE_INSTANCE</code>：按照实例步进<br/><code>VK_VERTEX_INPUT_RATE_MAX_ENUM</code>：保留字段</td>
</tr>
</tbody></table>
<h3 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h3><p>结构体 <code>VkVertexInputAttributeDescription</code> 描述了<strong>顶点属性</strong>的详细信息，描述了传递给顶点着色器的属性类型，指定数据应从哪个绑定（binding）加载，并指定数据的偏移量，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputAttributeDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    location;</span><br><span class="line">    <span class="type">uint32_t</span>    binding;</span><br><span class="line">    VkFormat    format;</span><br><span class="line">    <span class="type">uint32_t</span>    offset;</span><br><span class="line">&#125; VkVertexInputAttributeDescription;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>location</td>
<td>属性的索引</td>
<td>通常与顶点着色器中的输入变量位置相对应。</td>
</tr>
<tr>
<td>binding</td>
<td>绑定到属性的索引</td>
<td>通常与 <code>VkVertexInputBindingDescription</code> 中的 <code>binding</code> 对应。</td>
</tr>
<tr>
<td>format</td>
<td>属性的格式</td>
<td>属性的格式，指定数据的类型，如 <code>VK_FORMAT_R32G32B32_SFLOAT</code>。</td>
</tr>
<tr>
<td>offset</td>
<td>数据在顶点缓冲区中的偏移量</td>
<td></td>
</tr>
</tbody></table>
<h2 id="输入装配"><a href="#输入装配" class="headerlink" title="输入装配"></a>输入装配</h2><p>通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a> 来描述<strong>输入装配</strong>（Input Assembly）信息，描述了<strong>几何图形类型（Geometry Type）</strong> 以及<strong>是否启用原语重启（Primitive Restart）</strong>。其描述了从顶点生成的几何图形类型，是否允许在一些拓扑模式下通过指定特殊的索引值来重启图形原语，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineInputAssemblyStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                pNext;</span><br><span class="line">    VkPipelineInputAssemblyStateCreateFlags    flags;</span><br><span class="line">    VkPrimitiveTopology                        topology;</span><br><span class="line">    VkBool32                                   primitiveRestartEnable;</span><br><span class="line">&#125; VkPipelineInputAssemblyStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</code>，以表明这是一个着色器管线输入装配状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>topology</td>
<td>输入装配阶段所处理的几何图形类型</td>
<td><code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>: 每个顶点作为一个独立的点。<br/><code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>: 每两个顶点组成一条线（不重复使用顶点）。<br/><code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP</code>: 每条线的结束顶点作为下一条线的起始顶点。<br/><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>: 每三个顶点组成一个独立的三角形（不重复使用顶点）。<br/><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</code>: 每个三角形的第二个和第三个顶点作为下一个三角形的前两个顶点。</td>
</tr>
<tr>
<td>primitiveRestartEnable</td>
<td>是否启用原语重启功能</td>
<td>设置为 <code>VK_TRUE</code> 启用原语重启，设置为 <code>VK_FALSE</code> 则禁用。<br/>原语重启允许你在某些拓扑模式下通过特殊的索引值（例如 <code>0xFFFF</code> 或 <code>0xFFFFFFFF</code>）来断开当前图元，重新开始一个新的图元。</td>
</tr>
</tbody></table>
<h2 id="视口和裁剪矩形"><a href="#视口和裁剪矩形" class="headerlink" title="视口和裁剪矩形"></a>视口和裁剪矩形</h2><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口描述了帧缓冲区的大小，其通常从  <code>(0, 0)</code> 到 <code>(width, height)</code> （以像素为单位），其定义了从图像到帧缓冲区的映射。需要注意的是，视口的大小应该是交换链中图像的大小，而不是窗口的大小。通过结构体 <code>VkViewport</code> 可以定义视口的属性，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkViewport</span> &#123;</span><br><span class="line">    <span class="type">float</span>    x;</span><br><span class="line">    <span class="type">float</span>    y;</span><br><span class="line">    <span class="type">float</span>    width;</span><br><span class="line">    <span class="type">float</span>    height;</span><br><span class="line">    <span class="type">float</span>    minDepth;</span><br><span class="line">    <span class="type">float</span>    maxDepth;</span><br><span class="line">&#125; VkViewport;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>视口的左上角的 X 坐标</td>
<td>该值定义了视口在帧缓冲区中的水平位置。</td>
</tr>
<tr>
<td>y</td>
<td>视口的左上角的 Y 坐标</td>
<td>该值定义了视口在帧缓冲区中的垂直位置。</td>
</tr>
<tr>
<td>width</td>
<td>视口的宽度</td>
<td>该值指定视口的水平尺寸，通常是输出图像的宽度，一般取交换链的图像宽度。</td>
</tr>
<tr>
<td>height</td>
<td>视口的高度</td>
<td>该值指定视口的垂直尺寸，通常是输出图像的高度，一般取交换链的图像高度。</td>
</tr>
<tr>
<td>minDepth</td>
<td>深度值的最小值</td>
<td>该值指定了视口的深度范围的下界，通常是 <code>0.0f</code>，但在某些情况下也可以更改。</td>
</tr>
<tr>
<td>maxDepth</td>
<td>深度值的最大值</td>
<td>该值指定了视口的深度范围的上界，通常是 <code>1.0f</code>，但在某些情况下也可以更改。</td>
</tr>
</tbody></table>
<p>注意：根据需求，最小值可以大于最大值。一个声明示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkViewport viewport&#123;&#125;;</span><br><span class="line">viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">viewport.width = (<span class="type">float</span>) swapChainExtent.width;</span><br><span class="line">viewport.height = (<span class="type">float</span>) swapChainExtent.height;</span><br><span class="line">viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">viewport.maxDepth = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="裁剪矩形"><a href="#裁剪矩形" class="headerlink" title="裁剪矩形"></a>裁剪矩形</h3><p><strong>剪裁矩形</strong>（Scissor Rectangles）定义了哪些区域的像素会实际存储。任何位于剪裁矩形之外的像素都会被光栅化器丢弃。裁剪区域由结构体 <code>VkRect2D</code> 定义，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRect2D</span> &#123;</span><br><span class="line">    VkOffset2D    offset;</span><br><span class="line">    VkExtent2D    extent;</span><br><span class="line">&#125; VkRect2D;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>offset</td>
<td>裁剪矩形的左上角位置</td>
<td><code>x</code>: 矩形左上角的水平偏移量（相对于帧缓冲区的原点）。<br /><code>y</code>: 矩形左上角的垂直偏移量（相对于帧缓冲区的原点）。</td>
</tr>
<tr>
<td>extent</td>
<td>裁剪矩形的宽度和高度</td>
<td><code>width</code>: 矩形的宽度。<br /><code>height</code>: 矩形的高度。</td>
</tr>
</tbody></table>
<p>一个声明示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkRect2D scissor&#123;&#125;;</span><br><span class="line">scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">scissor.extent = swapChainExtent;</span><br></pre></td></tr></table></figure></div>

<h3 id="视口创建"><a href="#视口创建" class="headerlink" title="视口创建"></a>视口创建</h3><p>通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineViewportStateCreateInfo.html"><code>VkPipelineViewportStateCreateInfo</code></a> 完成管线<strong>视口</strong>信息的描述，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineViewportStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                       sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                           pNext;</span><br><span class="line">    VkPipelineViewportStateCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                              viewportCount;</span><br><span class="line">    <span class="type">const</span> VkViewport*                     pViewports;</span><br><span class="line">    <span class="type">uint32_t</span>                              scissorCount;</span><br><span class="line">    <span class="type">const</span> VkRect2D*                       pScissors;</span><br><span class="line">&#125; VkPipelineViewportStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</code>，以表明这是一个着色器管线视口状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>viewportCount</td>
<td>视口数量</td>
<td>描述管线中视口的数量。如果支持多视口渲染，则此值大于 1。</td>
</tr>
<tr>
<td>pViewports</td>
<td>视口数组</td>
<td>视口数组指针，其中的每个元素定义了一个视口。</td>
</tr>
<tr>
<td>scissorCount</td>
<td>剪裁矩形数量</td>
<td>剪裁矩形用于限制渲染的区域。多个剪裁矩形用于多视口渲染，通常与视口数量相匹配。</td>
</tr>
<tr>
<td>pScissors</td>
<td>裁剪矩形数组</td>
<td>裁剪矩形数组指针，其中的每个元素定义了一个裁剪矩形。</td>
</tr>
</tbody></table>
<p>在渲染管线创建时，视口和裁剪矩形能够以<strong>静态</strong>或者<strong>动态</strong>的方式指明，通常采取动态的方式。在动态方式下，需要在动态状态中指明视口 <code>VK_DYNAMIC_STATE_VIEWPORT</code> 和裁剪矩形 <code>VK_DYNAMIC_STATE_SCISSOR</code>，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;</span><br><span class="line">    VK_DYNAMIC_STATE_VIEWPORT,</span><br><span class="line">    VK_DYNAMIC_STATE_SCISSOR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;</span><br><span class="line">dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.dynamicStateCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dynamicStates.<span class="built_in">size</span>());</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;</span><br><span class="line">viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">viewportState.flags = <span class="number">0</span>;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果使用静态方式，则需要向 <code>VkPipelineViewportStateCreateInfo</code> 中传递视口和裁剪矩形数组，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;</span><br><span class="line">viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pViewports = &amp;viewport;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pScissors = &amp;scissor;</span><br></pre></td></tr></table></figure></div>

<h2 id="光栅化器"><a href="#光栅化器" class="headerlink" title="光栅化器"></a>光栅化器</h2><p><strong>光栅化器</strong>（Rasterizer）将由顶点着色器生成的几何体转换为片段（Fragments），以供片段着色器使用。在光栅化阶段，光栅化器还会执行<strong>深度测试</strong>、<strong>剔除</strong>、<strong>裁剪测试</strong>。通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a> 可以定义一个光栅化器，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                pNext;</span><br><span class="line">    VkPipelineRasterizationStateCreateFlags    flags;</span><br><span class="line">    VkBool32                                   depthClampEnable;</span><br><span class="line">    VkBool32                                   rasterizerDiscardEnable;</span><br><span class="line">    VkPolygonMode                              polygonMode;</span><br><span class="line">    VkCullModeFlags                            cullMode;</span><br><span class="line">    VkFrontFace                                frontFace;</span><br><span class="line">    VkBool32                                   depthBiasEnable;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasConstantFactor;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasClamp;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasSlopeFactor;</span><br><span class="line">    <span class="type">float</span>                                      lineWidth;</span><br><span class="line">&#125; VkPipelineRasterizationStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</code>，以表明这是一个着色器管线光栅化器状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>depthClampEnable</td>
<td>启用或禁用深度裁剪</td>
<td>默认值 <code>VK_FALSE</code>，如果设置为 <code>VK_TRUE</code>，深度值超出近平面和远平面范围的片段会被限制在这两个平面之间，而不是被丢弃。对于阴影贴图等操作，这个选项非常有用。启用此选项需要支持 <code>depthClamp</code> GPU 特性。</td>
</tr>
<tr>
<td>rasterizerDiscardEnable</td>
<td>启用或禁用跳过光栅化</td>
<td>默认值 <code>VK_FALSE</code>，如果设置为 <code>VK_TRUE</code>，几何体将跳过光栅化阶段，几何体不会被传递到片段着色器。这意味着没有片段会被生成，输出也不会写入帧缓冲区。通常用于不需要绘制的几何体，例如用于某些剔除或优化操作。</td>
</tr>
<tr>
<td>polygonMode</td>
<td>几何片段的生成模式</td>
<td>指定如何生成几何体的片段。它决定了几何体如何在屏幕上被渲染。可用的选项包括：<br/><code>VK_POLYGON_MODE_FILL</code>：填充多边形区域。<br/><code>VK_POLYGON_MODE_LINE</code>：绘制多边形的边缘作为线条（线框渲染）。<br/><code>VK_POLYGON_MODE_POINT</code>：绘制多边形的顶点作为点。<br /><code>VK_POLYGON_MODE_FILL_RECTANGLE_NV</code>：直接填充矩形区域，属于 <strong>NVIDIA</strong> 的专有扩展 <code>VK_NV_fill_rectangle</code>。<br /><code>VK_POLYGON_MODE_MAX_ENUM</code> ：保留值。<br />使用除 <code>VK_POLYGON_MODE_FILL</code> 之外的任何模式都需要启用 GPU 特性。</td>
</tr>
<tr>
<td>cullMode</td>
<td>面剔除方式</td>
<td>指定哪些面需要被剔除。可选值包括：<br/><code>VK_CULL_MODE_NONE</code>：不进行面剔除。<br/><code>VK_CULL_MODE_FRONT_BIT</code>：剔除前面。<br/><code>VK_CULL_MODE_BACK_BIT</code>：剔除背面。<br/><code>VK_CULL_MODE_FRONT_AND_BACK_BIT</code>：剔除前面和背面。<br /><code>VK_CULL_MODE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>frontFace</td>
<td>面剔除的正面的顶点顺序</td>
<td>指定正面面（front-facing）的顶点顺序，这会影响哪些面被认为是正面，哪些被认为是背面，可选值包括：<br /><code>VK_FRONT_FACE_CLOCKWISE</code>：顺时针。<br /><code>VK_FRONT_FACE_COUNTER_CLOCKWISE</code>：逆时针。<br /><code>VK_FRONT_FACE_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>depthBiasEnable</td>
<td>启用或禁用深度偏移</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用深度偏移。深度偏移用于调整片段的深度值，通常用于避免深度冲突（如阴影贴图中的“Z-fighting”）。在这种情况下，可以通过 <code>depthBiasConstantFactor</code> 和 <code>depthBiasSlopeFactor</code> 来指定偏移量。没有此需求时，应该设置为 <code>VK_FALSE</code>。</td>
</tr>
<tr>
<td>depthBiasConstantFactor</td>
<td>常数深度偏移量</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定常数深度偏移量。它通常用于在深度测试中调整深度值。</td>
</tr>
<tr>
<td>depthBiasClamp</td>
<td>深度偏移的最大值</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定深度偏移的最大值。</td>
</tr>
<tr>
<td>depthBiasSlopeFactor</td>
<td>斜率深度偏移量</td>
<td>如果 <code>depthBiasEnable</code> 设置为 <code>VK_TRUE</code>，此值指定与片段的斜率相关的深度偏移量。它用于在深度计算中根据片段的斜率来偏移深度值。</td>
</tr>
<tr>
<td>lineWidth</td>
<td>线条的宽度</td>
<td>值表示线条的厚度，以片段为单位。大于 <code>1.0f</code> 的线宽要求启用 GPU 特性 <code>wideLines</code>。线宽过大时可能需要更多的资源来渲染。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;</span><br><span class="line">rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;</span><br><span class="line">rasterizer.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">rasterizer.flags = <span class="number">0</span>;</span><br><span class="line">rasterizer.depthClampEnable = VK_FALSE;</span><br><span class="line">rasterizer.rasterizerDiscardEnable = VK_FALSE;</span><br><span class="line">rasterizer.polygonMode = VK_POLYGON_MODE_FILL;</span><br><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;</span><br><span class="line">rasterizer.depthBiasEnable = VK_FALSE;</span><br><span class="line">rasterizer.depthBiasConstantFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasClamp = <span class="number">0.0f</span>;          <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasSlopeFactor = <span class="number">0.0f</span>;    <span class="comment">// Optional</span></span><br><span class="line">rasterizer.lineWidth = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h2><p>多重采样（Multisample）是实现抗锯齿的一种方式，其通过将多个多边形的片段着色器结果组合在一起，来减少锯齿现象。多重采样主要在边缘区域工作，因为这些区域通常是最容易出现锯齿伪影的地方。通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a> 来配置多重采样，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineMultisampleStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                              pNext;</span><br><span class="line">    VkPipelineMultisampleStateCreateFlags    flags;</span><br><span class="line">    VkSampleCountFlagBits                    rasterizationSamples;</span><br><span class="line">    VkBool32                                 sampleShadingEnable;</span><br><span class="line">    <span class="type">float</span>                                    minSampleShading;</span><br><span class="line">    <span class="type">const</span> VkSampleMask*                      pSampleMask;</span><br><span class="line">    VkBool32                                 alphaToCoverageEnable;</span><br><span class="line">    VkBool32                                 alphaToOneEnable;</span><br><span class="line">&#125; VkPipelineMultisampleStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</code>，以表明这是一个着色器管线多重采样状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>rasterizationSamples</td>
<td>多重采样的样本数</td>
<td>该值决定了每个像素所采集的样本数，通常用于控制抗锯齿的效果与性能之间的权衡，可用的值包括：<br /><code>VK_SAMPLE_COUNT_1_BIT</code>：不使用多重采样。<br /><code>VK_SAMPLE_COUNT_2_BIT </code>：每像素 <code>2</code> 重采样。<br /><code>VK_SAMPLE_COUNT_4_BIT </code>：每像素 <code>4</code> 重采样。<br /><code>VK_SAMPLE_COUNT_8_BIT </code>：每像素 <code>8</code> 重采样。<br /><code>VK_SAMPLE_COUNT_16_BIT </code>：每像素 <code>16</code> 重采样。<br /><code>VK_SAMPLE_COUNT_32_BIT </code>：每像素 <code>32</code> 重采样。<br /><code>VK_SAMPLE_COUNT_64_BIT </code>：每像素 <code>64</code> 重采样。<br /><code>VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>sampleShadingEnable</td>
<td>启用或禁用样本着色</td>
<td>如果设置为 <code>VK_TRUE</code>，启用样本着色（sample shading），即对每个采样点单独进行着色计算。<br />如果设置为 <code>VK_FALSE</code>，则每个像素的所有样本使用相同的片段着色器计算结果。开启 <code>sampleShadingEnable</code> 需要设置 <code>minSampleShading</code>。</td>
</tr>
<tr>
<td>minSampleShading</td>
<td>最小采样比例</td>
<td>当 <code>sampleShadingEnable</code> 为 <code>VK_TRUE</code> 时，指定片段着色器在多重采样过程中进行采样的最小比例。<br />该值表示最小的样本着色比率，范围 <code>[0,1]</code>。如果设置为 <code>1.0</code>，表示所有的样本都必须独立着色；如果设置为较小的值，则可能使用合并样本的方式进行优化，适用于不需要完全独立着色的情况。</td>
</tr>
<tr>
<td>pSampleMask</td>
<td>每个采样点的掩码</td>
<td>一个可选的位掩码，用于指定每个采样点的掩码。每个位的值对应一个样本，如果该位为 1，则该样本被启用，否则该样本会被禁用。通常用于实现自定义的多重采样。</td>
</tr>
<tr>
<td>alphaToCoverageEnable</td>
<td>启用或禁用透明通道覆盖</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用 Alpha-to-Coverage。这个功能使用 alpha 通道来影响样本的覆盖情况，常用于抗锯齿处理，尤其是在多重采样抗锯齿（MSAA）中。</td>
</tr>
<tr>
<td>alphaToOneEnable</td>
<td>启用或禁用忽略透明通道</td>
<td>如果设置为 <code>VK_TRUE</code>，则将所有的 alpha 通道值设置为 1.0f，忽略原始 alpha 值。这个选项主要在启用了 <code>alphaToCoverageEnable</code> 时使用。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;</span><br><span class="line">multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;</span><br><span class="line">multisampling.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">multisampling.flags = <span class="number">0</span>;</span><br><span class="line">multisampling.sampleShadingEnable = VK_FALSE;</span><br><span class="line">multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">multisampling.minSampleShading = <span class="number">1.0f</span>;          </span><br><span class="line">multisampling.pSampleMask = <span class="literal">nullptr</span>;            </span><br><span class="line">multisampling.alphaToCoverageEnable = VK_FALSE; </span><br><span class="line">multisampling.alphaToOneEnable = VK_FALSE; </span><br></pre></td></tr></table></figure></div>

<h2 id="深度和模版测试"><a href="#深度和模版测试" class="headerlink" title="深度和模版测试"></a>深度和模版测试</h2><h3 id="模版测试"><a href="#模版测试" class="headerlink" title="模版测试"></a>模版测试</h3><p>通过结构体 <code>VkStencilOpState</code> 完成对于模版测试的配置，其定义了如何在模板测试阶段对模板缓冲区进行处理，包括模板比较、模板操作等，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkStencilOpState</span> &#123;</span><br><span class="line">    VkStencilOp    failOp;</span><br><span class="line">    VkStencilOp    passOp;</span><br><span class="line">    VkStencilOp    depthFailOp;</span><br><span class="line">    VkCompareOp    compareOp;</span><br><span class="line">    <span class="type">uint32_t</span>       compareMask;</span><br><span class="line">    <span class="type">uint32_t</span>       writeMask;</span><br><span class="line">    <span class="type">uint32_t</span>       reference;</span><br><span class="line">&#125; VkStencilOpState;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>failOp</td>
<td>模板测试失败时执行的操作</td>
<td>模板比较失败后如何处理模板值。常见操作包括：<br /><code>VK_STENCIL_OP_KEEP</code>：保持当前模板值。<br/><code>VK_STENCIL_OP_ZERO</code>：将模板值设为 0。<br/><code>VK_STENCIL_OP_REPLACE</code>：将模板值替换为参考值。<br/><code>VK_STENCIL_OP_INCREMENT_AND_CLAMP</code>：递增模板值，并且将其限制在最大值。<br/><code>VK_STENCIL_OP_DECREMENT_AND_CLAMP</code>：递减模板值，并且将其限制在最小值。<br/><code>VK_STENCIL_OP_INVERT</code>：反转模板值。<br/><code>VK_STENCIL_OP_INCREMENT_AND_WRAP</code>：递增模版值，并在模板值达到最大值时回绕回最小值。<br/><code>VK_STENCIL_OP_DECREMENT_AND_WRAP</code>：递减模板值，并在模板值达到最小值时回绕回最大值。<br/><code>VK_STENCIL_OP_MAX_ENUM</code>：保留值</td>
</tr>
<tr>
<td>passOp</td>
<td>模板测试通过时执行的操作</td>
<td>模板比较通过后如何处理模板值。常见操作与 <code>failOp</code> 类似，提供了对模板缓冲区的修改选项。</td>
</tr>
<tr>
<td>depthFailOp</td>
<td>模板测试通过但深度测试失败时执行的操作</td>
<td>当模板测试成功，但片段的深度与深度缓冲区中的值进行比较时，如果深度测试失败，则执行此操作。常见操作同 <code>failOp</code> 和 <code>passOp</code>，用于在深度测试失败时处理模板值。</td>
</tr>
<tr>
<td>compareOp</td>
<td>模版比较操作</td>
<td>指定模板比较操作，决定如何比较模板参考值和模板缓冲区中的模板值。常见的比较操作包括：<br /><code>VK_COMPARE_OP_NEVER</code>：永远失败。<br/><code>VK_COMPARE_OP_LESS</code>：片段深度小于当前深度时通过。<br/><code>VK_COMPARE_OP_EQUAL</code>：片段深度等于当前深度时通过。<br/><code>VK_COMPARE_OP_LESS_OR_EQUAL</code>：片段深度小于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER</code>：片段深度大于当前深度时通过。<br/><code>VK_COMPARE_OP_NOT_EQUAL</code>：片段深度不等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER_OR_EQUAL</code>：片段深度大于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_ALWAYS</code>：永远通过。<br/><code>VK_COMPARE_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>compareMask</td>
<td>模板比较掩码</td>
<td>此掩码与模板值进行按位与操作后再进行比较，以控制哪些位参与比较。设置为 <code>0xFF</code> 时表示所有位都参与比较。</td>
</tr>
<tr>
<td>writeMask</td>
<td>模版写入掩码</td>
<td>指定哪些位可以写入模板缓冲区。如果某个位被掩码屏蔽，则该位的值不会被修改。通常设置为 <code>0xFF</code> 表示所有位都可以被修改。</td>
</tr>
<tr>
<td>reference</td>
<td>模板参考值</td>
<td>与模板缓冲区中的模板值进行比较时使用的参考值。该值通常由应用程序设置，并用于与模板缓冲区中的模板值进行比较，依据 <code>compareOp</code> 的值决定比较规则。</td>
</tr>
</tbody></table>
<h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>通过结构体<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a> 完成对于深度测试和模版测试的配置，控制如何进行深度比较、模板操作以及深度和模板的写入，声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineDepthStencilStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                           sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                               pNext;</span><br><span class="line">    VkPipelineDepthStencilStateCreateFlags    flags;</span><br><span class="line">    VkBool32                                  depthTestEnable;</span><br><span class="line">    VkBool32                                  depthWriteEnable;</span><br><span class="line">    VkCompareOp                               depthCompareOp;</span><br><span class="line">    VkBool32                                  depthBoundsTestEnable;</span><br><span class="line">    VkBool32                                  stencilTestEnable;</span><br><span class="line">    VkStencilOpState                          front;</span><br><span class="line">    VkStencilOpState                          back;</span><br><span class="line">    <span class="type">float</span>                                     minDepthBounds;</span><br><span class="line">    <span class="type">float</span>                                     maxDepthBounds;</span><br><span class="line">&#125; VkPipelineDepthStencilStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</code>，以表明这是一个着色器管线深度和模版状态创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>depthTestEnable</td>
<td>启用或禁用深度测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用深度测试，片段的深度值将不会与深度缓冲区中的值进行比较。</td>
</tr>
<tr>
<td>depthWriteEnable</td>
<td>启用或禁用深度写入</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用深度写入，片段的深度值将不会写入深度缓冲区，但仍然可以进行深度比较。</td>
</tr>
<tr>
<td>depthCompareOp</td>
<td>深度比较操作</td>
<td>指定深度比较操作，控制如何对比片段的深度值和深度缓冲区中的现有深度值。常见的值包括：<br/><code>VK_COMPARE_OP_NEVER</code>：永远失败。<br/><code>VK_COMPARE_OP_LESS</code>：片段深度小于当前深度时通过（常用）。<br/><code>VK_COMPARE_OP_EQUAL</code>：片段深度等于当前深度时通过。<br/><code>VK_COMPARE_OP_LESS_OR_EQUAL</code>：片段深度小于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER</code>：片段深度大于当前深度时通过。<br/><code>VK_COMPARE_OP_NOT_EQUAL</code>：片段深度不等于当前深度时通过。<br/><code>VK_COMPARE_OP_GREATER_OR_EQUAL</code>：片段深度大于或等于当前深度时通过。<br/><code>VK_COMPARE_OP_ALWAYS</code>：永远通过。<br/><code>VK_COMPARE_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>depthBoundsTestEnable</td>
<td>启用或禁用深度边界测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果启用，片段的深度值将被检查是否在 <code>minDepthBounds</code> 和 <code>maxDepthBounds</code> 指定的深度范围内。</td>
</tr>
<tr>
<td>stencilTestEnable</td>
<td>启用或禁用模版测试</td>
<td><code>VK_TRUE</code> 启用，<code>VK_FALSE</code> 禁用。如果禁用模板测试，模板缓冲区中的值将不会参与比较操作。</td>
</tr>
<tr>
<td>front</td>
<td>配置前面（顺时针）面的模板操作</td>
<td><code>VkStencilOpState</code> 定义的模版操作。</td>
</tr>
<tr>
<td>back</td>
<td>配置背面（逆时针）面的模板操作</td>
<td><code>VkStencilOpState</code> 定义的模版操作。</td>
</tr>
<tr>
<td>minDepthBounds</td>
<td>深度边界的最小值</td>
<td>仅在 <code>depthBoundsTestEnable</code> 为 <code>VK_TRUE</code> 时有效。</td>
</tr>
<tr>
<td>maxDepthBounds</td>
<td>深度边界的最大值</td>
<td>仅在 <code>depthBoundsTestEnable</code> 为 <code>VK_TRUE</code> 时有效。</td>
</tr>
</tbody></table>
<h2 id="颜色混合"><a href="#颜色混合" class="headerlink" title="颜色混合"></a>颜色混合</h2><p>在片段着色器返回颜色之后，它需要与已经存在于帧缓冲区中的颜色进行合成。这一转换过程称为颜色混合（Color Blending）。颜色混合有两种方式来实现：1.将旧的颜色值与新的颜色值混合，生成最终的颜色；2.使用位操作将旧的颜色值与新的颜色值组合。</p>
<p>在颜色混合中，可以通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendAttachmentState.html"><code>VkPipelineColorBlendAttachmentState</code></a> 来配置每一个附加缓冲区的混合设置，也可以通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineColorBlendStateCreateInfo.html"><code>VkPipelineColorBlendStateCreateInfo</code></a> 来配置全局的混色设置。</p>
<p>结构体 <code>VkPipelineColorBlendAttachmentState</code> 的声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineColorBlendAttachmentState</span> &#123;</span><br><span class="line">    VkBool32                 blendEnable;</span><br><span class="line">    VkBlendFactor            srcColorBlendFactor;</span><br><span class="line">    VkBlendFactor            dstColorBlendFactor;</span><br><span class="line">    VkBlendOp                colorBlendOp;</span><br><span class="line">    VkBlendFactor            srcAlphaBlendFactor;</span><br><span class="line">    VkBlendFactor            dstAlphaBlendFactor;</span><br><span class="line">    VkBlendOp                alphaBlendOp;</span><br><span class="line">    VkColorComponentFlags    colorWriteMask;</span><br><span class="line">&#125; VkPipelineColorBlendAttachmentState;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>blendEnable</td>
<td>启用或禁用颜色混合操作</td>
<td><code>VK_FALSE</code>: 禁用颜色混合操作（即直接使用着色器的输出颜色）。<br/><code>VK_TRUE</code>: 启用颜色混合操作。</td>
</tr>
<tr>
<td>srcColorBlendFactor</td>
<td>源颜色混合因子</td>
<td>指定源颜色混合因子，即源颜色与目标颜色混合时的比例。可选值为<br /><code>VK_BLEND_FACTOR_ZERO </code>： 乘数为零。<br/><code>VK_BLEND_FACTOR_ONE </code>： 乘数为一。<br/><code>VK_BLEND_FACTOR_SRC_COLOR </code>： 使用源颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR </code>： 使用源颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_DST_COLOR </code>： 使用目标颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR </code>： 使用目标颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_SRC_ALPHA </code>： 使用源颜色的alpha通道值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA </code>： 使用源颜色的alpha通道补色作为乘数。<br/><code>VK_BLEND_FACTOR_DST_ALPHA </code>： 使用目标颜色的alpha通道值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA </code>： 使用目标颜色的alpha通道补色作为乘数。<br/><code>VK_BLEND_FACTOR_CONSTANT_COLOR </code>： 使用常量颜色作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR </code>： 使用常量颜色的补色作为乘数。<br/><code>VK_BLEND_FACTOR_CONSTANT_ALPHA </code>： 使用常量alpha值作为乘数。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA </code>： 使用常量alpha值的补色作为乘数。<br/><code>VK_BLEND_FACTOR_SRC_ALPHA_SATURATE </code>： 使用源alpha通道的饱和度（通常用于alpha混合和边缘处理）。<br/><code>VK_BLEND_FACTOR_SRC1_COLOR </code>： 使用第二个源颜色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR </code>： 使用第二个源颜色的补色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_SRC1_ALPHA </code>： 使用第二个源alpha值作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </code>： 使用第二个源alpha值的补色作为乘数（用于多源混合）。<br/><code>VK_BLEND_FACTOR_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>dstColorBlendFactor</td>
<td>目标颜色混合因子</td>
<td>指定目标颜色混合因子，即目标颜色与源颜色混合时的比例。可选值与 <code>srcColorBlendFactor</code> 相同。</td>
</tr>
<tr>
<td>colorBlendOp</td>
<td>颜色值的混合操作</td>
<td>决定了如何将源颜色（来自片段着色器）与目标颜色（来自帧缓冲区）混合。可选值：<br /><code>VK_BLEND_OP_ADD </code>： 源颜色和目标颜色相加（标准的颜色混合操作）。<br/><code>VK_BLEND_OP_SUBTRACT </code>： 源颜色减去目标颜色。<br/><code>VK_BLEND_OP_REVERSE_SUBTRACT </code>： 目标颜色减去源颜色。<br/><code>VK_BLEND_OP_MIN </code>： 选择源颜色和目标颜色中的最小值。<br/><code>VK_BLEND_OP_MAX </code>： 选择源颜色和目标颜色中的最大值。<br/><code>VK_BLEND_OP_ZERO_EXT </code>： 混合时使用零值。<br/><code>VK_BLEND_OP_SRC_EXT </code>： 使用源颜色作为混合结果。<br/><code>VK_BLEND_OP_DST_EXT </code>： 使用目标颜色作为混合结果。<br/><code>VK_BLEND_OP_SRC_OVER_EXT </code>： 源颜色覆盖目标颜色。<br/><code>VK_BLEND_OP_DST_OVER_EXT </code>： 目标颜色覆盖源颜色。<br/><code>VK_BLEND_OP_SRC_IN_EXT </code>： 仅源颜色与目标交集部分进行显示。<br/><code>VK_BLEND_OP_DST_IN_EXT </code>： 仅目标颜色与源交集部分进行显示。<br/><code>VK_BLEND_OP_SRC_OUT_EXT </code>： 显示源颜色，但排除与目标颜色重叠的部分。<br/><code>VK_BLEND_OP_DST_OUT_EXT </code>： 显示目标颜色，但排除与源颜色重叠的部分。<br/><code>VK_BLEND_OP_SRC_ATOP_EXT </code>： 将源颜色“放置”在目标颜色上，仅保留源的交集部分。<br/><code>VK_BLEND_OP_DST_ATOP_EXT </code>： 将目标颜色“放置”在源颜色上，仅保留目标的交集部分。<br/><code>VK_BLEND_OP_XOR_EXT </code>： 仅显示源和目标的非交集部分。<br/><code>VK_BLEND_OP_MULTIPLY_EXT </code>： 乘法模式，常用于阴影效果。<br/><code>VK_BLEND_OP_SCREEN_EXT </code>： 屏幕模式，通常用于高光效果。<br/><code>VK_BLEND_OP_OVERLAY_EXT </code>： 覆盖模式，结合了乘法和屏幕模式。<br/><code>VK_BLEND_OP_DARKEN_EXT </code>： 暗化模式，显示源和目标的较暗部分。<br/><code>VK_BLEND_OP_LIGHTEN_EXT </code>： 亮化模式，显示源和目标的较亮部分。<br/><code>VK_BLEND_OP_COLORDODGE_EXT </code>： 颜色闪避模式，通常用于增强高光效果。<br/><code>VK_BLEND_OP_COLORBURN_EXT </code>： 颜色加深模式，通常用于增加阴影效果。<br/><code>VK_BLEND_OP_HARDLIGHT_EXT </code>： 硬光模式，结合了亮化和暗化的效果。<br/><code>VK_BLEND_OP_SOFTLIGHT_EXT </code>： 柔光模式，通常用于对图像进行柔和的亮化和暗化处理。<br/><code>VK_BLEND_OP_DIFFERENCE_EXT </code>： 差异模式，显示源和目标的差异部分。<br/><code>VK_BLEND_OP_EXCLUSION_EXT </code>： 排除模式，类似于差异模式，但产生更柔和的效果。<br/><code>VK_BLEND_OP_INVERT_EXT </code>： 反转模式，反转目标颜色。<br/><code>VK_BLEND_OP_INVERT_RGB_EXT </code>： 反转RGB模式，反转目标颜色的RGB通道。<br/><code>VK_BLEND_OP_LINEARDODGE_EXT </code>： 线性闪避模式。<br/><code>VK_BLEND_OP_LINEARBURN_EXT </code>： 线性加深模式。<br/><code>VK_BLEND_OP_VIVIDLIGHT_EXT </code>： 鲜明光模式。<br/><code>VK_BLEND_OP_LINEARLIGHT_EXT </code>： 线性光模式。<br/><code>VK_BLEND_OP_PINLIGHT_EXT </code>： 刺光模式。<br/><code>VK_BLEND_OP_HARDMIX_EXT </code>： 硬混合模式。<br/><code>VK_BLEND_OP_HSL_HUE_EXT </code>： 色相模式。<br/><code>VK_BLEND_OP_HSL_SATURATION_EXT </code>： 饱和度模式。<br/><code>VK_BLEND_OP_HSL_COLOR_EXT </code>： 色彩模式。<br/><code>VK_BLEND_OP_HSL_LUMINOSITY_EXT </code>： 明度模式。<br/><code>VK_BLEND_OP_PLUS_EXT </code>： 加法模式。<br/><code>VK_BLEND_OP_PLUS_CLAMPED_EXT </code>： 有限加法模式。<br/><code>VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT </code>： 带alpha的加法模式。<br/><code>VK_BLEND_OP_PLUS_DARKER_EXT </code>： 加法黑暗模式。<br/><code>VK_BLEND_OP_MINUS_EXT </code>： 减法模式。<br/><code>VK_BLEND_OP_MINUS_CLAMPED_EXT </code>： 有限减法模式。<br/><code>VK_BLEND_OP_CONTRAST_EXT </code>： 对比模式。<br/><code>VK_BLEND_OP_INVERT_OVG_EXT </code>： 反转OVG模式。<br/><code>VK_BLEND_OP_RED_EXT </code>： 仅处理红色通道。<br/><code>VK_BLEND_OP_GREEN_EXT </code>： 仅处理绿色通道。<br/><code>VK_BLEND_OP_BLUE_EXT </code>： 仅处理蓝色通道。<br/><code>VK_BLEND_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>srcAlphaBlendFactor</td>
<td>源alpha混合因子</td>
<td>类似于 <code>srcColorBlendFactor</code>，但只影响alpha通道。</td>
</tr>
<tr>
<td>dstAlphaBlendFactor</td>
<td>目标alpha混合因子</td>
<td>类似于 <code>dstColorBlendFactor</code>，但仅影响alpha通道。</td>
</tr>
<tr>
<td>alphaBlendOp</td>
<td>alpha通道的混合操作</td>
<td>与 <code>colorBlendOp</code> 类似，但仅应用于alpha值（透明度）。</td>
</tr>
<tr>
<td>colorWriteMask</td>
<td>参与混合的颜色分量掩码</td>
<td>这个掩码决定了哪些颜色通道的值将会被写入到帧缓冲区，可以通过按位或 &#96;</td>
</tr>
</tbody></table>
<p>一种常用的颜色混合方式为 alpha 混合，在这种情况下，新颜色根据其透明度与旧颜色混合，示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;</span><br><span class="line">colorBlendAttachment.blendEnable = VK_TRUE;</span><br><span class="line">colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</span><br><span class="line">colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;</span><br><span class="line">colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;</span><br></pre></td></tr></table></figure></div>

<p>结构体 <code>VkPipelineColorBlendStateCreateInfo</code> 的声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineColorBlendStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                               sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                   pNext;</span><br><span class="line">    VkPipelineColorBlendStateCreateFlags          flags;</span><br><span class="line">    VkBool32                                      logicOpEnable;</span><br><span class="line">    VkLogicOp                                     logicOp;</span><br><span class="line">    <span class="type">uint32_t</span>                                      attachmentCount;</span><br><span class="line">    <span class="type">const</span> VkPipelineColorBlendAttachmentState*    pAttachments;</span><br><span class="line">    <span class="type">float</span>                                         blendConstants[<span class="number">4</span>];</span><br><span class="line">&#125; VkPipelineColorBlendStateCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</code>，以表明这是一个着色器管线颜色混合创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>通常设置为 <code>0</code>。</td>
</tr>
<tr>
<td>logicOpEnable</td>
<td>启用或禁用逻辑操作</td>
<td>如果设置为 <code>VK_TRUE</code>，则启用按位操作模式，<code>logicOp</code> 字段将指定使用的逻辑操作。如果设置为 <code>VK_FALSE</code>，则使用标准的颜色混合。</td>
</tr>
<tr>
<td>logicOp</td>
<td></td>
<td><code>VK_LOGIC_OP_CLEAR</code>：将结果清空，所有位都设置为 0。<br/><code>VK_LOGIC_OP_AND</code>：按位与操作，两个操作数的相应位都为 1 时，结果才为 1。<br/><code>VK_LOGIC_OP_AND_REVERSE</code>：按位与操作，源操作数与目标操作数按位与操作，但反转源操作数。即源的位与目标的位按位与，源的位要反转。<br/><code>VK_LOGIC_OP_COPY</code>：将源操作数直接拷贝到结果中，不做任何改变。<br/><code>VK_LOGIC_OP_AND_INVERTED </code>：按位与操作，目标操作数与源操作数按位与操作，但反转目标操作数。即源的位与目标的位按位与，目标的位要反转。<br/><code>VK_LOGIC_OP_NO_OP</code>：无操作，不做任何修改。结果等于源操作数。<br/><code>VK_LOGIC_OP_XOR</code>：按位异或操作，相同位的结果为 0，不同位的结果为 1。<br/><code>VK_LOGIC_OP_OR</code>：按位或操作，只要其中一个操作数的位为 1，结果就是 1。<br/><code>VK_LOGIC_OP_NOR</code>：按位或操作的反操作，即按位或的结果反转。只有在源和目标的位都为 0 时，结果为 1。<br/><code>VK_LOGIC_OP_EQUIVALENT</code>：按位等价操作。当两个操作数的位相同时，结果为 1；否则，结果为 0。<br/><code>VK_LOGIC_OP_INVERT</code>：将源操作数的所有位反转。<br/><code>VK_LOGIC_OP_OR_REVERSE</code>：按位或操作，源操作数与目标操作数按位或，但反转源操作数。<br/><code>VK_LOGIC_OP_COPY_INVERTED</code>：将源操作数反转后拷贝到结果中。<br/><code>VK_LOGIC_OP_OR_INVERTED</code>：按位或操作，目标操作数与源操作数按位或，但反转目标操作数。<br/><code>VK_LOGIC_OP_NAND</code>：按位与的反操作，即源和目标的位按位与后结果取反。<br/><code>VK_LOGIC_OP_SET</code>：将结果设置为 1，所有位都设置为 1。<br/><code>VK_LOGIC_OP_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>attachmentCount</td>
<td>颜色附件数组大小</td>
<td>通常设置为1，表示有一个附加的颜色附件。</td>
</tr>
<tr>
<td>pAttachments</td>
<td>颜色附件数组</td>
<td>数组中的每个元素配置了单个颜色附件的混合状态。数组的长度由 <code>attachmentCount</code> 确定，通常只有一个元素。</td>
</tr>
<tr>
<td>blendConstants</td>
<td>混合操作常量数组</td>
<td>在颜色混合操作中，<code>blendConstants</code> 提供了额外的参数，允许你在混合计算中使用常量值。通常，<code>blendConstants</code> 数组中的每个元素都可以用作 <code>colorBlendOp</code> 操作的参数之一。对于 alpha 混合，常常使用其中的 <code>blendConstants[0]</code> 和 <code>blendConstants[1]</code> 等值。</td>
</tr>
</tbody></table>
<p>注意：当 <code>logicOpEnable</code> 设置为 <code>VK_TRUE</code> 时，对于 <code>pAttachments</code> 中的每个元素，<code>blendEnable</code> 将默认为 <code>VK_FALSE</code>。一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineColorBlendStateCreateInfo colorBlending&#123;&#125;;</span><br><span class="line">colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;</span><br><span class="line">colorBlending.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">colorBlending.flags = <span class="number">0</span>;</span><br><span class="line">colorBlending.logicOpEnable = VK_FALSE;</span><br><span class="line">colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.attachmentCount = <span class="number">1</span>;</span><br><span class="line">colorBlending.pAttachments = &amp;colorBlendAttachment;</span><br><span class="line">colorBlending.blendConstants[<span class="number">0</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">1</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">2</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">3</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure></div>

<h2 id="管线布局"><a href="#管线布局" class="headerlink" title="管线布局"></a>管线布局</h2><p>在着色器中，可以使用统一值（uniform values）来动态的决定着色器的行为，比如在顶点着色器中应用<strong>变换矩阵</strong>。在 Vulkan 中，对于统一值的管理需要在着色器创建时通过<strong>管线布局</strong>（Pipeline Layout）来管理。通过 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a> 结构体来描述管线布局信息，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkPipelineLayoutCreateFlags     flags;</span><br><span class="line">    <span class="type">uint32_t</span>                        setLayoutCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">    <span class="type">uint32_t</span>                        pushConstantRangeCount;</span><br><span class="line">    <span class="type">const</span> VkPushConstantRange*      pPushConstantRanges;</span><br><span class="line">&#125; VkPipelineLayoutCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</code>，以表明这是一个着色器管线布局创建信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>flags</td>
<td>附加标志</td>
<td>当设置 <code>VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT</code> 标志时，表示描述符集（Descriptor Sets）在管线布局中的绑定不受管线阶段的影响，即它们是独立的。换句话说，每个描述符集的绑定不会受到管线阶段的影响，从而允许更多的灵活性。其他情况应设置为 <code>0</code>。</td>
</tr>
<tr>
<td>setLayoutCount</td>
<td>描述符集布局数量</td>
<td>管线布局中描述符集布局（descriptor set layout）的数量。可以是 0 或更大的值，指示管线使用了多少个描述符集布局。</td>
</tr>
<tr>
<td>pSetLayouts</td>
<td>描述符集布局数组</td>
<td>指向 <code>VkDescriptorSetLayout</code> 类型数组的指针，描述每个描述符集布局的设置。这个数组的大小由 <code>setLayoutCount</code> 指定。描述符集布局用于定义着色器程序中使用的资源，如纹理、缓冲区等。</td>
</tr>
<tr>
<td>pushConstantRangeCount</td>
<td>推送常量的数量</td>
<td>管线布局中推送常量的数量。推送常量用于在渲染过程中动态修改着色器程序中的某些常量值。</td>
</tr>
<tr>
<td>pPushConstantRanges</td>
<td>推送常量数组</td>
<td>指向 <code>VkPushConstantRange</code> 结构体数组的指针，描述每个推送常量的范围。每个推送常量范围指定了常量的大小、起始位置以及它可以用于哪些着色器阶段（如顶点着色器、片段着色器等）。</td>
</tr>
</tbody></table>
<p>在完成管线布局信息的描述之后，需要通过 <code>vkCreatePipelineLayout</code> 函数来完成管线布局的创建，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreatePipelineLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkPipelineLayoutCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout*                           pPipelineLayout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要创建管线布局的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>创建信息指针</td>
<td>指向 <code>VkPipelineLayoutCreateInfo</code> 结构体的指针，用于描述管线布局的详细信息。该结构体包含了管线布局的创建信息，如描述符集布局、推送常量的范围等。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pPipelineLayout</td>
<td>管线布局对象句柄</td>
<td>函数执行成功后，<code>pPipelineLayout</code> 将返回一个有效的管线布局对象句柄。这个句柄可以在后续创建管线时使用。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示窗口表面是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示窗口创建成功。其他错误码表示创建失败</td>
</tr>
</tbody></table>
<p>在管线布局对象使用完毕后，需要通过函数 <code>vkDestroyPipelineLayout</code> 显式地摧毁，其声明如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyPipelineLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            pipelineLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>要销毁管线布局的逻辑设备。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pipelineLayout</td>
<td>创建信息句斌</td>
<td>要销毁的管线布局对象句柄</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建管线布局对象时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pSetLayouts = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pushConstantRangeCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pPushConstantRanges = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="literal">nullptr</span>, &amp;pipelineLayout) != VK_SUCCESS) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create pipeline layout!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> 固定功能</li>
        <li><strong>作者:</strong> 王小龙</li>
        <li><strong>创建于
                :</strong> 2025-03-20 14:52:08</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-03-20 15:37:42
            </li>
        
        <li>
            <strong>链接:</strong> https://xiaolong-work.github.io/2025/03/20/Vulkan/固定功能/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Vulkan/">#Vulkan</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/03/20/Vulkan/%E5%A4%9A%E5%B8%A7%E5%B9%B6%E8%A1%8C/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">多帧并行</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/03/20/Vulkan/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">模型加载</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">固定功能</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD"><span class="nav-text">固定功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%8A%B6%E6%80%81"><span class="nav-text">动态状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5"><span class="nav-text">顶点输入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%BB%91%E5%AE%9A"><span class="nav-text">顶点绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-text">顶点属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%A3%85%E9%85%8D"><span class="nav-text">输入装配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3%E5%92%8C%E8%A3%81%E5%89%AA%E7%9F%A9%E5%BD%A2"><span class="nav-text">视口和裁剪矩形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3"><span class="nav-text">视口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%81%E5%89%AA%E7%9F%A9%E5%BD%A2"><span class="nav-text">裁剪矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="nav-text">视口创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E5%99%A8"><span class="nav-text">光栅化器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7"><span class="nav-text">多重采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%A8%A1%E7%89%88%E6%B5%8B%E8%AF%95"><span class="nav-text">深度和模版测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E6%B5%8B%E8%AF%95"><span class="nav-text">模版测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="nav-text">深度测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88"><span class="nav-text">颜色混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%BA%BF%E5%B8%83%E5%B1%80"><span class="nav-text">管线布局</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">王小龙</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 23 篇文章
                    </span>
                    
                        <span>
                            共 88.1k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>