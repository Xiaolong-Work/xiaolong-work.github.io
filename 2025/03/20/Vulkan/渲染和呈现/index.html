<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="王小龙">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/03/20/vulkan/渲染和呈现/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="渲染和呈现在 Vulkan 中，渲染一帧图像通常包括以下的步骤：  等待上一帧完成 从交换链获取一张图像 记录一个命令缓冲区，将场景绘制到该图像上 提交已记录的命令缓冲区 呈现交换链图像  同步Vulkan 的核心设计是显式同步，GPU 上的执行顺序需要由开发者通过各种同步原语（synchronization primitives）来定义，明确指示驱动程序按照我们指定的顺序执行操作。许多的 Vul">
<meta property="og:type" content="article">
<meta property="og:title" content="渲染和呈现">
<meta property="og:url" content="http://example.com/2025/03/20/Vulkan/%E6%B8%B2%E6%9F%93%E5%92%8C%E5%91%88%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="渲染和呈现在 Vulkan 中，渲染一帧图像通常包括以下的步骤：  等待上一帧完成 从交换链获取一张图像 记录一个命令缓冲区，将场景绘制到该图像上 提交已记录的命令缓冲区 呈现交换链图像  同步Vulkan 的核心设计是显式同步，GPU 上的执行顺序需要由开发者通过各种同步原语（synchronization primitives）来定义，明确指示驱动程序按照我们指定的顺序执行操作。许多的 Vul">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-20T06:52:08.848Z">
<meta property="article:modified_time" content="2025-03-20T07:37:58.055Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Vulkan">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            渲染和呈现 -
        
        小龙的笔记本
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"小龙的笔记本","subtitle":{"text":[],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.4.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="http://example.com/">
                
                小龙的笔记本
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                <h1 class="article-title-regular">渲染和呈现</h1>
            
            </div>
            
                    
        
        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/%E5%A4%B4%E5%83%8F.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王小龙</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-03-20 14:52:08</span>
        <span class="mobile">2025-03-20 14:52:08</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-20 15:37:58</span>
            <span class="mobile">2025-03-20 15:37:58</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Vulkan/">Vulkan</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>5.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>20 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="渲染和呈现"><a href="#渲染和呈现" class="headerlink" title="渲染和呈现"></a>渲染和呈现</h1><p>在 Vulkan 中，渲染一帧图像通常包括以下的步骤：</p>
<ol>
<li>等待上一帧完成</li>
<li>从交换链获取一张图像</li>
<li>记录一个命令缓冲区，将场景绘制到该图像上</li>
<li>提交已记录的命令缓冲区</li>
<li>呈现交换链图像</li>
</ol>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>Vulkan 的核心设计是<strong>显式同步</strong>，GPU 上的执行顺序需要由开发者通过各种同步原语（synchronization primitives）来定义，明确指示驱动程序按照我们指定的顺序执行操作。许多的 Vulkan API 调用时<strong>异步返回</strong>，而不会<strong>阻塞直到执行完成</strong>。</p>
<p>这意味着如果需要执行的操作有严格的先后顺序，即后一个操作需要等待前一个操作完成时，需要利用 Vulkan 提供的同步机制来确保执行顺序的正确。</p>
<p>以渲染图像为例：</p>
<ol>
<li>从交换链获取一张图像</li>
<li>执行绘制命令，将内容渲染到获取的图像上</li>
<li>将该图像呈现到屏幕上，并将其归还给交换链</li>
</ol>
<p>这些操作的 Vulkan API 调用都是异步执行的，但是这些操作是相互依赖的，因此需要同步机制来确保执行顺序的正确。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量（Semaphores）</strong>用于在<strong>队列操作</strong>之间建立执行顺序，队列操作是所有提交到队列中的任务，例如命令缓冲区，<code>vkQueueSubmit</code> 调用等。常见的 Vulkan 队列包括 <strong>图形队列（graphics queue）</strong> 和 <strong>呈现队列（presentation queue）</strong>。</p>
<p>信号量不仅用于<strong>同一队列内</strong>任务的排序，也用于<strong>不同队列间</strong>的任务同步。</p>
<h4 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h4><p>Vulkan 提供了两种类型的信号量：</p>
<ol>
<li><strong>二进制信号量（Binary Semaphore）</strong>：只能有两种状态：已触发（signaled）或未触发（unsignaled）。</li>
<li><strong>时间线信号量（Timeline Semaphore）</strong>：允许使用递增的计数值进行更精确的同步。</li>
</ol>
<h4 id="信号量的工作过程"><a href="#信号量的工作过程" class="headerlink" title="信号量的工作过程"></a>信号量的工作过程</h4><p>信号量的初始状态为 <strong>未触发（unsignaled）</strong>。我们可以使用它在两个队列操作（A 和 B）之间 <strong>建立执行顺序</strong>。</p>
<ol>
<li>队列操作 A 执行时，设置信号量 S 为触发状态（signaled）</li>
<li>队列操作 B 在执行前，需要等待信号量 S 变为触发状态（signaled）</li>
<li>当 B 开始执行时，信号量 S 会自动重置为未触发状态（unsignaled），以便后续复用</li>
</ol>
<p>伪代码描述如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer A, B = ... <span class="comment">// 记录命令缓冲区</span></span><br><span class="line">VkSemaphore S = ... <span class="comment">// 创建信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 A 任务，并在执行完毕后触发 S</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, signal: S, wait: None)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 B 任务，并等待 S 被触发后才开始执行</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: B, signal: None, wait: S)</span><br></pre></td></tr></table></figure></div>

<p>注意：即使添加了信号量，两次 <code>vkQueueSubmit</code> 调用仍然是非阻塞的，Vulkan 仅在 GPU 上等待信号量触发，而不会阻塞 CPU 的执行。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p><strong>栅栏（Fence）</strong> 的作用与 <strong>信号量（Semaphore）</strong> 类似，其都用于同步操作的执行，但与信号量不同的是，栅栏用于 <strong>CPU和GPU之间</strong> 的同步。</p>
<p>简单来说：如果 GPU 任务需要在另一个 GPU 任务之后执行，使用信号量；如果 CPU 需要等待 GPU 任务完成后再继续执行，我们使用 栅栏。</p>
<h4 id="栅栏的工作过程"><a href="#栅栏的工作过程" class="headerlink" title="栅栏的工作过程"></a>栅栏的工作过程</h4><p>栅栏有两种状态：</p>
<ol>
<li><strong>未触发（unsignaled）</strong>：初始状态。</li>
<li><strong>已触发（signaled）</strong>：当 GPU 任务完成后，栅栏变为 <strong>已触发</strong>，表示 CPU 可以继续执行后续任务。</li>
</ol>
<p>在提交 GPU 任务时，我们可以附加一个 <strong>栅栏（Fence）</strong>，当任务完成时，该栅栏会被 Vulkan <strong>设为已触发状态</strong>。然后，我们可以让 CPU 等待栅栏变为 <strong>已触发</strong>，以确保 GPU 任务完成后，CPU 才继续执行。</p>
<p>例如：假设我们要从 <strong>GPU 传输图像到 CPU</strong>，然后将数据保存到文件。</p>
<ol>
<li>使用命令缓冲区 A 进行图像传输。</li>
<li>创建栅栏 F，并在 GPU 任务完成后触发它。</li>
<li>CPU 等待栅栏 F 触发，然后再将数据保存到文件。</li>
</ol>
<p>伪代码描述如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer A = ... <span class="comment">// 记录命令缓冲区 A（用于图像传输）</span></span><br><span class="line">VkFence F = ... <span class="comment">// 创建栅栏 F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 A 任务，开始执行，任务完成后触发 F</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, fence: F)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU 等待栅栏 F 触发，确保 GPU 任务完成</span></span><br><span class="line"><span class="built_in">vkWaitForFence</span>(F) <span class="comment">// 阻塞 CPU，直到 A 完成执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">save_screenshot_to_disk</span>() <span class="comment">// 只有在传输完成后才会执行</span></span><br></pre></td></tr></table></figure></div>

<p>注意：栅栏会阻塞 CPU 的执行。</p>
<h3 id="信号量与栅栏的选择"><a href="#信号量与栅栏的选择" class="headerlink" title="信号量与栅栏的选择"></a>信号量与栅栏的选择</h3><p>在 Vulkan 渲染循环中，有两个主要的同步点：</p>
<ol>
<li><strong>交换链操作</strong>：发生在 <strong>GPU 内部</strong>，使用 <strong>信号量</strong> 来同步。</li>
<li><strong>等待上一帧完成</strong>：CPU 需要等待 GPU 任务完成，以避免修改 <strong>仍在使用中的命令缓冲区</strong>，因此使用 <strong>栅栏</strong>。</li>
</ol>
<h2 id="创建同步对象"><a href="#创建同步对象" class="headerlink" title="创建同步对象"></a>创建同步对象</h2><h3 id="信号量的创建与销毁"><a href="#信号量的创建与销毁" class="headerlink" title="信号量的创建与销毁"></a>信号量的创建与销毁</h3><p>信号量的创建需要首先填充 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSemaphoreCreateInfo.html"><code>VkSemaphoreCreateInfo</code></a> 结构体，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSemaphoreCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType           sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*               pNext;</span><br><span class="line">    VkSemaphoreCreateFlags    flags;</span><br><span class="line">&#125; VkSemaphoreCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</code>，以表明这是一个信号量创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定信号量创建时的附加标志。</td>
<td>目前没有定义，应设置为 <code>0</code>。</td>
</tr>
</tbody></table>
<p>然后，调用函数 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateSemaphore.html"><code>vkCreateSemaphore</code></a> 来创建信号量，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSemaphoreCreateInfo*                pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore*                                pSemaphore)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建信号量的逻辑设备，表示在哪个设备上创建信号量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>信号量创建信息指针</td>
<td><code>VkSemaphoreCreateInfo</code> 结构体的指针，包含信号量的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。<br />如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pSemaphore</td>
<td>信号量指针</td>
<td>指向 <code>VkSemaphore</code> 句柄的指针，创建成功后，该变量存储信号量的句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示信号量是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示信号量创建成功。<br />其他错误码表示创建失败，例如：<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机（CPU）内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备（GPU）内存不足。</td>
</tr>
</tbody></table>
<p>在信号量使用完毕之后，需要调用函数 <code>vkDestroySemaphore</code> 进行销毁，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroySemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore                                 semaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁信号量的逻辑设备，表示在哪个设备上销毁信号量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>semaphore</td>
<td>信号量句柄</td>
<td>需要销毁的信号量对象的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建信号量时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h3 id="栅栏的创建与销毁"><a href="#栅栏的创建与销毁" class="headerlink" title="栅栏的创建与销毁"></a>栅栏的创建与销毁</h3><p>栅栏的创建需要首先填充  <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkFenceCreateInfo.html"><code>VkFenceCreateInfo</code></a> 结构体，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkFenceCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType       sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*           pNext;</span><br><span class="line">    VkFenceCreateFlags    flags;</span><br><span class="line">&#125; VkFenceCreateInfo;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</code>，以表明这是一个栅栏创建信息结构</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code></td>
</tr>
<tr>
<td>flags</td>
<td>用于指定栅栏创建时的附加标志</td>
<td>可能的值包括：<br /><code>VK_FENCE_CREATE_SIGNALED_BIT</code>：创建栅栏时设置为已触发状态。<br /><code>VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>然后，调用函数 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateFence.html"><code>vkCreateFence</code></a> 来创建栅栏，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateFence</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFenceCreateInfo*                    pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence*                                    pFence)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定创建栅栏的逻辑设备，表示在哪个设备上创建栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pCreateInfo</td>
<td>栅栏创建信息指针</td>
<td><code>VkFenceCreateInfo</code> 结构体的指针，包含栅栏的创建信息。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的分配器。<br />如果需要自定义 Vulkan 的内存分配行为，可以传递指向 <code>VkAllocationCallbacks</code> 的指针。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pFence</td>
<td>栅栏指针</td>
<td>指向 <code>VkFence</code> 句柄的指针，创建成功后，该变量存储栅栏的句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示栅栏是否创建成功</td>
<td><code>VK_SUCCESS</code>：表示栅栏创建成功。<br />其他错误码表示创建失败，例如：<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机（CPU）内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备（GPU）内存不足。</td>
</tr>
</tbody></table>
<p>在栅栏使用完毕之后，需要调用函数 <code>vkDestroyFence</code> 进行销毁，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkDestroyFence</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>指定要销毁栅栏的逻辑设备，表示在哪个设备上销毁栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fence</td>
<td>栅栏句柄</td>
<td>需要销毁的栅栏对象的句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pAllocator</td>
<td>自定义内存分配器</td>
<td>如果为 <code>nullptr</code>，则使用默认的内存分配器。如果在创建信号量时使用了自定义的分配器，则在销毁时需要提供相同的分配器。</td>
</tr>
</tbody></table>
<h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><p>在一个简单的 Vulkan 渲染循环中，需要三个同步对象：</p>
<ol>
<li>一个 信号量来指示交换链中的图像已经准备好进行渲染。</li>
<li>一个 信号量来指示渲染已完成，可以进行显示。</li>
<li>一个 栅栏来确保同一时间只渲染一帧，防止 CPU 过早提交新的命令。</li>
</ol>
<p>一个创建示例如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;</span><br><span class="line">semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line">semaphoreInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">semaphoreInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VkFenceCreateInfo fenceInfo&#123;&#125;;</span><br><span class="line">fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">fenceInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS ||</span><br><span class="line">    <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS ||</span><br><span class="line">    <span class="built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="literal">nullptr</span>, &amp;inFlightFence) != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create semaphores!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroyFence</span>(device, inFlightFence, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="渲染一帧图像"><a href="#渲染一帧图像" class="headerlink" title="渲染一帧图像"></a>渲染一帧图像</h2><h3 id="等待上一帧完成"><a href="#等待上一帧完成" class="headerlink" title="等待上一帧完成"></a>等待上一帧完成</h3><p>在每一帧的开始，需要<strong>等待上一帧的渲染完成</strong>，确保<strong>命令缓冲区（Command Buffer）</strong> 和 <strong>信号量（Semaphore）</strong> 可用。为此，我们需要调用 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkWaitForFences.html"><code>vkWaitForFences</code></a>，其接受一个栅栏数组，并在 CPU 端等待，直到其中 <strong>任意或所有</strong> 栅栏变为已触发状态后再返回，声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkWaitForFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    fenceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFence*                              pFences,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBool32                                    waitAll,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span>                                    timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>等待栅栏所在的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fenceCount</td>
<td>栅栏数组大小</td>
<td>需要等待的栅栏数量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pFences</td>
<td>栅栏数组指针</td>
<td>指向栅栏数组的指针。</td>
</tr>
<tr>
<td>输入参数</td>
<td>waitAll</td>
<td>是否等待所有栅栏</td>
<td>是否等待所有栅栏：<br /><code>VK_TRUE</code>：等待所有。<br /><code>VK_FALSE</code> ：等待任意一个栅栏。</td>
</tr>
<tr>
<td>输入参数</td>
<td>timeout</td>
<td>超时时间</td>
<td>单位为纳秒。如果超时仍未触发，则返回 <code>VK_TIMEOUT</code>。若设为 <code>UINT64_MAX</code>，则无限等待</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示等待结果</td>
<td>常见值包括：<br /><code>VK_SUCCESS</code>：所有需要等待的栅栏都已触发。<br /><code>VK_TIMEOUT</code>：超时时间到达，仍然有栅栏未触发。<br /><code>VK_ERROR_DEVICE_LOST</code>：设备丢失（通常是 GPU 崩溃）。</td>
</tr>
</tbody></table>
<p>在等待完成后，需要调用函数 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkResetFences.html"><code>vkResetFences</code></a> 手动重置栅栏，将其恢复为未触发状态，以便下一帧使用，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkResetFences</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    fenceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFence*                              pFences)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>重置栅栏所在的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fenceCount</td>
<td>栅栏数组大小</td>
<td>需要重置的栅栏数量。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pFences</td>
<td>栅栏数组指针</td>
<td>指向栅栏数组的指针。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>表示重置结果</td>
<td>常见值包括：<br /><code>VK_SUCCESS</code>：成功重置。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足，Fence 无法重置。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足，Fence 无法重置。</td>
</tr>
</tbody></table>
<p>注意：在绘制第一帧时，由于第一帧没有“上一帧”来触发它，<code>vkWaitForFences()</code> 会一直阻塞，导致程序卡死。</p>
<p>有许多方法能够解决这个问题，但最佳实践是：在创建栅栏时就让其处于已触发状态，这样第一帧 <code>vkWaitForFences()</code> 会立即返回，不会阻塞。</p>
<p>其做法是在栅栏创建信息中设置 <code>VK_FENCE_CREATE_SIGNALED_BIT</code> 标志：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br></pre></td></tr></table></figure></div>

<h3 id="从交换链获取图像"><a href="#从交换链获取图像" class="headerlink" title="从交换链获取图像"></a>从交换链获取图像</h3><p>通过调用函数 <code>vkAcquireNextImageKHR</code> 来从交换链中获取图像，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAcquireNextImageKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR                              swapchain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span>                                    timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore                                 semaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pImageIndex)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>device</td>
<td>逻辑设备句柄</td>
<td>进行 Vulkan 操作的逻辑设备句柄。</td>
</tr>
<tr>
<td>输入参数</td>
<td>swapchain</td>
<td>交换链句柄</td>
<td>获取图像的交换链对象。</td>
</tr>
<tr>
<td>输入参数</td>
<td>timeout</td>
<td>超时时间</td>
<td>单位为纳秒，如果设置为 <code>UINT64_MAX</code>，表示无限等待，直到图像可用。</td>
</tr>
<tr>
<td>输入参数</td>
<td>semaphore</td>
<td>信号量句柄</td>
<td>可选信号量，用于同步。当图像可用时，会触发该信号量。<br />不使用时应设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
<tr>
<td>输入参数</td>
<td>fence</td>
<td>栅栏句柄</td>
<td>可选栅栏，用于同步 CPU 线程。当图像可用时，会触发该栅栏。<br />不使用时应设置为 <code>VK_NULL_HANDLE</code>。</td>
</tr>
<tr>
<td>输出参数</td>
<td>pImageIndex</td>
<td>可用图像索引</td>
<td>返回交换链中可用图像的索引。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>获取图像结果</td>
<td>常见的值包括：<br /><code>VK_SUCCESS</code>：成功获取图像。<br /><code>VK_TIMEOUT</code>：超过超时时间，仍然没有可用图像。<br /><code>VK_NOT_READY</code>：没有可用的图像，但不会阻塞。<br /><code>VK_SUBOPTIMAL_KHR</code>：成功获取图像，但交换链的配置不再最优（需要重新创建交换链）。<br /><code>VK_ERROR_OUT_OF_DATE_KHR</code>：交换链已经过期（例如窗口大小发生变化），需要重建交换链。</td>
</tr>
</tbody></table>
<h3 id="记录命令缓冲区"><a href="#记录命令缓冲区" class="headerlink" title="记录命令缓冲区"></a>记录命令缓冲区</h3><p>在记录命令缓冲区之前，需要先调用 <code>vkResetCommandBuffer</code> 以确保命令缓冲区处于可记录状态，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkResetCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBufferResetFlags                   flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>commandBuffer</td>
<td>命令缓冲区句柄</td>
<td>需要重置的命令缓冲区。在重置后，该缓冲区将返回到初始状态，并可重新记录命令。</td>
</tr>
<tr>
<td>输入参数</td>
<td>flags</td>
<td>重置命令缓冲区的附加标志</td>
<td>控制如何重置命令缓冲区，可能的值包括：<br /><code>0</code>（默认）：不执行任何特殊操作。<br /><code>VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT</code>：表示在重置时释放命令缓冲区占用的所有资源。<br /><code>VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>命令缓冲区是否重置成功</td>
<td>可能的值包括：<br /><code>VK_SUCCESS</code>：成功重置命令缓冲区。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足，无法完成操作。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足，无法完成操作。</td>
</tr>
</tbody></table>
<p>注意：只有在 <code>VkCommandPool</code> 创建时未设置 <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> 时，<code>vkResetCommandBuffer</code> 才会返回错误。否则，可以随时重置命令缓冲区。在命令缓冲区处于 <code>VK_COMMAND_BUFFER_STATE_RECORDING</code> 或 <code>VK_COMMAND_BUFFER_STATE_PENDING</code> 状态时，调用 <code>vkResetCommandBuffer</code> 会导致未定义行为。</p>
<p>然后按照 <code>命令缓冲区</code> 中的操作对于命令缓冲区进行记录。</p>
<p>一个调用示例如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line">VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="子通道依赖关系"><a href="#子通道依赖关系" class="headerlink" title="子通道依赖关系"></a>子通道依赖关系</h3><p>在一个渲染通道（render pass）中，子通道（subpasses）会自动处理图像布局转换。这些转换是通过 <strong>子通道依赖关系</strong> 来控制的，子通道依赖关系指定了子通道之间的内存和执行依赖。</p>
<p>在 Vulkan 中，有两个内置的依赖关系，分别处理渲染通道开始时和结束时的图像转换。</p>
<p>但前者并没有在正确的时机发生。它假设转换发生在管线的开始阶段，但在那个时刻我们还没有获取到图像！有两种方法来解决这个问题。我们可以将 <code>imageAvailableSemaphore</code> 的 <code>waitStages</code> 修改为 <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，以确保渲染通道在图像可用之前不会开始；或者我们可以让渲染通道等待 <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> 阶段。</p>
<p>子通道依赖关系通过结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a> 来指定，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubpassDependency</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>                srcSubpass;</span><br><span class="line">    <span class="type">uint32_t</span>                dstSubpass;</span><br><span class="line">    VkPipelineStageFlags    srcStageMask;</span><br><span class="line">    VkPipelineStageFlags    dstStageMask;</span><br><span class="line">    VkAccessFlags           srcAccessMask;</span><br><span class="line">    VkAccessFlags           dstAccessMask;</span><br><span class="line">    VkDependencyFlags       dependencyFlags;</span><br><span class="line">&#125; VkSubpassDependency;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>srcSubpass</td>
<td>源子通道的索引</td>
<td>这个子通道将在依赖关系中作为“源”，即它会先执行。<br /><code>VK_SUBPASS_EXTERNAL</code> 表示外部子通道，通常用于指代渲染通道开始前的隐式子通道。</td>
</tr>
<tr>
<td>dstSubpass</td>
<td>目标子通道的索引</td>
<td>这个子通道将在依赖关系中作为“目标”，即它会在源子通道之后执行。<br /><code>VK_SUBPASS_EXTERNAL</code> 表示外部子通道，通常用于指代渲染通道结束后的隐式子通道。<br /><code>dstSubpass</code> 必须大于 <code>srcSubpass</code> 以避免出现循环依赖，除非 <code>srcSubpass</code> 或 <code>dstSubpass</code> 是 <code>VK_SUBPASS_EXTERNAL</code>。</td>
</tr>
<tr>
<td>srcStageMask</td>
<td>源子通道操作等待的管线阶段</td>
<td>指定源子通道的操作应该在哪些管线阶段<strong>等待</strong>执行。它是一个位掩码，表示所有需要等待的源阶段。例如，<code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> 表示颜色附件输出阶段。<br />如果源子通道中有多个操作，这个字段定义了哪些阶段必须完成才能继续执行目标子通道。</td>
</tr>
<tr>
<td>dstStageMask</td>
<td>目标子通道操作等待的管线阶段</td>
<td>指定目标子通道的操作在哪些管线阶段开始执行。它是一个位掩码，表示目标子通道中的哪些阶段可以执行，只有在源子通道依赖的阶段完成之后。<br />如果目标子通道的操作涉及到颜色附件的写入，可以使用 <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>。</td>
</tr>
<tr>
<td>srcAccessMask</td>
<td>源阶段中等待的内存访问类型</td>
<td>指定源阶段中应该等待哪些类型的内存访问。这是一个位掩码，表示所有相关的内存访问类型（如读取、写入等）。<br />如果源子通道涉及到颜色附件的写入，可以使用 <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>。</td>
</tr>
<tr>
<td>dstAccessMask</td>
<td>目标阶段中等待的内存访问类型</td>
<td>指定目标阶段中涉及的内存访问类型，表示哪些访问必须在源阶段完成之后才能开始。例如，如果目标子通道涉及读取颜色附件的内容，可以使用 <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code>。</td>
</tr>
<tr>
<td>dependencyFlags</td>
<td>设置依赖关系的标志</td>
<td>可选的值包括：<br /><code>0</code>：默认值。<br /><code>VK_DEPENDENCY_BY_REGION_BIT</code>：按区域控制依赖关系。<br/><code>VK_DEPENDENCY_DEVICE_GROUP_BIT</code>：跨设备的依赖关系，通常用于多GPU环境。<br/> <code>VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR</code>：前者的 KHR 扩展别名。<br/><code>VK_DEPENDENCY_VIEW_LOCAL_BIT</code>：局部视图依赖关系，适用于多个渲染目标时。<br/><code>VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR</code>：前者的 KHR 扩展别名。<br /><code>VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT</code>：表示一个反馈循环依赖，通常在图像或计算着色器中使用。<br/><code>VK_DEPENDENCY_FLAG_BITS_MAX_ENUM</code>：保留值。</td>
</tr>
</tbody></table>
<p>一个调用示例如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkSubpassDependency dependency&#123;&#125;;</span><br><span class="line">dependency.srcSubpass = VK_SUBPASS_EXTERNAL;</span><br><span class="line">dependency.dstSubpass = <span class="number">0</span>;</span><br><span class="line">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span><br><span class="line">dependency.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span><br><span class="line">dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;</span><br><span class="line">dependency.dependencyFlags = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h3><p>绘制一帧的最后一步是将渲染结果提交回交换链，呈现通过结构体 <code>VkPresentInfoKHR</code> 来进行配置，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPresentInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                 waitSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*       pWaitSemaphores;</span><br><span class="line">    <span class="type">uint32_t</span>                 swapchainCount;</span><br><span class="line">    <span class="type">const</span> VkSwapchainKHR*    pSwapchains;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pImageIndices;</span><br><span class="line">    VkResult*                pResults;</span><br><span class="line">&#125; VkPresentInfoKHR;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sType</td>
<td>指定结构体的类型</td>
<td>必须设置为 <code>VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</code>，以表明这是一个呈现信息结构。</td>
</tr>
<tr>
<td>pNext</td>
<td>指向扩展信息的指针</td>
<td>如果没有需要使用的扩展，设置为 <code>nullptr</code>。</td>
</tr>
<tr>
<td>waitSemaphoreCount</td>
<td>信号量数组大小</td>
<td>指定 <code>pWaitSemaphores</code> 数组中的信号量数量。</td>
</tr>
<tr>
<td>pWaitSemaphores</td>
<td>信号量数组指针</td>
<td>指定一个信号量数组，在展示前需要等待这些信号量被触发（用于确保渲染完成后再进行展示）。</td>
</tr>
<tr>
<td>swapchainCount</td>
<td>交换链数组大小</td>
<td>交换链的数量，通常为 1。</td>
</tr>
<tr>
<td>pSwapchains</td>
<td>交换链数组指针</td>
<td>指向 <code>VkSwapchainKHR</code> 交换链的指针数组，指定要呈现的交换链。</td>
</tr>
<tr>
<td>pImageIndices</td>
<td>图像索引</td>
<td>指向 <code>uint32_t</code> 数组，每个元素表示 <code>pSwapchains</code> 对应交换链中的图像索引，指定要呈现的图像。</td>
</tr>
<tr>
<td>pResults</td>
<td>呈现结果</td>
<td>可选的 <code>VkResult</code> 数组，用于存储每个交换链的呈现结果，通常为 <code>nullptr</code>。如果多个交换链存在，可以用它来检查每个交换链的单独返回状态。</td>
</tr>
</tbody></table>
<p>然后调用函数 <code>vkQueuePresentKHR</code> 来呈现绘制结果，其声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkQueuePresentKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue                                     queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkPresentInfoKHR*                     pPresentInfo)</span></span>;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>输入参数</td>
<td>queue</td>
<td>队列句柄</td>
<td>负责图像呈现的队列，通常是 <code>presentQueue</code>（必须支持 <code>VK_QUEUE_PRESENT_BIT</code>）。</td>
</tr>
<tr>
<td>输入参数</td>
<td>pPresentInfo</td>
<td>呈现信息指针</td>
<td>指向 <code>VkPresentInfoKHR</code> 结构体，包含交换链信息和同步对象。</td>
</tr>
<tr>
<td>返回值</td>
<td></td>
<td>呈现执行结果</td>
<td>可能的值包括：<br /><code>VK_SUCCESS</code>：呈现成功。<br /><code>VK_SUBOPTIMAL_KHR</code>：呈现成功，但交换链不理想（例如窗口大小发生变化，但仍然可用）。<br /><code>VK_ERROR_OUT_OF_DATE_KHR</code>：交换链已过期（例如窗口大小改变，需要重建交换链）。<br /><code>VK_ERROR_SURFACE_LOST_KHR</code>：表面丢失（可能由于窗口销毁或最小化）。<br /><code>VK_ERROR_DEVICE_LOST</code>：设备丢失，通常是 GPU 崩溃或驱动错误。<br /><code>VK_ERROR_OUT_OF_HOST_MEMORY</code>：主机内存不足。<br /><code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>：设备内存不足。</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>本节的示例函数如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vkWaitForFences</span>(device, <span class="number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取交换链图像 */</span></span><br><span class="line">    <span class="type">uint32_t</span> imageIndex;</span><br><span class="line">    <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录命令缓冲区 */</span></span><br><span class="line">    <span class="built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提交命令缓冲区 */</span></span><br><span class="line">    VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line">    VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">    submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">    submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">    submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFence) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkPresentInfoKHR presentInfo&#123;&#125;;</span><br><span class="line">    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</span><br><span class="line">    presentInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    presentInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pWaitSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line">    VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;</span><br><span class="line">    presentInfo.swapchainCount = <span class="number">1</span>;</span><br><span class="line">    presentInfo.pSwapchains = swapChains;</span><br><span class="line">    presentInfo.pImageIndices = &amp;imageIndex;</span><br><span class="line">    presentInfo.pResults = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> 渲染和呈现</li>
        <li><strong>作者:</strong> 王小龙</li>
        <li><strong>创建于
                :</strong> 2025-03-20 14:52:08</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-03-20 15:37:58
            </li>
        
        <li>
            <strong>链接:</strong> https://xiaolong-work.github.io/2025/03/20/Vulkan/渲染和呈现/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            
            本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
            

        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Vulkan/">#Vulkan</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2025/03/20/Vulkan/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA/"
                        >
                            <span class="left arrow-icon flex-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">深度缓冲区</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2025/03/20/Vulkan/%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">渲染通道</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">渲染和呈现</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E5%92%8C%E5%91%88%E7%8E%B0"><span class="nav-text">渲染和呈现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%85%E6%A0%8F"><span class="nav-text">栅栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E6%A0%85%E6%A0%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">信号量与栅栏的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建同步对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-text">信号量的创建与销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%85%E6%A0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81"><span class="nav-text">栅栏的创建与销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">调用示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F"><span class="nav-text">渲染一帧图像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%B8%8A%E4%B8%80%E5%B8%A7%E5%AE%8C%E6%88%90"><span class="nav-text">等待上一帧完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F"><span class="nav-text">从交换链获取图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">记录命令缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%80%9A%E9%81%93%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-text">子通道依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%88%E7%8E%B0"><span class="nav-text">呈现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">王小龙</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.4.1</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
        ],
        containers: ["#swup"],
    });

    swup.hooks.on("page:view", () => {
        Global.refresh();
    });

    // if (document.readyState === "complete") {
    //
    // } else {
    //     document.addEventListener("DOMContentLoaded", () => init());
    // }
</script>






<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>

<script src="/js/layouts/categoryList.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


</body>
</html>
